{"meta":{"title":"菜菜的blog","subtitle":null,"description":"给自己平时用到的东西做笔记,顺便满足一下写东西的需求","author":"菜菜","url":"https://caicaing.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-03-10T02:03:51.209Z","updated":"2019-12-03T01:21:52.613Z","comments":true,"path":"404.html","permalink":"https://caicaing.github.io/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"个人简介","date":"2020-01-06T08:12:29.089Z","updated":"2019-12-03T03:03:46.646Z","comments":true,"path":"about/index.html","permalink":"https://caicaing.github.io/about/index.html","excerpt":"","text":"热爱游戏热爱代码，并不宅男。"},{"title":"所有分类","date":"2020-01-06T08:12:29.138Z","updated":"2019-12-02T14:42:56.794Z","comments":true,"path":"categories/index.html","permalink":"https://caicaing.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-01-06T08:12:29.128Z","updated":"2019-12-02T14:44:45.145Z","comments":true,"path":"friends/index.html","permalink":"https://caicaing.github.io/friends/index.html","excerpt":"","text":"这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2020-01-06T08:12:28.818Z","updated":"2019-12-03T01:28:44.499Z","comments":true,"path":"mylist/index.html","permalink":"https://caicaing.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-01-06T08:12:29.119Z","updated":"2019-12-03T01:38:53.726Z","comments":true,"path":"tags/index.html","permalink":"https://caicaing.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java多线程","slug":"Java多线程","date":"2020-05-04T07:44:31.000Z","updated":"2020-05-04T07:52:43.857Z","comments":true,"path":"2020/05/04/Java多线程/","link":"","permalink":"https://caicaing.github.io/2020/05/04/Java多线程/","excerpt":"多线程的相关","text":"多线程的相关 Java多线程并发和并行并发：多个不同的事务在同一时间间隔执行。 并行：多个不同的事务在同一时间点上执行。 举一个通俗的例子，假设你是一个厨师，因为太忙了，所以你不得不一下子开两个火同时炒两个菜。你的面前是两个锅，如果你技术高超，一只手负责炒一个锅的菜，左右手同时开工，那么这就是并行，因为你同时在执行这两个任务。而如果你的技术不够高超，先炒一边，然后炒几下又迅速跑到另一边再翻炒几下，这样快速的在两个锅前切换，那么这就是并行，因为你在这两个任务之间快速切换。电脑中的cpu就如同这个例子中的厨子，面对一个个任务，cpu在极短的时间内快速的切换任务进行执行，由于切换时间过短，让人感觉像是在同时执行多个任务。 线程和进程进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 线程的创建继承ThreadThread类本质上是实现了Runnable接口的一个实例。我们通过继承Thread类的方式，并重写run方法，可以创建自己的线程。调用start()方法可以启动线程。并不推荐使用继承Thread类的方式来创建线程对象： 1、Java是单继承，继承了Thread类后不能再继承其他的类。 2、通过继承的方式数据是线程独享的。 123456789101112131415161718192021package com.caicai.threaddemo;/** * @Author: caicai * @Date: 2020/4/20 * @Description: */public class MyThreadTest1 &#123; public static void main(String[] args) &#123; Thread t1 = new Mythread1(); t1.start(); &#125;&#125;class Mythread1 extends Thread&#123; @Override public void run() &#123; System.out.println(\"继承Thread创建多线程\"); &#125;&#125; 实现Runnable接口相比于继承Thread类，使用Runnable更加灵活，即使是类已经继承了其他的父类，仍然可以通过实现Runnable来支持多线程。只需实现Runnable接口即可。 12345678910111213141516171819202122package com.caicai.threaddemo;/** * @Author: caicai * @Date: 2020/4/20 * @Description: */public class MyThreadTest2 &#123; public static void main(String[] args) &#123; Thread t2 = new Thread(new Mythread2()); t2.start(); &#125;&#125;class Mythread2 implements Runnable &#123; @Override public void run() &#123; System.out.println(\"实现Runnable创建线程\"); &#125;&#125; 通过构造方法，将Thread类中的target对象赋值，并且在执行的时候调用target的run方法。 123public Thread(Runnable target) &#123; this(null, target, \"Thread-\" + nextThreadNum(), 0);&#125; 123456@Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 实现Callable接口在jdk1.5之后增加了Callable接口。Callable相对于Runnable有更强大的功能： 相比run方法，可以有返回值 方法可以抛出异常 支持泛型 实现Callable接口的方式不再像前面两种创建Thread对象调用start方法进行执行，而是需要借助FutureTask的run方法来执行。同时调用FutureTask对象的get方法可以获取到线程执行时候的返回值。 123456789101112131415161718192021222324252627282930313233343536package com.caicai.threaddemo;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * @Author: caicai * @Date: 2020/4/20 * @Description: */public class MyThreadTest3 &#123; public static void main(String[] args) &#123; FutureTask&lt;String&gt; futureTask = new FutureTask(new Mythread3()); futureTask.run(); String s = null; try &#123; s = futureTask.get(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println(s); &#125;&#125;class Mythread3 implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println(\"实现Callable创建线程并返回一个值\"); return \"hello world\"; &#125;&#125; 创建线程池Executors.newFixedThreadPool方法创建线程池。对于经常创建、销毁、使用量特别大的资源使用线程池可以很大的提升性能。线程池的基本思路为提前创建好多个线程，放入线程池中，使用的时候直接从线程池里获取，使用完再放回线程池中。使用的优势在于： 可以避免频繁的创建、销毁线程时对资源的浪费，提升响应速度，降低资源的消耗 便于线程的管理，可以通过设置参数来管理线程池中的线程 《阿里巴巴java开发手册》中提到线程池不使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 Executors 返回的线程池对象的弊端如下： FixedThreadPool 和 SingleThreadPool : 允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。 CachedThreadPool 和 ScheduledThreadPool : 允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。 12345678910111213141516171819202122package com.caicai.threaddemo;import java.util.concurrent.*;/** * @Author: caicai * @Date: 2020/4/20 * @Description: */public class MyThreadTest4 &#123; public static void main(String[] args) &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(3, 7, 10, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10)); threadPoolExecutor.execute(new Mythread4()); &#125;&#125;class Mythread4 implements Runnable &#123; @Override public void run() &#123; System.out.println(\"使用线程池创建线程\"); &#125;&#125; ThreadPoolExecutor的构造方法如下 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 名称 类型 含义 corePoolSize int 核心线程池大小 maximumPoolSize int 最大线程数 keepAliveTime long 线程最大空闲时间 unit TImeUnit 时间单位 workQueue BlockingQueue 线程等待队列 threadFactory ThreadFactory 线程创建工厂 handler RejectedExecutionHandler 拒绝策略 线程的生命周期线程的生命周期包括五个阶段，包括：新建、就绪、运行、阻塞、销毁。 新建：使用new 方法new出一个线程，线程就处于新建状态，JVM为线程分配内存，初始化成员变量的值。 就绪：线程调用了start()方法后，线程就处于就绪的状态，JVM为线程创建方法栈和程序计数器。 运行：线程得到了CPU的资源，开始执行，进入运行状态。 阻塞：当发生如下情况时候线程会进入阻塞状态: ​ 1)调用sleep()方法，主动放弃所占用的处理器资源 ​ 2)调用了一个阻塞式IO方法，在该方法返回之前线程被阻塞 ​ 3)线程试图获得一个同步锁，但是该同步锁正在被其他线程持有。 ​ 4)等待通知（notify） ​ 5)调用了suspend()方法挂起了线程，该方法容易导致死锁，不推荐。 死亡：线程会以如下三种方式结束： ​ run()方法或call()方法执行完成，线程正常结束 ​ 线程抛出一个Exception或者Error ​ 调用stop()结束进程，该方法容易导致死锁，不推荐。 线程安全问题如果有多个线程同时运行了一个实现了Runnable接口的类，程序每次运行结果和单线程运行结果是一样的，那么就是线程安全的，否则就是线程不安全的。 举例分析举个例子，有几个窗口共同在卖票，并且所有窗口共享所有的票，这样在卖票时候就可能出现线程安全问题。例子代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.caicai.java;/** * @Author: caicai * @Date: 2020/4/14 * @Description: */public class WindowTest1 &#123; public static void main(String[] args) &#123; Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口一\"); t2.setName(\"窗口二\"); t3.setName(\"窗口三\"); t1.start(); t2.start(); t3.start(); &#125;&#125;class Window1 implements Runnable &#123; private int ticket = 20; @Override public void run() &#123; while (true) &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \":卖票,票号为\" + ticket--); &#125; else &#123; break; &#125; &#125; &#125;&#125; 代码执行后，运行结果如下： 123456789101112131415161718192021222324252627282930窗口三:卖票,票号为19窗口一:卖票,票号为20窗口二:卖票,票号为20窗口二:卖票,票号为18窗口一:卖票,票号为17窗口三:卖票,票号为17窗口二:卖票,票号为16窗口三:卖票,票号为15窗口一:卖票,票号为14窗口二:卖票,票号为13窗口三:卖票,票号为13窗口一:卖票,票号为12窗口二:卖票,票号为11窗口三:卖票,票号为10窗口一:卖票,票号为9窗口二:卖票,票号为8窗口一:卖票,票号为7窗口三:卖票,票号为7窗口三:卖票,票号为6窗口一:卖票,票号为6窗口二:卖票,票号为6窗口三:卖票,票号为4窗口二:卖票,票号为5窗口一:卖票,票号为5窗口三:卖票,票号为3窗口一:卖票,票号为2窗口二:卖票,票号为2窗口三:卖票,票号为1窗口一:卖票,票号为0窗口二:卖票,票号为-1 从运行结果中，我们看到有的一些窗口卖出的票的序号是相同的，甚至还出现了票号为-1的票。这就是所谓的多个对象同时访问一个成员变量所带来的非线程安全问题。 之所以上述例子中出现了线程安全问题是因为ticket这个变量是三个窗口同时共享的，并且这三个卖票的进程存在对共享数据的写操作。所以若有多个线程同时执行写操作我们一般都要考虑线程同步问题。 实现线程同步为了解决上述线程问题，只要在某个线程修改共享资源的时候，让其他线程不能修改该资源，等待修改完毕同步后才能去抢夺CPU资源完成响应的操作。Java引入了7中线程同步机制来解决线程同步问题： 同步代码块（synchronized） 同步方法（synchronized） 同步锁（ReentrantLock） 特殊域变量(volatile) 局部变量(ThreadLocal) 阻塞队列（LinkedBlockingQueue） 原子变量(Atomic*) 同步代码块1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.caicai.java;/** * @Author: caicai * @Date: 2020/4/14 * @Description: */public class WindowTest1 &#123; public static void main(String[] args) &#123; Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口一\"); t2.setName(\"窗口二\"); t3.setName(\"窗口三\"); t1.start(); t2.start(); t3.start(); &#125;&#125;class Window1 implements Runnable &#123; private int ticket = 20; @Override public void run() &#123; while (true) &#123;//使用synchronized包裹要进行同步的代码，synchronized需要一个对象来当做锁，需要同步的不同线程需要用同一个对象当锁 synchronized (this) &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \":卖票,票号为\" + ticket--); &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125; 同步方法123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.caicai.java;/** * @Author: caicai * @Date: 2020/4/14 * @Description: */public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 w = new Window3(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口一\"); t2.setName(\"窗口二\"); t3.setName(\"窗口三\"); t1.start(); t2.start(); t3.start(); &#125;&#125;class Window3 implements Runnable &#123; private int ticket = 20; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125;//使用synchronized来修饰方法，若方法不是静态方法，使用当前对象作为锁（this），若为static方法，使用对象的所属类作为锁（本例中为Window3.class)。 private synchronized void show() &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \":卖票,票号为\" + ticket--); &#125; &#125;&#125; 同步锁1ReentrantLock lock = new ReentrantLock(true);//参数，是否公平锁，若true，公平锁，多个线程都公平拥有执行权，false 非公平独占锁，默认值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.caicai.java;import java.util.concurrent.locks.ReentrantLock;/** * @Author: caicai * @Date: 2020/4/14 * @Description: */public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 w = new Window4(); Window4 w1 = new Window4(); Window4 w2 = new Window4(); Thread t1 = new Thread(w); Thread t2 = new Thread(w1); Thread t3 = new Thread(w2); t1.setName(\"窗口一\"); t2.setName(\"窗口二\"); t3.setName(\"窗口三\"); t1.start(); t2.start(); t3.start(); &#125;&#125;class Window4 implements Runnable &#123; private static int ticket = 20; //创建同步锁，此处把锁声明为了static 因为在main方法中，创建线程的时候用了三个不同的Window4对象 private static ReentrantLock reentrantLock = new ReentrantLock(true); @Override public void run() &#123; while (true) &#123; //在同步代码块前边使用lock加锁，为了确保执行了lock之后，unlock一定能执行，把需要同步的代码放在try里，使用finally确保unlock一定执行。 reentrantLock.lock(); try &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \":卖票,票号为\" + ticket--); &#125; else &#123; break; &#125; &#125; finally &#123; reentrantLock.unlock(); &#125; &#125; &#125;&#125; synchronized和Lock的区别 synchronized是java内置关键字，在JVM层面，Lock是个java类 synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁 synchronized会自动释放锁（a线程执行完同步代码会释放锁，b线程执行过程中发生异常会释放锁），Lock需在finally中手动释放锁（unlock()解锁），否则容易造成线程死锁 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2会一直等待下去。而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了。 synchronized的锁可重入、不可中断、非公平，而Lock锁可重入可判断可公平 Lock锁适合大量同步代码的同步问题，synchronized锁适合代码少量的同步问题。 线程死锁线程死锁是指两个或两个以上的线程互相持有对方所需要的资源，由于synchronized的特性，一个线程持有一个资源，或者说获得一个锁，在该线程释放这个锁之前，其它线程是获取不到这个锁的，而且会一直死等下去，因此这便造成了死锁。举个栗子，两个人一起吃饭，但餐桌上只有一双筷子，秉承着谁先抢到筷子谁先吃的原则两个人开始抢筷子，碰巧一人抢到了一根筷子，对于一般人来说一根筷子显然是没法夹东西的，而两个人对于自己手里抢到的一根筷子都不愿意松手，所以就陷入了无限的等待当中。 产生死锁的必要条件 互斥条件： 进程要求对锁分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程占有。此时若有其他进程请求该资源，则请求进程只能等待。 不可剥夺条件： 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放） 请求与保持条件 进程已经保持了至少一个资源，但又提出了新的资源请求，该资源已经被其他进程占有，此时请求阻塞，但对自己获得的资源保持不放 循环等待条件 存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中的下一个进程所请求。 死锁演示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.caicai.threadlock;/** * @Author: caicai * @Date: 2020/4/21 * @Description: */public class Demo &#123; public static void main(String[] args) &#123; Person1 p1 = new Person1(); Person2 p2 = new Person2(); Thread t1 = new Thread(p1); Thread t2 = new Thread(p2); t1.setName(\"A\"); t2.setName(\"B\"); t1.start(); t2.start(); &#125;&#125;class Person1 implements Runnable &#123; @Override public void run() &#123; synchronized (Chopstick1.class) &#123; System.out.println(Thread.currentThread().getName() + \"拿到了1号筷子去拿2号筷子\"); synchronized (Chopstick2.class) &#123; System.out.println(Thread.currentThread().getName() + \"拿到了所有筷子,吃饭了\"); &#125; &#125; &#125;&#125;class Person2 implements Runnable &#123; @Override public void run() &#123; synchronized (Chopstick2.class) &#123; System.out.println(Thread.currentThread().getName() + \"拿到了2号筷子去拿1号筷子\"); synchronized (Chopstick1.class) &#123; System.out.println(Thread.currentThread().getName() + \"拿到了所有筷子,吃饭了\"); &#125; &#125; &#125;&#125;//一号筷子class Chopstick1 &#123;&#125;//二号筷子class Chopstick2 &#123;&#125; 在上述代码中，分别有Person1，Person2两个类代表两个人，分别叫A和B，Chopstick1、Chopstick2两个类代表两根筷子，分别为1号筷子和2号筷子。当一个人拿到两根筷子后进行吃饭。对于A来说，他先拿取1号筷子，然后去拿2号筷子，B刚好与A相反，他先拿2号筷子再拿1号筷子。运行结果如下： 12B拿到了2号筷子去拿1号筷子A拿到了1号筷子去拿2号筷子 A和B分别抢到了一根筷子等待另一根筷子，然而双方都不愿意放弃自己手中的筷子，造成死锁，程序无限的等待下去。 死锁处理 预防死锁： 通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。 避免死锁 在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。 检测死锁 允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。 解除死锁 当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。 线程通讯对个线程并发执行时，在默认情况下CUP是随机切换线程的，有时我们希望CPU按我们的规律执行线程，此时就需要线程之间的协调通信。 线程通信方式线程间通信常用方式如下： 休眠唤醒的方式： Object的wait、notify、notifyAll Condition的await、signal、signalAll CountDownLatch：用于某个线程A等待若干个其他线程执行完后，他才执行 CyclicBarrier：一组线程等待至某个状态之后再同时执行 Semaphore：用于控制对某组资源的访问权限 wait/notify使用举例 Object.wait()：释放当前对象锁，并进入阻塞队列 Object.notify()：唤醒当前对象阻塞队列里的任一线程（并不保证唤醒哪一个） Object.notifyAll()：唤醒当前对象阻塞队列里的所有线程 使用wait和notify关键字让两个线程交替打印奇数和偶数。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.caicai;/** * @Author: caicai * @Date: 2020/4/22 * @Description: */public class ThreadCommunication &#123; public static void main(String[] args) &#123; OddEvenDemo demo = new OddEvenDemo(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; demo.odd(); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; demo.even(); &#125; &#125;); t1.start(); t2.start(); &#125;&#125;class OddEvenDemo &#123; private int i = 0; public synchronized void odd() &#123; while (i &lt; 10) &#123; if (i % 2 == 1) &#123; System.out.println(\"奇数 \" + i); i++; //唤醒偶数线程 notify(); &#125; else &#123; try &#123; //当前为偶数，进入阻塞， wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public synchronized void even() &#123; while (i &lt; 10) &#123; if (i % 2 == 0) &#123; System.out.println(\"偶数 \" + i); i++; //唤醒奇数线程 notify(); &#125; else &#123; try &#123; //当前为奇数，进入阻塞 wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 注意：wait/notify 要与synchronized一起使用，不然会出现java.lang.IllegalMonitorStateException异常 await/signal使用举例await/signal是Condition接口里的方法，配合lock一起使用也可以完成线程通讯的功能。仍是两个线程交替打印奇数和偶数，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.caicai;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @Author: caicai * @Date: 2020/4/22 * @Description: */public class ThreadCommunication2 &#123; public static void main(String[] args) &#123; OddEvenDemo demo = new OddEvenDemo(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; demo.odd(); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; demo.even(); &#125; &#125;); t1.start(); t2.start(); &#125;&#125;class OddEvenDemo2 &#123; private int i = 0; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void odd() &#123; while (i &lt; 10) &#123; lock.lock(); try &#123; if (i % 2 == 1) &#123; System.out.println(\"奇数 \" + i); i++; condition.signal(); &#125; else &#123; try &#123; condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public void even() &#123; while (i &lt; 10) &#123; lock.lock(); try &#123; if (i % 2 == 0) &#123; System.out.println(\"偶数 \" + i); i++; condition.signal(); &#125; else &#123; try &#123; condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; Object和Condition休眠唤醒的区别 Object wait()必须在synchronized（同步锁）下使用 Object wait()必须通过notify()方法进行唤醒 Condition await()必须和Lock（互斥锁/共享锁）配合使用 Condition await()必须通过signal()方法进行唤醒 CountDownLatch方式 CountDownLatch是在java1.5被引入，存在于java.util.cucurrent包下,跟它一起被引入的工具类还有CyclicBarrier。 CountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。 是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。 Java的concurrent包里面的CountDownLatch其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。 你可以向CountDownLatch对象设置一个初始的数字作为计数值，任何调用这个对象上的await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为0为止。 代码示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.caicai;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @Author: caicai * @Date: 2020/4/22 * @Description: 学生由于疫情原因只能在家进行上网课, 老师需要等到全部学生进入课堂后才开始上课, 假设有20个学生. */public class CountDownLatchDemo &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); CountDownLatch countDownLatch = new CountDownLatch(20); service.execute(new Teacher(countDownLatch)); for (int i = 0; i &lt; 20; i++) &#123; service.execute(new Student(\"学生\" + (i + 1) + \"号\", countDownLatch)); &#125; service.shutdown(); &#125;&#125;class Student implements Runnable &#123; public Student(String name, CountDownLatch countDownLatch) &#123; this.name = name; this.countDownLatch = countDownLatch; &#125; private String name; private CountDownLatch countDownLatch; @Override public void run() &#123; System.out.println(name + \"准备就绪!!\"); countDownLatch.countDown(); &#125;&#125;class Teacher implements Runnable &#123; public Teacher(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; private CountDownLatch countDownLatch; @Override public void run() &#123; System.out.println(\"等待学生进入课堂\"); try &#123; countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"人到齐了,开始上课!\"); &#125;&#125; 运行结果： 12345678910111213141516171819202122等待学生进入课堂学生6号准备就绪!!学生1号准备就绪!!学生8号准备就绪!!学生7号准备就绪!!学生5号准备就绪!!学生4号准备就绪!!学生3号准备就绪!!学生2号准备就绪!!学生10号准备就绪!!学生9号准备就绪!!学生11号准备就绪!!学生13号准备就绪!!学生16号准备就绪!!学生18号准备就绪!!学生12号准备就绪!!学生20号准备就绪!!学生19号准备就绪!!学生17号准备就绪!!学生15号准备就绪!!学生14号准备就绪!!人到齐了,开始上课! 上述例子中每创建一个学生线程都使用countDown()方法来减少一个计数，countDown方法的注释大意如下： 1减少锁存器的计数，如果计数达到零，则释放所有等待线程。如果当前计数大于零，则将其递减。如果新计数为零，则出于线程调度的目的，将重新启用所有等待线程。如果当前计数等于零，那么什么也不会发生。 CyclicBarrierCyclicBarrier也是在jdk1.5后被引入的。CyclicBarrier让一组线程都处于某个状态后在全部同时执行。CyclicBarrier的底层是基于ReentrantLock和Condition的实现。代码示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.caicai;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @Author: caicai * @Date: 2020/4/22 * @Description: * 三个爬山爱好者,约定在山脚下,半山腰,山顶分别集合一次再进行下一步活动. */public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); CyclicBarrier cyclicBarrier = new CyclicBarrier(3,()-&gt;&#123; System.out.println(Thread.currentThread().getName() +\"最后到达,大家都到了我来晚了抱歉,继续进行下一步吧\"); &#125;); for (int i = 1; i &lt; 4; i ++)&#123; service.execute(new Person(cyclicBarrier,i+\"号\")); &#125; service.shutdown(); &#125;&#125;class Person implements Runnable &#123; public Person(CyclicBarrier cyclicBarrier, String name) &#123; this.cyclicBarrier = cyclicBarrier; this.name = name; &#125; public String getName() &#123; return name; &#125; private CyclicBarrier cyclicBarrier; private String name; @Override public void run() &#123; try &#123; System.out.println(getName() + \"到达山脚下\"); cyclicBarrier.await(); System.out.println(getName() + \"从山脚下出发\"); Thread.sleep(1000); System.out.println(getName() + \"到达半山腰\"); cyclicBarrier.await(); System.out.println(getName() + \"从半山腰出发\"); Thread.sleep(1000); System.out.println(getName() + \"到达山顶\"); cyclicBarrier.await(); System.out.println(getName() + \"与大家庆祝拍照留念\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 代码运行结果如下： 1234567891011121314151617181920212号到达山脚下3号到达山脚下1号到达山脚下pool-1-thread-3最后到达,大家都到了我来晚了抱歉,继续进行下一步吧3号从山脚下出发2号从山脚下出发1号从山脚下出发1号到达半山腰3号到达半山腰2号到达半山腰pool-1-thread-2最后到达,大家都到了我来晚了抱歉,继续进行下一步吧2号从半山腰出发1号从半山腰出发3号从半山腰出发1号到达山顶2号到达山顶3号到达山顶pool-1-thread-3最后到达,大家都到了我来晚了抱歉,继续进行下一步吧3号与大家庆祝拍照留念1号与大家庆祝拍照留念2号与大家庆祝拍照留念 从打印结果可以看出，所有线程会等待全部线程到达之后才会继续执行，并且最后到达的线程会完成 Runnable 的任务。 CyclicBarrier 与 CountDownLatch 区别 CountDownLatch CyclicBarrier 减计数方式 加计数方式 计算为0时释放所有等待的线程 计数达到指定值时释放所有等待线程 计数为0时，无法重置 计数达到指定值时，计数置为0重新开始 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 不可重复利用 可重复利用 线程在countDown()之后，会继续执行自己的任务 所有线程任务结束之后，才会进行后续任务 Semaphore方式Semaphore是java1.5被引入，存在于java.util.concurrent包下 Semaphore用于控制线程的并发数量。假设疫情期间有一个商店为了防止人数过多，要求大家排队，每次只允许两个消费者进店消费。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.caicai;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;/** * @Author: caicai * @Date: 2020/4/23 * @Description: */public class SemaphoreDemo &#123; public static void main(String[] args) &#123; Semaphore semaphore = new Semaphore(2); ExecutorService e = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; e.execute(new Consumer(semaphore, i)); &#125; e.shutdown(); &#125;&#125;class Consumer implements Runnable &#123; private Semaphore semaphore; private Integer id; public Consumer(Semaphore semaphore, Integer id) &#123; this.semaphore = semaphore; this.id = id; &#125; @Override public void run() &#123; try &#123; semaphore.acquire(); System.out.println(id + \"号消费者进店购买\"); Thread.sleep(2000); System.out.println(id + \"号消费者离开\"); semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 代码运行结果如下： 12345678910111213141516171819200号消费者进店购买1号消费者进店购买1号消费者离开0号消费者离开4号消费者进店购买2号消费者进店购买2号消费者离开4号消费者离开5号消费者进店购买6号消费者进店购买5号消费者离开6号消费者离开3号消费者进店购买7号消费者进店购买3号消费者离开7号消费者离开8号消费者进店购买9号消费者进店购买9号消费者离开8号消费者离开 通过使用Semaphore的acquire()方法和release()方法实现控制并发线程的数量。此外使用acquire(int permits)方法可以让一个线程占据自定义个许可。对应的release(int permits) 来释放指定许可。 多线程特性多线程编程要保证满足三个特性：原子性、可见性、有序性。 原子性原子性是指一个操作或者多个操作要么全部执行并且执行的过程中不会被任何因素打断，要么就不执行。 可见性可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。对于多线程，不存在可见性问题。 有序性有序性即程序执行的顺序按照代码的先后顺序执行。 多线程控制类为了保证多线程的三个特性，Java引入了很多线程控制机制: ThreadLocal:线程本地变量 原子类：保证变量原子操作 Lock类：保证线程有序性 Volatile关键字：保证线程变量可见性 ThreadLocal作用官方解释如下： 12345678/** * This class provides thread-local variables. These variables differ from * their normal counterparts in that each thread that accesses one (via its * &#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized * copy of the variable. &#123;@code ThreadLocal&#125; instances are typically private * static fields in classes that wish to associate state with a thread (e.g., * a user ID or Transaction ID). */ 大致意思是说该类为每个线程都提供了一个自己独立的变量，通过get和set方法就可以对本线程的变量进行操作。 应用场景在Java的多线程编程中，为保证多个线程对共享变量的安全访问，通常会使用synchronized来保证同一时刻只有一个线程对共享变量进行操作。这种情况下可以将类变量放到ThreadLocal类型的对象中，使变量在每个线程中都有独立拷贝，不会出现一个线程读取变量时而被另一个线程修改的现象。最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。 举个栗子两个人都在同一个银行里进行存款，银行是相同的，但是用户的账户余额应该是独立的，用ThreadLocal完成此功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.caicai;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @Author: caicai * @Date: 2020/4/30 * @Description: */public class ThreadLocalDemo &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Bank b = new Bank(); executorService.execute(new Transfer(b)); executorService.execute(new Transfer(b)); executorService.shutdown(); &#125;&#125;class Bank &#123; private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;() &#123; @Override protected Integer initialValue() &#123; return 0; &#125; &#125;; public Integer get() &#123; return threadLocal.get(); &#125; public void set(Integer value) &#123; threadLocal.set(value + threadLocal.get()); &#125;&#125;class Transfer implements Runnable&#123; private Bank bank ; Transfer(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++)&#123; Integer integer = bank.get(); int v = (int) (Math.random() * 10); bank.set(v); System.out.println(\"原来余额\" +integer+\", \"+Thread.currentThread().getName() +\"向银行存了\" + v +\"元,余额为\" +bank.get() +\"元\"); &#125; &#125;&#125; 运行结果如下 1234567891011121314151617181920原来余额0, pool-1-thread-1向银行存了0元,余额为0元原来余额0, pool-1-thread-2向银行存了4元,余额为4元原来余额0, pool-1-thread-1向银行存了0元,余额为0元原来余额4, pool-1-thread-2向银行存了2元,余额为6元原来余额0, pool-1-thread-1向银行存了9元,余额为9元原来余额6, pool-1-thread-2向银行存了9元,余额为15元原来余额9, pool-1-thread-1向银行存了8元,余额为17元原来余额15, pool-1-thread-2向银行存了2元,余额为17元原来余额17, pool-1-thread-1向银行存了3元,余额为20元原来余额17, pool-1-thread-2向银行存了3元,余额为20元原来余额20, pool-1-thread-1向银行存了2元,余额为22元原来余额20, pool-1-thread-2向银行存了7元,余额为27元原来余额22, pool-1-thread-1向银行存了9元,余额为31元原来余额27, pool-1-thread-2向银行存了0元,余额为27元原来余额31, pool-1-thread-1向银行存了0元,余额为31元原来余额27, pool-1-thread-2向银行存了7元,余额为34元原来余额31, pool-1-thread-1向银行存了6元,余额为37元原来余额34, pool-1-thread-2向银行存了1元,余额为35元原来余额37, pool-1-thread-1向银行存了6元,余额为43元原来余额35, pool-1-thread-2向银行存了7元,余额为42元 可以看线程1和线程2都在向银行里进行存款，两个用户的存款余额是独立的 原子类Java的java.util.concurrent.atomic包里提供了很多可以进行原子操作的类，分为以下四类： 原子更新基本类型：AtomicInteger、AtomicBoolean、AtomicLong 原子更新数组类型：AtomicIntegerArray、AtomicLongArray 原子更新引用类型：AtomicReference、AtomicStampedReference 原子更新属性类型：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 提供这些原子类的目的是为了解决基本类型操作的非原子性导致在多线程并发访问情况下引发的问题。 非原子性操作问题演示使用两个线程同时对n进行++操作，观察n的最终值。 n++操作并不是原子操作，虽然他只有一行，它由三个操作组成: 123tp1 = n;tp2 = tp1 + 1;n = tp2; 所以如果只是单线程下，n的值不会有问题，但是在多线程情况下就有可能出错。示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940package com.caicai;/** * @Author: caicai * @Date: 2020/4/30 * @Description: */public class ThreadAtomicDemo &#123; private static int n = 0; public static void main(String[] args) &#123; int j = 0; while(j&lt;20)&#123; n= 0; Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 1000; i++) &#123; n++; &#125; &#125;); Thread thread1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 1000; i++) &#123; n++; &#125; &#125;); thread.start(); thread1.start(); try &#123; thread.join(); thread1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(n); j++; &#125; &#125;&#125; 运行结果如下： 123456789101112131415161718192020001627200020002000200020002000200020002000200020002000200020002000200020002000 两个线程每个执行了1000次n++操作，理论上讲n的最终值应该是2000，但是从结果中可以看到出现了为1627的值。这也证明了++操作在 多线程情况下是不安全的 原子类解决非原子性操作问题AtomicInteger类可以保证++操作的原子性： getAndIncrement()：对应n++ incrementAndGet()：对应++n decrementAndGet()：对应–n getAndDecrement()：对应n– 修改代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.caicai;import java.util.concurrent.atomic.AtomicInteger;/** * @Author: caicai * @Date: 2020/4/30 * @Description: */public class ThreadAtomicDemo &#123;// private static int n = 0; private static AtomicInteger n ; public static void main(String[] args) &#123; int j = 0; while(j&lt;20)&#123; n= new AtomicInteger(0);//创建原子整数,初始值为0 Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 1000; i++) &#123; n.getAndIncrement(); &#125; &#125;); Thread thread1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 1000; i++) &#123; n.getAndIncrement(); &#125; &#125;); thread.start(); thread1.start(); try &#123; thread.join(); thread1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(n); j++; &#125; &#125;&#125; CAS算法和ABA问题乐观锁和悲观锁的概念 悲观锁：悲观锁认为自己执行的操作过程中一定会有人修改自己操作的值，所以在自己操作之前一定会加上一把锁。Synchronized就是一个悲观锁。 乐观锁：乐观锁每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。 CAS算法CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。 CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。 在AtomicInteger对象实现n++操作的函数getAndIncrement中就使用了CAS 123public final int getAndIncrement() &#123; return U.getAndAddInt(this, VALUE, 1);&#125; 上述代码的U是AtomicInteger中一个Unsafe的对象。 1private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe(); Unsafe是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地native方法来访问，尽管如此，JVM还是开了一个后门：Unsafe它提供了硬件级别的原子操作。 123456789101112131415161718 /** * Atomically adds the given value to the current value of a field * or array element within the given object &#123;@code o&#125; * at the given &#123;@code offset&#125;. * * @param o object/array to update the field/element in * @param offset field/element offset * @param delta the value to add * @return the previous value * @since 1.8 */public final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta)); return v;&#125; getIntVolatile方法拿到内存位置的最新值v，使用CAS尝试将内存位置的值v修改为目标值v+delta，如果修改失败，则获取该内存位置的新值v，然后继续尝试，直至修改成功。 CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” 通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。 类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。 CAS缺点CAS搞笑的解决了原子操作问题，但是CAS仍然存在问题 循环时间长开销很大。 只能保证一个共享变量的原子操作。 ABA问题 ABA问题因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 使用AtomicStampedReference解决ABA问题AtomicStampedReference主要方法： AtomicStampedReference（初始值，时间戳）：构造函数，设置初始值和初始时间戳 getStamp：获取时间戳 getReference：获取预期值 compareAndSet(预期值，更新至，预期时间戳，更新时间戳)实现CAS时间戳和预期值的比对 compareAndSet和weakCompareAndSet的差别： weakCompareAndSet无法保证处理操作目标的volatile变量外的其他变量的执行顺序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.caicai;import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.atomic.AtomicStampedReference;/** * @Author: caicai * @Date: 2020/4/30 * @Description: */public class ThreadAtomicDemo &#123; // private static int n = 0;// private static AtomicInteger n ; private static AtomicStampedReference&lt;Integer&gt; atomicInteger; public static void main(String[] args) &#123; int j = 0; while (j &lt; 20) &#123; atomicInteger = new AtomicStampedReference(0, 0);//创建原子整数,初始值为0 Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 1000; i++) &#123; int stamp; Integer reference; do &#123; reference = atomicInteger.getReference(); stamp = atomicInteger.getStamp(); &#125; while (!atomicInteger.weakCompareAndSet(reference, reference + 1, stamp, stamp + 1)); &#125; &#125;); Thread thread1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 1000; i++) &#123; int stamp; Integer reference; do &#123; reference = atomicInteger.getReference(); stamp = atomicInteger.getStamp(); &#125; while (!atomicInteger.weakCompareAndSet(reference, reference + 1, stamp, stamp + 1)); &#125; &#125;); thread.start(); thread1.start(); try &#123; thread.join(); thread1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicInteger.getReference()); j++; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://caicaing.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://caicaing.github.io/tags/多线程/"}]},{"title":"Java创建多线程的四种方式","slug":"Java创建多线程的四种方式","date":"2020-04-20T01:54:06.000Z","updated":"2020-04-20T03:13:02.168Z","comments":true,"path":"2020/04/20/Java创建多线程的四种方式/","link":"","permalink":"https://caicaing.github.io/2020/04/20/Java创建多线程的四种方式/","excerpt":"介绍Java创建多线程的四种方式。","text":"介绍Java创建多线程的四种方式。 Java创建多线程的四种方式继承ThreadThread类本质上是实现了Runnable接口的一个实例。我们通过继承Thread类的方式，并重写run方法，可以创建自己的线程。调用start()方法可以启动线程。并不推荐使用继承Thread类的方式来创建线程对象： 1、Java是单继承，继承了Thread类后不能再继承其他的类。 2、通过继承的方式数据是线程独享的。 123456789101112131415161718192021package com.caicai.threaddemo;/** * @Author: caicai * @Date: 2020/4/20 * @Description: */public class MyThreadTest1 &#123; public static void main(String[] args) &#123; Thread t1 = new Mythread1(); t1.start(); &#125;&#125;class Mythread1 extends Thread&#123; @Override public void run() &#123; System.out.println(\"继承Thread创建多线程\"); &#125;&#125; 实现Runnable接口相比于继承Thread类，使用Runnable更加灵活，即使是类已经继承了其他的父类，仍然可以通过实现Runnable来支持多线程。只需实现Runnable接口即可。 12345678910111213141516171819202122package com.caicai.threaddemo;/** * @Author: caicai * @Date: 2020/4/20 * @Description: */public class MyThreadTest2 &#123; public static void main(String[] args) &#123; Thread t2 = new Thread(new Mythread2()); t2.start(); &#125;&#125;class Mythread2 implements Runnable &#123; @Override public void run() &#123; System.out.println(\"实现Runnable创建线程\"); &#125;&#125; 通过构造方法，将Thread类中的target对象赋值，并且在执行的时候调用target的run方法。 123public Thread(Runnable target) &#123; this(null, target, \"Thread-\" + nextThreadNum(), 0);&#125; 123456@Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 实现Callable接口在jdk1.5之后增加了Callable接口。Callable相对于Runnable有更强大的功能： 相比run方法，可以有返回值 方法可以抛出异常 支持泛型 实现Callable接口的方式不再像前面两种创建Thread对象调用start方法进行执行，而是需要借助FutureTask的run方法来执行。同时调用FutureTask对象的get方法可以获取到线程执行时候的返回值。 123456789101112131415161718192021222324252627282930313233343536package com.caicai.threaddemo;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * @Author: caicai * @Date: 2020/4/20 * @Description: */public class MyThreadTest3 &#123; public static void main(String[] args) &#123; FutureTask&lt;String&gt; futureTask = new FutureTask(new Mythread3()); futureTask.run(); String s = null; try &#123; s = futureTask.get(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println(s); &#125;&#125;class Mythread3 implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println(\"实现Callable创建线程并返回一个值\"); return \"hello world\"; &#125;&#125; ## 创建线程池 Executors.newFixedThreadPool方法创建线程池。对于经常创建、销毁、使用量特别大的资源使用线程池可以很大的提升性能。线程池的基本思路为提前创建好多个线程，放入线程池中，使用的时候直接从线程池里获取，使用完再放回线程池中。使用的优势在于： 可以避免频繁的创建、销毁线程时对资源的浪费，提升响应速度，降低资源的消耗 便于线程的管理，可以通过设置参数来管理线程池中的线程 《阿里巴巴java开发手册》中提到线程池不使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 Executors 返回的线程池对象的弊端如下： FixedThreadPool 和 SingleThreadPool : 允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。 CachedThreadPool 和 ScheduledThreadPool : 允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。 12345678910111213141516171819202122package com.caicai.threaddemo;import java.util.concurrent.*;/** * @Author: caicai * @Date: 2020/4/20 * @Description: */public class MyThreadTest4 &#123; public static void main(String[] args) &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(3, 7, 10, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10)); threadPoolExecutor.execute(new Mythread4()); &#125;&#125;class Mythread4 implements Runnable &#123; @Override public void run() &#123; System.out.println(\"使用线程池创建线程\"); &#125;&#125; ThreadPoolExecutor的构造方法如下 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 名称 类型 含义 corePoolSize int 核心线程池大小 maximumPoolSize int 最大线程数 keepAliveTime long 线程最大空闲时间 unit TImeUnit 时间单位 workQueue BlockingQueue 线程等待队列 threadFactory ThreadFactory 线程创建工厂 handler RejectedExecutionHandler 拒绝策略","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://caicaing.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://caicaing.github.io/tags/多线程/"}]},{"title":"Java ArrayList","slug":"Java-ArrayList","date":"2020-03-15T12:40:32.000Z","updated":"2020-03-16T01:27:40.005Z","comments":true,"path":"2020/03/15/Java-ArrayList/","link":"","permalink":"https://caicaing.github.io/2020/03/15/Java-ArrayList/","excerpt":"Java ArrayList","text":"Java ArrayList ArrayListArrayList简介ArrayList就是动态数组，是Array的复杂版本。List 接口的大小可变数组的实现，位于API文档的java.util.ArrayList。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。（此类大致上等同于 Vector 类，除了此类是不同步的）。 ArrayList 变量12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList继承了AbstractList类，并且实现了一系列的接口。 DEFAULT_CAPACITY1private static final int DEFAULT_CAPACITY = 10; 数组初始默认容量 EMPTY_ELEMENTDATA1private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 用于空实例的共享空数组实例。 DEFAULTCAPACITY_EMPTY_ELEMENTDATA1private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 默认数组初始化状态。 elementData1transient Object[] elementData; // non-private to simplify nested class access 数据的存储数组 sizea1private int size; 列表中实际存在的元素个数 ArrayList方法构造方法123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 默认的构造方法，把存放数据的数组初始华为默认的数组，DEFAULTCAPACITY_EMPTY_ELEMENTDATA默认为空。 12345678910public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125; 此构造方法中，若传入的值合法，则将存放数据的数组长度设置为传入的值。 123456789101112public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // defend against c.toArray (incorrectly) not returning Object[] // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 传入一个集合，把集合中的所有数据都拷贝到ArrayList的存储数组中。 contains(Object o)123public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; 判断List中是否包含某个对象，本质上是调用了indexOf方法 indexOf(Object o)123public int indexOf(Object o) &#123; return indexOfRange(o, 0, size);&#125; 1234567891011121314151617int indexOfRange(Object o, int start, int end) &#123; Object[] es = elementData; if (o == null) &#123; for (int i = start; i &lt; end; i++) &#123; if (es[i] == null) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = start; i &lt; end; i++) &#123;//对象不为空，遍历存储数组，找到返回索引，否则-1 if (o.equals(es[i])) &#123; return i; &#125; &#125; &#125; return -1;&#125; lastIndexOf(Object o)123public int lastIndexOf(Object o) &#123; return lastIndexOfRange(o, 0, size);&#125; 从后往前寻找第一次出现的元素，本质上是反向遍历存储数组 1234567891011121314151617int lastIndexOfRange(Object o, int start, int end) &#123; Object[] es = elementData; if (o == null) &#123; for (int i = end - 1; i &gt;= start; i--) &#123; if (es[i] == null) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = end - 1; i &gt;= start; i--) &#123; if (o.equals(es[i])) &#123; return i; &#125; &#125; &#125; return -1;&#125; clone()1234567891011public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125;&#125; 获得一个与当前链表一样的副本，深拷贝。 toArray()123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125; 将list转化为Object类型的数组 123456789public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a;&#125; 将list转化为传入类型的数组，当传入的数组长度小于链表数据长度时候，会返回一个新的数组，a不发生改变，当传入的数组长度大于等于链表数据长度时候，会直接将数据拷贝到a中并返回a。 System.arraycopy和Arrays.copyOf的区别： System.arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置 Arrays.copyOf()是系统自动在内部新建一个数组，调用arraycopy()将original内容复制到copy中去，并且长度为newLength。返回copy; 即将原数组拷贝到一个长度为newLength的新数组中，并返回该数组。 Array.copyOf()可以看作是受限的System.arraycopy(),它主要是用来将原数组全部拷贝到一个新长度的数组，适用于数组扩容。 get(int index)123public E get(int index) &#123; Objects.checkIndex(index, size); //判断index 是否越界 return elementData(index); set(int index, E element)123456public E set(int index, E element) &#123; Objects.checkIndex(index, size); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; Set 方法将index位置的对象设置为传入的对象，并且返回原来的对象 add(E e)12345public boolean add(E e) &#123; modCount++;//增加修改次数 add(e, elementData, size); return true;&#125; 123456private void add(E e, Object[] elementData, int s) &#123; if (s == elementData.length) elementData = grow(); //数组空间满了 进行扩容 elementData[s] = e; size = s + 1;&#125; 扩容函数如下： 1234567891011private Object[] grow(int minCapacity) &#123; int oldCapacity = elementData.length; if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; int newCapacity = ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, /* minimum growth */ oldCapacity &gt;&gt; 1 /* preferred growth */); return elementData = Arrays.copyOf(elementData, newCapacity); &#125; else &#123; return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)]; &#125;&#125; remove(int index)1234567public E remove(int index) &#123; Objects.checkIndex(index, size);//判断是否越界 final Object[] es = elementData; @SuppressWarnings(\"unchecked\") E oldValue = (E) es[index]; fastRemove(es, index); return oldValue; 1234567private void fastRemove(Object[] es, int i) &#123; modCount++; final int newSize; if ((newSize = size - 1) &gt; i) System.arraycopy(es, i + 1, es, i, newSize - i);//把i+1后的元素全部向前覆盖一个位置 es[size = newSize] = null;&#125; size()123public int size() &#123; return size;&#125; 获得List的长度 isEmpty()123public boolean isEmpty() &#123; return size == 0;&#125; 判断List是否为空 trimToSize()12345678public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; 把数组长度改变为当前实际存在数据的大小。 ArrayList遍历123456789101112131415161718192021222324252627private static void method04(ArrayList&lt;Integer&gt; arrayList) &#123; arrayList.forEach((i)-&gt;&#123; System.out.println(i); &#125;);&#125;private static void method03(ArrayList&lt;Integer&gt; arrayList) &#123; for (Integer integer : arrayList)&#123; System.out.println(integer); &#125;&#125;private static void method02(ArrayList&lt;Integer&gt; arrayList) &#123; Iterator&lt;Integer&gt; iterator = arrayList.iterator(); while (iterator.hasNext())&#123; Integer next = iterator.next(); System.out.println(next); &#125;&#125;private static void method01(ArrayList&lt;Integer&gt; arrayList) &#123; for(int i = 0; i &lt; arrayList.size(); i++)&#123; System.out.println(arrayList.get(i)); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://caicaing.github.io/tags/Java/"},{"name":"List","slug":"List","permalink":"https://caicaing.github.io/tags/List/"}]},{"title":"HashMap源码分析","slug":"HashMap源码分析","date":"2020-03-10T02:02:38.000Z","updated":"2020-03-11T03:40:40.755Z","comments":true,"path":"2020/03/10/HashMap源码分析/","link":"","permalink":"https://caicaing.github.io/2020/03/10/HashMap源码分析/","excerpt":"Java HashMap 源码分析 本文所使用jdk为jdk13","text":"Java HashMap 源码分析 本文所使用jdk为jdk13 HashMap源码分析HashMap简介基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低） 12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125; 从类的定义可以看到HashMap继承了AbstractMap类，并且实现了Map、Cloneable、Serializable接口 HashMap数据结构存储数组1Node&lt;K,V&gt;[] table; 在java8后，使用Node类型的数组来存储键值对数据。Node是一个实现了Map.Entry接口的自定义类。 1static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;&#125; Node的主要参数有 1234final int hash; //哈希值final K key; //键V value; //值Node&lt;K,V&gt; next; //连接的下一个节点 存储方式在java8之前，HashMap的存储方式为数组+链表，数组是HashMap的主体，链表（拉链法）是为了解决哈希碰撞（两个对象在经过哈希计算后得到的索引值相同）的情况。java8后HashMap的存储方式为数组+链表+红黑树。当HashMap中链表的长度大于8并且当前数组的长度大约64，则把索引位置上的链表转化为红黑树存储数据。提高了大量数据下的查找效率。 重要参数默认初始容量1static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 默认的初始容量为16，规定了默认的初始容量为2的幂。 最大容量1static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 最大容量为节点数组所能开辟的最大个数，如果指定了更大的值则使用最大容量的值。 默认负载因子1static final float DEFAULT_LOAD_FACTOR = 0.75f; 在构造函数中如果没有显式的指定负载因子的值则使用默认的负载因子值：0.75 负载因子决定了HashMap的数据密度。负载因子越大数组装填的越满，发生碰撞的几率就会越高，负载因子越小，越容易触发扩容，经常扩容会影响程序性能。之所以选择0.75作为负载因子的默认值，根据源码中注释中所解释： 在理想情况下，使用随机哈希吗，节点出现的频率在hash桶中遵循泊松分布，并且阈值为0.75，同时给出了桶中元素的个数和概率的对照表。 1234567890: 0.606530661: 0.303265332: 0.075816333: 0.012636064: 0.001579525: 0.000157956: 0.000013167: 0.000000948: 0.00000006 将链表转为红黑树的节点数量阈值1static final int TREEIFY_THRESHOLD = 8; 从上文桶中元素的个数和概率的对照表中可以看到，当桶中元素到达8个的时候，概率已经变得非常小，当链表的长度大于了8，并且数组长度大于64，为了查找效率就会把链表转化为红黑树。 将红黑树转为链表的节点数量阈值1static final int UNTREEIFY_THRESHOLD = 6; 当红黑树的节点个数小于6时，会把红黑树转化为链表存储 可以对容器进行红黑树化处理的最小表容量1static final int MIN_TREEIFY_CAPACITY = 64; 键值对数量1transient int size; 表示HashMap中键值对的数量 修改次数1transient int modCount; modCount是指改变HashMap中映射的数量或修改其内部结构(例如，重新散列)的次数。 主要方法构造方法java8在构造方法中不再初始化Node数组的长度，而是在第一次put时初始化Node数组长度 HashMap()123public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; 在默认构造方法中，将负载因子初始化为默认的值–0.75 HashMap(int initialCapacity)123public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125; 显式的定义了HashMap的存储数组的长度，并且使用默认的负载因子。但是此处并不是直接就将存储数组的长度设置为传入的initialCapacity值，而是经过一系列操作将长度设置为大于等于传入值，最接近传入值的2的指数幂。详细过程见下面一个构造函数 HashMap(int initialCapacity, float loadFactor)123456789101112public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; 在此构造函数中，首先判断传入的数组长度是否小于0，若小于0的抛出异常，若大于数组的最大长度则将其设置为最大长度。继而判断负载因子是否小于等于0或是否是一个非法的小数。经过了上述判断后将负载因子设置为传入的负载因子，之后执行tableSizeFor(initialCapacity)，tableSizeFor()方法如下： 1234static final int tableSizeFor(int cap) &#123; int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1); return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 在tableSizeFor()中执行了Integer.numberOfLeadingZeros()方法，Integer.numberOfLeadingZeros()方法如下： 1234567891011public static int numberOfLeadingZeros(int i) &#123; // HD, Count leading 0's if (i &lt;= 0) return i == 0 ? 32 : 0; int n = 31; if (i &gt;= 1 &lt;&lt; 16) &#123; n -= 16; i &gt;&gt;&gt;= 16; &#125; if (i &gt;= 1 &lt;&lt; 8) &#123; n -= 8; i &gt;&gt;&gt;= 8; &#125; if (i &gt;= 1 &lt;&lt; 4) &#123; n -= 4; i &gt;&gt;&gt;= 4; &#125; if (i &gt;= 1 &lt;&lt; 2) &#123; n -= 2; i &gt;&gt;&gt;= 2; &#125; return n - (i &gt;&gt;&gt; 1);&#125; numberOfLeadingZeros方法的作用是返回无符号整型i的最高非零位前面的0的个数，包括符号位在内,如果i为负数，这个方法将会返回0，符号位为1。例如， 10的二进制表示为 0000 0000 0000 0000 0000 0000 0000 1010 那么这个方法返回的就是28。 tableSizeFor()中 1int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1); cap为传入的数组长度，假设cap = 11，那么Integer.numberOfLeadingZeros(cap - 1)的值为28。那么n相当于-1向右无符号移动28位 1int n = -1 &gt;&gt;&gt; 28; 我们知道-1 的二进制为 1111 1111 1111 1111 1111 1111 1111 1111 向右移动28位后变成 0000 0000 0000 0000 0000 0000 0000 1111 则n = 15 最后函数在return时候经过判断返回n+1即16。相当于把自定义的数组长度11变成了比11大的、最接近11的2的幂，即16。 这里存在两个需要注意的点： 1）Integer.numberOfLeadingZeros(cap - 1)中为什么传入的参数为cap-1? 这是为了防止cap已经是2的幂，如果cap已经是2的幂，又没有执行减1的操作，则执行完一系列操作后返回的值会是cap值的两倍。 2）为什么数组长度一定要是2的幂？ 因为在计算索引的时候 使用的是(n - 1) &amp; hash来决定索引，当n为2次幂时，会满足一个公式：(n - 1) &amp; hash = hash % n，在计算机中，位运算要比%取模要快，用位运算可以提高运算的效率。 resize()resize是HashMap中的扩容方法，为方便理解加了部分注释，resize()代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table;//保存扩容前table的引用 int oldCap = (oldTab == null) ? 0 : oldTab.length;//保存老数组长度 int oldThr = threshold;//老数组存储阈值(容量*负载因子) int newCap, newThr = 0;//定义新的数组大小、存储阈值大小 if (oldCap &gt; 0) &#123; //当数组长度已大于最大数组长度，则返回原数组，并且将存储阈值设置为Integer的最大值 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //数组长度乘2后仍然小于最大数组长度，并且当前数组长度大于等于默认的数组长度则可扩容，将容量扩大为原来的两倍 newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) newCap = oldThr; else &#123; // 当初始数组长度和初始存储阈值都为0时候，将他们赋值为默认值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123;//当只满足老阈值大于0的条件时，新阈值等于新容量*默认扩容因子 float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//创建新数组 table = newTab; /** ---------------------上述为扩容数组部分，下面为复制数据部分----------------------- **/ if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123;//遍历原来数组中的值 Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null;//把原来数组对应序号的值赋值为空 便于内存回收 if (e.next == null) //若当前节点没有下一个节点就证明是一个单独的数据直接计算新的位置赋值 newTab[e.hash &amp; (newCap - 1)] = e;//e.hash &amp; (newCap - 1)的值为新的索引位置 else if (e instanceof TreeNode)//如果是红黑树，则按照红黑树进行操作 暂略 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 当前位置是个链表 Node&lt;K,V&gt; loHead = null, loTail = null; //保存不位移的链表 Node&lt;K,V&gt; hiHead = null, hiTail = null; //保存位移的链表 Node&lt;K,V&gt; next; do &#123;//遍历 next = e.next; if ((e.hash &amp; oldCap) == 0) &#123;//此时oldCap已经是原来的两倍，如果与的结果为0，表示索引不位移 if (loTail == null) // 如果索引对应位置为空直接赋值， loHead = e; else // 否则连接到链表末尾 loTail.next = e; loTail = e; &#125; else &#123;// 位移的节点 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123;//把不移位的结点添加到对应的链表数组中去 loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123;//把移位的结点添加到对应的链表数组中去 hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 总结： 如果是第一次进行put元素时进行扩容会将数组的长度和存储阈值设置为默认值。扩容时首先判断数组长度翻倍后是否仍然在最大范围之内，若超过最大值则设置为最大值，然后创建新的数组，将原来数组中的元素重新根据新的数组的长度计算索引值，在进行索引计算的时候每个元素只有两种情况，在原来的位置上或者在原来的位置，例子如下： 123456789101112131415161718192021222324252627假设原来的数组长度n=8。8的二进制编码为：0000 0000 0000 1000计算数组索引的公式为(n-1) &amp; hash，假设存在两个哈希值为别为6和14扩容前 n = 86的索引计算：0000 0000 0000 0111 -&gt;&gt; n-1 (7)0000 0000 0000 0110 -&gt;&gt; 6--------------------0000 0000 0000 0110 -&gt;&gt; 614的索引计算：0000 0000 0000 0111 -&gt;&gt; n-1 (7)0000 0000 0000 1110 -&gt;&gt; 140000 0000 0000 0110 -&gt;&gt; 6可以看到 6 和14 的索引都是6进行扩容以后 n = 166的索引计算：0000 0000 0000 1111 -&gt;&gt; n-1 (15)0000 0000 0000 0110 -&gt;&gt; 6--------------------0000 0000 0000 0110 -&gt;&gt; 614的索引计算：0000 0000 0000 1111 -&gt;&gt; n-1 (7)0000 0000 0000 1110 -&gt;&gt; 140000 0000 0000 1110 -&gt;&gt; 14可以看到6的索引值不变 还是6，但是14的索引值发生改变，改变为原来的索引+原来的数组长度。 最后根据对应的索引值把元素放入新数组之中。 put(K key, V value)123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; put方法调用了putVal方法，为方便理解加了部分注释，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; //定义了临时变量 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0)//如果存储数组为空或长度为0则进行扩容 n = (tab = resize()).length;//扩容 详见resize方法解释 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 计算索引并查看是否为索引位置为空 tab[i] = newNode(hash, key, value, null);//索引位置为空，直接把元素放进去 else &#123;//索引位置不空 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))//键相同，直接覆盖 e = p; else if (p instanceof TreeNode) // 判断为空黑树，使用红黑树插入方法插入 详情暂略 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//链表 for (int binCount = 0; ; ++binCount) &#123;//遍历元素 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // 若长度达到阈值，转换为红黑树 treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))//键相等，直接覆盖 break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null)//onlyIfAbsent为true:不覆盖，false：覆盖。 e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount;//增加修改次数 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; remove(Object key)12345public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125; remove方法中调用removeNode方法进行删除。 1234567891011121314151617181920212223242526272829303132333435363738394041final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; // 判断是否存储数组为空或者存储数组长度为0 Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //判断索引位置key是否与要删除的key相等 node = p; else if ((e = p.next) != null) &#123; // next不为空，则索引位置为链表或红黑树 if (p instanceof TreeNode) // 红黑树 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); //红黑树中找到key相等的元素 else &#123; // 链表 do &#123;//遍历链表找到key相等的元素 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123;//matchValue为是否匹配值 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);//红黑树删除节点 else if (node == p) tab[index] = node.next; //单一节点直接删除 else p.next = node.next;//链表删除节点 ++modCount; //增加操作次数 --size; //减少数组实际存储元素个数 afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; get(Object key)1234public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; get方法中调用getNode方法获取元素。 12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123;// 判断是否存储数组为空或者存储数组长度为0 if (first.hash == hash &amp;&amp; // 判断第一个节点 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //红黑树查找 do &#123;//链表遍历查找 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; HashMap的遍历1234567891011121314151617181920212223242526272829//获取key集合遍历key集合再进行取值（需要二次取值效率低）private static void method04(Map&lt;String, Integer&gt; map) &#123; for (String s : map.keySet()) &#123; System.out.println(s + \"----\" + map.get(s)); &#125;&#125;//使用Map.entrySet遍历\"private static void method03(Map&lt;String, Integer&gt; map) &#123; for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + \"----\" + entry.getValue()); &#125;&#125;//使用迭代器进行遍历private static void method02(Map&lt;String, Integer&gt; map) &#123; Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator(); while ((iterator.hasNext()))&#123; Map.Entry&lt;String, Integer&gt; mapEntry = iterator.next(); System.out.println(mapEntry.getKey() + \"----\" + mapEntry.getValue()); &#125;&#125;//使用forEach 进行遍历private static void method01(Map&lt;String, Integer&gt; map) &#123; map.forEach(( key, value) -&gt; &#123; System.out.println(key + \"----\" + value); &#125;);&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://caicaing.github.io/tags/java/"},{"name":"HashMap","slug":"HashMap","permalink":"https://caicaing.github.io/tags/HashMap/"}]},{"title":"java多线程(一)","slug":"java多线程-一","date":"2020-02-02T11:10:53.000Z","updated":"2020-02-05T03:14:12.000Z","comments":true,"path":"2020/02/02/java多线程-一/","link":"","permalink":"https://caicaing.github.io/2020/02/02/java多线程-一/","excerpt":"线程、进程概念、Thread和Runnable的基本使用。","text":"线程、进程概念、Thread和Runnable的基本使用。 进程和多线程的概念以及线程的优点什么是进程进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 [1] 什么是线程线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。 线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。 同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。 一个进程可以有很多线程，每条线程并行执行不同的任务。 在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。 使用多线程一个进程正在运行时至少会有一个线程在运行，这种情况在Java中也是存在的。这些线程在后台默默地执行，比如调用public static void main() 方法的线程就是这样的，而且它是由JVM创建的。 继承Thread 类在Java的JDK开发包中，已经自带了对多线程技术的支持，可以很方便的进行多线程编程。实现多线程编程的方式主要有两种： 继承Thread类 实现Runnable接口。 在创建新的线程前，先来看看Thread类的接口，如下： 1public class Thread implements Runnable 从上面的源代码中可以发现，Thread类实现了Runnable接口，它们之间具有多态的关系。使用Thread类的方式创建新线程时，最大的局限就是不支持多继承，因为iJava语言的特点就是单根继承，所以为了支持多继承，完全可以实现Runnable接口的方式，一边实现一边继承。但是使用这两种方式创建的线程在工作时的性质是一样的，没有本质的区别。 首先来看一下第一种方法。创建MyThread类，继承Thread类并且重写run方法。MyThread类代码如下： 123456789package com.caicai;public class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); System.out.println(\"MyThread\"); &#125;&#125; 运行类代码如下： 12345678910package com.caicai;public class Run &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); myThread.start(); System.out.println(\"运行结束\"); &#125;&#125; 运行结果如下： 1234运行结束MyThreadProcess finished with exit code 0 从运行结果来看，MyThread.java类中的run方法执行的时间比较晚，这也说明在使用多线程技术时，代码的运行结果与代码的执行顺序和调用顺序是无关的。 线程是一个子任务，cpu以不确定的方式，或者说是以随机的事件来调用线程中的run方法，所以就会出现先打印“运行结束”后输出“MyThread”这样的结果了。 如果多次调用start()方法，则会出现异常Excaption in thread “main” java.lang.IllegalThreadStateExcetion。 上面介绍了线程的调用的随机性，下面演示线程的随机性。 创建运行类Test.java，代码如下： 1234567891011121314151617181920package com.caicai;public class Test &#123; public static void main(String[] args) &#123; MyThread1 myThread1 = new MyThread1(); myThread1.setName(\"myThread01\"); myThread1.start(); for (int i = 0; i &lt; 10; i++) &#123; int time = (int) (Math.random() * 1000); try &#123; Thread.sleep(time); System.out.println(\"main=\" + Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 创建自定义线程类MyThread1.java，代码如下： 1234567891011121314151617package com.caicai;public class MyThread1 extends Thread &#123; @Override public void run() &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; int time = (int) (Math.random() * 1000); Thread.sleep(time); System.out.println(\"run = \" + Thread.currentThread().getName()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果如下： 1234567891011121314151617main=mainmain=mainrun = myThread01main=mainmain=mainrun = myThread01run = myThread01run = myThread01run = myThread01main=mainmain=mainrun = myThread01main=mainrun = myThread01main=mainProcess finished with exit code 130 (interrupted by signal 2: SIGINT) 在代码中，为了展现出线程具有随机特性，所以使用随机数的形式来使线程得到挂起的效果，从而表现出CPU执行的哪个线程具有不确定性。 另外，执行start方法的顺序不代表线程启动的顺序。创建类MyThread2.java，代码如下： 1234567891011121314package com.caicai;public class MyThread2 extends Thread &#123; private int i; public MyThread2(int i) &#123; this.i = i; &#125; @Override public void run() &#123; System.out.println(i); &#125;&#125; 运行类Test.java代码如下： 12345678910111213141516171819202122package com.caicai;public class Test2 &#123; public static void main(String[] args) &#123; MyThread2 t1 = new MyThread2(1); MyThread2 t2 = new MyThread2(2); MyThread2 t3 = new MyThread2(3); MyThread2 t4 = new MyThread2(4); MyThread2 t5 = new MyThread2(5); MyThread2 t6 = new MyThread2(6); MyThread2 t7 = new MyThread2(7); MyThread2 t8 = new MyThread2(8); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); t6.start(); t7.start(); t8.start(); &#125;&#125; 运行结果如下所示： 1234567891015432768Process finished with exit code 0 实现Runnable接口如果欲创建的线程类已经有一个父类了，就不能再继承Thread类了，所以需要实现Runnable接口来应对这样的情况。 创建MyRunnable，实现MyRunnable，代码如下： 12345678package com.caicai.myrunnable;public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(\"运行中\"); &#125;&#125; 1234567891011package com.caicai.myrunnable;public class Run &#123; public static void main(String[] args) &#123; Runnable runnable = new MyRunnable(); Thread thread = new Thread(runnable); thread.start(); System.out.println(\"运行结束\"); &#125;&#125; 在上述代码中，把一个实现了Runnable的接口当做参数传入Thread的构造函数中创建了一个新的线程类。需要另外说明的是Thread.java类也实现了Runnable接口，这意味着构造函数Thread(Runnable target)不光可以传入Runnable接口对象，还可以传入一个Thread类对象，这样做完全可以将一个Thread对象中的run方法教给其他线程进行调用。 实例变量与线程安全自定义线程类中的实例变量针对其他线程有可共享与不可共享之分。 （1）不共享数据的情况 创建MyThread.java，代码如下： 12345678910111213141516171819package com.caicai.t3;public class MyThread extends Thread &#123; private int count = 5; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; super.run(); while (count &gt; 0) &#123; count--; System.out.println(\"由\" + Thread.currentThread().getName() + \"计算，count = \" + count ); &#125; &#125;&#125; 运行类Run.java，代码如下： 123456789101112package com.caicai.t3;public class Run &#123; public static void main(String[] args) &#123; MyThread a = new MyThread(\"A\"); MyThread b = new MyThread(\"B\"); MyThread c = new MyThread(\"C\"); a.start(); b.start(); c.start(); &#125;&#125; 运行结果如下： 1234567891011121314151617由A计算，count = 4由C计算，count = 4由B计算，count = 4由C计算，count = 3由A计算，count = 3由C计算，count = 2由B计算，count = 3由C计算，count = 1由A计算，count = 2由C计算，count = 0由B计算，count = 2由A计算，count = 1由B计算，count = 1由A计算，count = 0由B计算，count = 0Process finished with exit code 0 可以看到 一共创建了三个线程 每个线程都有各自的count变量，自己减少自己的count变量的值。这样的情况就是变量不共享，此实例不存在多个线程访问同一个实例变量的情况。 （2）共享数据的情况 共享数据的情况就是多个线程可以访问同一个变量，比如在实现投票功能的软件时，多个线程可以同时处理同一个人的票数。 下面通过一个实例来看下数据共享的情况。 创建MyThread.java类，代码如下： 123456789101112package t4;public class MyThread extends Thread &#123; private int count = 5; @Override public void run() &#123; super.run(); count--; System.out.println(\"由\" + Thread.currentThread().getName() + \"计算 count = \" + count); &#125;&#125; 创建运行类Run.java，代码如下： 1234567891011121314151617package t4;public class Run &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread a = new Thread(myThread, \"A\"); Thread b = new Thread(myThread, \"B\"); Thread c = new Thread(myThread, \"C\"); Thread d = new Thread(myThread, \"D\"); Thread e = new Thread(myThread, \"E\"); a.start(); b.start(); c.start(); d.start(); e.start(); &#125;&#125; 运行结果如下： 1234567由A计算 count = 3由D计算 count = 1由B计算 count = 3由E计算 count = 0由C计算 count = 2Process finished with exit code 0 可以看到，线程A和线程B打印出的都是count值都是3，说明A和B同时对count 进行处理，产生了“非线程安全”问题。而我们想要得到的打印结果却不是重复的，而是依次递减的。 在某些JVM中，i–的操作要分成如下三步： 1）取得原有的i值。 2）计算i-1。 3）对i进行赋值。 在这三个步骤中，如果有多个线程进行访问，那么一定会出现非线程安全的问题。 这个示例就是典型的销售场景：火车剩五个座位对应五张车票，每当卖出一张票总的票数就会减一，每次得到的剩余票数都是不同的。这时就要使多个线程之间同步，也就是用按顺序排队的方式进行减一操作。更改代码如下： 123456789101112package t4;public class MyThread extends Thread &#123; private int count = 5; @Override synchronized public void run() &#123; super.run(); count--; System.out.println(\"由\" + Thread.currentThread().getName() + \"计算 count = \" + count); &#125;&#125; 重新运行程序，就不会出现值一样的情况了。通过在run方法前加入synchronized关键字，使多个线程在执行run方法时，以排队的方式进行处理。当一个线程调用run前，先判断run方法有没有被上锁，如果上锁，说明有其他线程正在调用run犯法，必须等到其他线程对run方法调用结束后才可以执行run方法。这也就实现了排队调用run方法的目的。synchronized可以在任意对象和方法上枷锁，而加锁的这段代码成为“互斥区”或“临界区”。 当一个线程想要执行同步方法里面的代码时，线程首先尝试去拿这把锁，如果能够拿到这把锁，那么这个线程可以执行代码，如果不能拿到线程锁那么这个线程会不断地尝试拿这把锁，直到能够拿到为止，而且是有多个线程同时去争抢这把锁。 currentThread()方法currentThread()方法可以返回代码段正在被哪个线程调用的信息。下面通过一个示例说明。 创建MyThread.java类，代码如下： 123456789101112package com.caicai.t5;public class MyThread extends Thread &#123; public MyThread() &#123; System.out.println(\"构造方法打印:\" + Thread.currentThread().getName()); &#125; @Override public void run() &#123; System.out.println(\"run 方法的打印：\" + Thread.currentThread().getName()); &#125;&#125; 创建Run2.java类，代码如下： 12345678910package com.caicai.t5;public class Run2 &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); myThread.start();// myThread.run(); &#125;&#125; 运行结果如下： 12构造方法打印:mainrun 方法的打印：Thread-0 可以看到MyThread.java的构造函数是被main线程调用的，而run方法是被名称Thread-0的线程调用的，run方法是自动调用的方法。 Run2.java代码更改如下： 12345678910package com.caicai.t5;public class Run2 &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread();// myThread.start(); myThread.run(); &#125;&#125; 12构造方法打印:mainrun 方法的打印：main 构造方法和run方法都是main线程调用的。 isAlive()方法方法isAlive()的功能是判断当前的线程是否处于活动状态。 创建MyThread.java类，代码如下： 123456789package com.caicai.t7;public class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(\"run == \" + this.isAlive()); &#125;&#125; 创建Run.java类，代码如下： 12345678910package com.caicai.t7;public class Run &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); System.out.println(\"begin==\" + myThread.isAlive()); myThread.start(); System.out.println(\"end==\" + myThread.isAlive()); &#125;&#125; 运行结果如下： 123begin==falseend==truerun == true 方法isAlive()的作用是测试线程是否处在活动状态。线程处于正在运行或准备开始运行的状态就认为线程是存活的。需要说明的是 1System.out.println(\"end==\" + myThread.isAlive()); 虽然示例中打印的是true，但是此值是不确定的。打印true值是因为mythread线程还未执行完毕，所以输出true。 sleep()方法方法sleep()的作用是在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)。这个“正在执行的线程”是指this.currentThread()返回的线程。 通过一个示例来进行说明。 创建MyThread1.java类，代码如下： 12345678910111213141516package com.caicai.t8;public class MyThread1 extends Thread &#123; @Override public void run() &#123; try&#123; System.out.println(\"run threadName= \" + Thread.currentThread().getName() + \"begin \"); Thread.sleep(2000); System.out.println(\"run threadName= \" + Thread.currentThread().getName() + \"end \"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 创建Run1.java类，代码如下： 123456789101112package com.caicai.t8;import org.w3c.dom.ls.LSOutput;public class Run1 &#123; public static void main(String[] args) &#123; MyThread1 myThread1 = new MyThread1(); System.out.println(\"begin = \" + System.currentTimeMillis()); myThread1.start(); System.out.println(\"end = \" + System.currentTimeMillis()); &#125;&#125; 直接调用run方法运行结果如下： 1234begin = 1580819435402run threadName= mainbegin run threadName= mainend end = 1580819437421 把Run1改为如下： 1234567891011package com.caicai.t8;public class Run1 &#123; public static void main(String[] args) &#123; MyThread1 myThread1 = new MyThread1(); System.out.println(\"begin = \" + System.currentTimeMillis()); myThread1.start(); System.out.println(\"end = \" + System.currentTimeMillis()); &#125;&#125; 调用start方法运行结果如下： 1234begin = 1580819522188end = 1580819522196run threadName= Thread-0begin run threadName= Thread-0end 由于main线程与MyThread2线程是异步执行的，所以首先打印的信息为begin和end。而MyThread2线程是随后执行的，在最后两行打印run begin和run end相关信息。 getId()方法getId()方法的作用是取得线程的唯一标识。 创建Test.java类，代码如下： 12345678package com.caicai.t9;public class Test &#123; public static void main(String[] args) &#123; Thread runThread = Thread.currentThread(); System.out.println(runThread.getName() + \" \" + runThread.getId()); &#125;&#125; 运行结果如下: 1main 1","categories":[],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://caicaing.github.io/tags/多线程/"},{"name":"thread","slug":"thread","permalink":"https://caicaing.github.io/tags/thread/"}]},{"title":"MAC 键盘快捷键","slug":"MAC-键盘快捷键","date":"2020-01-30T13:57:59.000Z","updated":"2020-01-30T14:00:52.000Z","comments":true,"path":"2020/01/30/MAC-键盘快捷键/","link":"","permalink":"https://caicaing.github.io/2020/01/30/MAC-键盘快捷键/","excerpt":"MAC快捷键","text":"MAC快捷键 MAC 键盘快捷键剪切、拷贝、粘贴和其他常用快捷键Command-X：剪切所选项并拷贝到剪贴板。Command-C：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。Command-V：将剪贴板的内容粘贴到当前文稿或 App 中。这同样适用于“访达”中的文件。Command-Z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些 App 中，您可以撤销和重做多个命令。Command-A：全选各项。Command-F：查找文稿中的项目或打开“查找”窗口。Command-G：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。Command-H：隐藏最前面的 App 的窗口。要查看最前面的 App 但隐藏所有其他 App，请按 Option-Command-H。Command-M：将最前面的窗口最小化至“程序坞”。要最小化最前面的 App 的所有窗口，请按 Option-Command-M。Command-O：打开所选项，或打开一个对话框以选择要打开的文件。Command-P：打印当前文稿。Command-S：存储当前文稿。Command-T：打开新标签页。Command-W：关闭最前面的窗口。要关闭 App 的所有窗口，请按下 Option-Command-W。Option-Command-Esc：强制退出 App。Command–空格键：显示或隐藏“聚焦”搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。（如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何更改冲突的键盘快捷键。）Control-Command–空格键：显示字符检视器，您可以从中选择表情符号和其他符号。Control-Command-F：全屏使用 App（如果 App 支持）。空格键：使用快速查看来预览所选项。Command-Tab：在打开的 App 中切换到下一个最近使用的 App。Shift-Command-5：在 macOS Mojave 或更高版本中，拍摄截屏或录制屏幕。也可以使用 Shift-Command-3 或 Shift-Command-4 来拍摄截屏。进一步了解截屏。Shift-Command-N：在“访达”中创建一个新文件夹。Command-逗号 (,)：打开最前面的 App 的偏好设置。 睡眠、退出登录和关机快捷键在这些快捷键中，您可能需要按住其中一些快捷键稍长时间。这样有助于避免无意中启用快捷键。 电源按钮：按下可将 Mac 开机或将 Mac 从睡眠状态唤醒。按住这个按钮 1.5 秒可使 Mac 进入睡眠状态。继续按住则会强制您的 Mac 关机。Option–Command–电源按钮或 Option–Command–Media Eject（Option–Command–介质推出键）：将您的 Mac 置于睡眠状态。Control–Shift–电源按钮或 Control–Shift–Media Eject（Control–Shift–介质推出键）：将显示器置于睡眠状态。Control–电源按钮 或 Control–介质推出键 ：显示一个对话框，询问您是要重新启动、睡眠还是关机。Control–Command–电源按钮：强制 Mac 重新启动，系统不会提示是否要存储任何打开且未存储的文稿。Control–Command–Media Eject（Control–Command–介质推出键）：退出所有 App，然后重新启动您的 Mac。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。Control–Option–Command–电源按钮 或 Control–Option–Command–介质推出键 ：退出所有 App，然后将您的 Mac 关机。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。Control-Command-Q：立即锁定屏幕。Shift–Command–Q：退出登录您的 macOS 用户帐户。系统将提示您确认。要在不确认的情况下立即退出登录，请按下 Option-Shift-Command-Q。 不适用于触控 ID 传感器。 访达和系统快捷键Command-D：复制所选文件。Command-E：推出所选磁盘或宗卷。Command-F：在“访达”窗口中开始“聚焦”搜索。Command-I：显示所选文件的“显示简介”窗口。Command-R：(1) 如果在“访达”中选择了某个别名：显示所选别名对应的原始文件。(2) 在某些 App（如“日历”或 Safari 浏览器）中，刷新或重新载入页面。(3) 在“软件更新”偏好设置中，再次检查有没有软件更新。Shift-Command-C：打开“电脑”窗口。Shift-Command-D：打开“桌面”文件夹。Shift-Command-F：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。Shift-Command-G：打开“前往文件夹”窗口。Shift-Command-H：打开当前 macOS 用户帐户的个人文件夹。Shift-Command-I：打开 iCloud 云盘。Shift-Command-K：打开“网络”窗口。Option-Command-L：打开“下载”文件夹。Shift-Command-N：新建文件夹。Shift-Command-O：打开“文稿”文件夹。Shift-Command-P：在“访达”窗口中显示或隐藏预览面板。Shift-Command-R：打开“隔空投送”窗口。Shift-Command-T：显示或隐藏“访达”窗口中的标签页栏。Ctrl-Shift-Command-T：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本）Shift-Command-U：打开“实用工具”文件夹。Option-Command-D：显示或隐藏“程序坞”。Control-Command-T：将所选项添加到边栏（OS X Mavericks 或更高版本）。Option-Command-P：隐藏或显示“访达”窗口中的路径栏。Option-Command-S：隐藏或显示“访达”窗口中的边栏。Command–斜线 (/)：隐藏或显示“访达”窗口中的状态栏。Command-J：显示“显示”选项。Command-K：打开“连接服务器”窗口。Command-L：为所选项制作替身。Command-N：打开一个新的“访达”窗口。Option-Command-N：新建智能文件夹。Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。Option-Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。Option-Command-V：移动：将剪贴板中的文件从原始位置移动到当前位置。Command-Y：使用“快速查看”预览所选文件。Option-Command-Y：显示所选文件的快速查看幻灯片显示。Command-1：以图标方式显示“访达”窗口中的项目。Command-2：以列表方式显示“访达”窗口中的项目。Command-3：以分栏方式显示“访达”窗口中的项目。Command-4：以画廊方式显示“访达”窗口中的项目。Command–左中括号 ([)：前往上一文件夹。Command–右中括号 (])：前往下一个文件夹。Command–上箭头：打开包含当前文件夹的文件夹。Command–Control–上箭头：在新窗口中打开包含当前文件夹的文件夹。Command–下箭头：打开所选项。右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。Command-Delete：将所选项移到废纸篓。Shift-Command-Delete：清倒废纸篓。Option-Shift-Command-Delete：清倒废纸篓而不显示确认对话框。Command–调高亮度：打开或关闭目标显示器模式。Command–调低亮度：当您的 Mac 连接到多台显示器时，打开或关闭视频镜像。Option–调高亮度：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。Control–调高亮度或 Control–调低亮度：更改外部显示器的亮度（如果显示器支持）。Option-Shift–调高亮度或 Option-Shift–调低亮度：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。Option–“调度中心”：打开“调度中心”偏好设置。Command–调度中心：显示桌面。Control–下箭头：显示最前面的 App 的所有窗口。Option–调高音量：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。Option-Shift–调高音量或 Option-Shift–调低音量：以较小的步幅调节音量。Option–键盘调高亮度：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。Option-Shift–键盘调高亮度或 Option-Shift–键盘调低亮度：以较小的步幅调节键盘亮度。连按 Option 键：在单独的窗口中打开项目，然后关闭原始窗口。连按 Command 键：在单独的标签页或窗口中打开文件夹。按住 Command 键拖移到另一个宗卷：将拖移的项目移到另一个宗卷，而不是拷贝它。按住 Option 键拖移：拷贝托移的项目。拖移项目时指针会随之变化。拖移时按住 Option-Command：为拖移的项目制作替身。拖移项目时指针会随之变化。按住 Option 键点按开合三角：打开所选文件夹内的所有文件夹。这个快捷键仅在列表视图中有效。按住 Command 键点按窗口标题：查看包含当前文件夹的文件夹。了解如何使用 Command 或 Shift 在“访达”中选择多个项目。点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。 文稿快捷键这些快捷键的行为可能因您使用的 App 而异。 Command-B：以粗体显示所选文本，或者打开或关闭粗体显示功能。Command-I：以斜体显示所选文本，或者打开或关闭斜体显示功能。Command-K：添加网页链接。Command-U：对所选文本加下划线，或者打开或关闭加下划线功能。Command-T：显示或隐藏“字体”窗口。Command-D：从“打开”对话框或“存储”对话框内选择“桌面”文件夹。Control-Command-D：显示或隐藏所选字词的定义。Shift-Command–冒号 (:)：显示“拼写和语法”窗口。Command–分号 (;)：查找文稿中拼写错误的字词。Option-Delete：删除插入点左边的字词。Control-H：删除插入点左边的字符。也可以使用 Delete 键。Control-D：删除插入点右边的字符。也可以使用 Fn-Delete。Fn-Delete：在没有向前删除 键的键盘上向前删除。也可以使用 Control-D。Control-K：删除插入点与行或段落末尾处之间的文本。Fn–上箭头：Page Up：向上滚动一页。Fn–下箭头：Page Down：向下滚动一页。Fn–左箭头：Home：滚动到文稿开头。Fn–右箭头：End：滚动到文稿末尾。Command–上箭头：将插入点移至文稿开头。Command–下箭头：将插入点移至文稿末尾。Command–左箭头：将插入点移至当前行的行首。Command–右箭头：将插入点移至当前行的行尾。Option–左箭头：将插入点移至上一字词的词首。Option–右箭头：将插入点移至下一字词的词尾。Shift-Command–上箭头：选中插入点与文稿开头之间的文本。Shift-Command–下箭头：选中插入点与文稿末尾之间的文本。Shift-Command–左箭头：选中插入点与当前行行首之间的文本。Shift-Command–右箭头：选中插入点与当前行行尾之间的文本。Shift–上箭头：将文本选择范围扩展到上一行相同水平位置的最近字符处。Shift–下箭头：将文本选择范围扩展到下一行相同水平位置的最近字符处。Shift–左箭头：将文本选择范围向左扩展一个字符。Shift–右箭头：将文本选择范围向右扩展一个字符。Option–Shift–上箭头：将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。Option–Shift–下箭头：将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。Option–Shift–左箭头：将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。Option–Shift–左箭头：将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。Control–A：移至行或段落的开头。Control–E：移至行或段落的末尾。Control–F：向前移动一个字符。Control–B：向后移动一个字符。Control–L：将光标或所选内容置于可见区域中央。Control–P：上移一行。Control–N：下移一行。Control–O：在插入点后新插入一行。Control–T：将插入点后面的字符与插入点前面的字符交换。Command–左花括号 ({)：左对齐。Command–右花括号 (})：右对齐。Shift-Command–竖线 (|)：居中对齐。Option-Command-F：前往搜索栏。Option-Command-T：显示或隐藏 App 中的工具栏。Option-Command-C：拷贝样式：将所选项的格式设置拷贝到剪贴板。Option-Command-V：粘贴样式：将拷贝的样式应用到所选项。Option-Shift-Command-V：粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。Option-Command-I：显示或隐藏检查器窗口。Shift-Command-P：页面设置：显示用于选择文稿设置的窗口。Shift-Command-S：显示“存储为”对话框或复制当前文稿。Shift-Command-减号 (-)：缩小所选项。Shift-Command-加号 (+)：放大所选项。Command–等号 (=) 可实现相同的功能。Shift-Command–问号 (?)：打开“帮助”菜单。","categories":[],"tags":[{"name":"MAC","slug":"MAC","permalink":"https://caicaing.github.io/tags/MAC/"}]},{"title":"LeetCode 热题HOT100","slug":"LeetCode-热题HOT100","date":"2019-12-02T10:51:35.000Z","updated":"2019-12-02T11:04:09.254Z","comments":true,"path":"2019/12/02/LeetCode-热题HOT100/","link":"","permalink":"https://caicaing.github.io/2019/12/02/LeetCode-热题HOT100/","excerpt":"LeetCode热题HOT100题解","text":"LeetCode热题HOT100题解 1.两数之和12345678910给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int [] result = new int[2]; for(int i = 0; i &lt; nums.length ; i++)&#123; for(int j = i+1; j &lt; nums.length; j++)&#123; if(nums[i] + nums[j] == target)&#123; result[0] = i; result[1] = j; &#125; &#125; &#125; return result; &#125;&#125; 2.两数相加1234567891011给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode node = new ListNode(0); //是否进位 Boolean flag = false; ListNode mid = node; while (true)&#123; if(l1 == null || l2 == null) &#123; break; &#125; int result = l1.val + l2.val; if(flag)&#123; result++; flag = false; &#125; if(result &gt;= 10)&#123; flag = true; &#125; ListNode temp = new ListNode(result % 10); mid.next = temp; mid = temp; l1 = l1.next; l2 = l2.next; &#125; while(l1 != null)&#123; int result = l1.val; if(flag)&#123; result++; flag = false; &#125; if(result &gt;= 10)&#123; flag = true; &#125; ListNode temp = new ListNode(result % 10); mid.next = temp; mid = temp; l1 = l1.next; &#125; while(l2!= null)&#123; int result = l2.val; if(flag)&#123; result++; flag = false; &#125; if(result &gt;= 10)&#123; flag = true; &#125; ListNode temp = new ListNode(result % 10); mid.next = temp; mid = temp; l2 = l2.next; &#125; if(flag)&#123; ListNode temp = new ListNode(1); mid.next = temp; mid = temp; &#125; if(node.next == null)&#123; return new ListNode(0); &#125; return node.next; &#125;&#125; 3.无重复字符的最长字串123456789101112131415161718给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例 1:输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。示例 2:输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。示例 3:输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 1234567891011121314151617181920212223class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int maxlength = 0; char[] chars = s.toCharArray(); String str = \"\"; for (int i = 0; i &lt; s.length(); i++) &#123; System.out.println(str);// if((chars[i] &gt;= 'a' &amp;&amp; chars[i] &lt;= 'z') || chars[i] == ' ' )&#123; int index = str.indexOf(chars[i]); if (index == -1) &#123; str += chars[i]; if (str.length() &gt; maxlength) &#123; maxlength = str.length(); &#125; &#125; else &#123; str = str.substring(index+1); str += chars[i]; &#125;// &#125; &#125; return maxlength; &#125;&#125; 4.寻找两个有序数组的中位数123456789101112131415161718给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。示例 1:nums1 = [1, 3]nums2 = [2]则中位数是 2.0示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 12","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://caicaing.github.io/tags/LeetCode/"}]},{"title":"JSR-303校验API","slug":"JSR-303校验API","date":"2019-12-01T12:48:13.000Z","updated":"2019-12-02T01:56:55.498Z","comments":true,"path":"2019/12/01/JSR-303校验API/","link":"","permalink":"https://caicaing.github.io/2019/12/01/JSR-303校验API/","excerpt":"JSR-303","text":"JSR-303 JSR-303从Spring3.0开始，在SpringMVC中提供了对Java校验API的支持。在SpringMVC中要使用Java校验API的话，并不需要什么额外的配置。只要保证在类路径下包含这个JavaAPI的实现即可。 Java校验API定义了多个注解，这些注解可以放到属性上，从而限制这些属性的值。所有的注解都位于javax.validation.constraints包中。下表列出了这些注解 注解 描述 @AssertFalse 所注解的元素必须是Boolean类型，并且值为false @AssertTrue 所注解的元素必须是Boolean类型，并且值为true @DecimalMax 所注解的元素必须是数字，并且他的值要小于或者等于给定的BigDecimalString值 @DecimalMin 所注解的元素必须是数字，并且他的值要大于或等于给定的BigDecimalString值 @Digits 所注解的元素必须是数字，并且他的值必须有指定位数 @Future 所注解的元素必须是一个将来的日期 @Max 所注解的元素必须是数字，并且它的值要小于或等于给定的值 @Min 所注解的元素必须是数字，并且它的值要大于或等于给定的值 @NotNull 所注解的元素的值必须不能为null @Null 所注解的元素的值必须为null @Past 所注解的元素必须是一个过去的日期 @Pattern 所注解的元素的值必须匹配给定的正则表达式 @Size 所注解的元素的值必须是String、集合或数组，并且它的长度要符合给定的范围 除了上表中的注解，Java校验API的实现可能还会提供额外的校验注解。同时也可以定义自己的限制条件。 12345678910111213141516171819202122232425package caicai;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;public class Spitter &#123; private Long id; @NotNull @Size(min = 5, max = 16) private String username; @NotNull @Size(min = 5, max = 25) private String password; @NotNull @Size(min = 2, max = 30) private String firstName; @NotNull @Size(min = 2, max = 30) private String lastName;&#125; 现在所有的属性都加上了NotNull注解，以确保他们的值不会为null。类似的，属性上也添加了@Size注解以限制他们的长度在最大值和最小值之间。 我们接下来要修改processRegistration()方法来应用校验功能。启用校验功能的processRegistration()如下所示： 1234567@RequestMapping(value = \"/register\",method = RequestMethod.POST)public String processRegistration(@Valid Spitter spitter, Errors errors)&#123; if(errors.hasErrors())&#123; return \"registerForm\"; &#125; return \"redirect:/spitter/\" + spitter.getUsername();&#125; Spitter参数添加了@Valid注解，这会告知Spring，需要确保这个对象满足校验限制。在Spitter属性上添加校验限制并不能阻止表单提交。即便用户没有填写某个域所给定的值超出了最大长度，processRegistration()方法依然会被调用。这样，我们就需要处理校验的错误，就像在processRegistration()方法中所看到的那样。 如果有校验出现错误的话，那么这些错误可以通过Errors对象进行访问，现在这个对象以作为processRegistration()方法的参数。（很重要一点需要注意，Errors参数要紧跟在带有@Valid注解的参数后面，@Valid注解所标注的就是要检验的参数。）processRegistration()方法所做的第一件事就是调用Errors.hasErrors()来检查是否有错误。 如果又称错误的话，Errors.hasErrors()将会返回到registerForm,也就是注册表单的视图，这能够让用户的浏览器重新回到注册表单页面，所以他们能够修正错误，然后重新尝试提交。现在，会显示空的表单，但是在下一章中，我们将在表单中显示最初提交的值并将校验错误反馈给用户。","categories":[],"tags":[{"name":"JSR-303","slug":"JSR-303","permalink":"https://caicaing.github.io/tags/JSR-303/"},{"name":"Spring","slug":"Spring","permalink":"https://caicaing.github.io/tags/Spring/"}]},{"title":"Spring Web","slug":"Spring-Web","date":"2019-11-27T10:38:21.000Z","updated":"2019-12-01T12:44:07.977Z","comments":true,"path":"2019/11/27/Spring-Web/","link":"","permalink":"https://caicaing.github.io/2019/11/27/Spring-Web/","excerpt":"Spring Web","text":"Spring Web 构建SpringWeb应用程序Spring MVC起步每当用户在Web浏览器中点击链接或提交表单的时候，请求就开始工作了。下图展示了请求使用SpringMVC所经历的所有站点。 在请求离开浏览器时(①)会将带有用户所请求内容的信息，至少会包含请求的URL，但是还可能带有其他的信息，例如用户提交的表单信息。 请求的第一站是Spring的DispatcherServlet。与大多数基于Java的Web框架一样，SpringMVC所请求都会通过一个前端控制器Servlet。前端控制器是常用的Web应用程序模式，在这里一个单例的Servlet将请求委托给应用程序的其他组件来执行实际的处理。在SpringMVC中，DispatcherServlet就是前端控制器。 DispatcherServlet的任务是将请求发送给SpringMVC控制器（Controller）。控制器是一个用于处理请求的Spring组件。在典型的应用程序中可能会有多个控制器，DispatcherServlet需要知道应该将请求发送给哪个控制器。所以DispatcherServlet以会查询一个或多个处理器映射（handler mapping）②来确定请求的下一站在哪里。处理器映射会根据请求所携带的url信息进行决策。 一旦选择了合适的控制器，DispatcherServlet会将请求发送给选中的控制器③。到了控制器，请求会卸下其负载（用户提交的信息）并耐心等待控制器处理这些信息。（实际上，设计良好的控制器本身只处理很少甚至不处理工作，而是将业务逻辑委托给一个或多个服务对象进行处理。） 控制器在完成逻辑处理后，通常会产生一些信息，这些信息需要返回给用户并在浏览器上显示。这些信息被称为模型（model）。仅仅给用户返回原始的信息是不够的——这些信息需要以有好的方式进行格式化，一般会是HTML。所以，信息需要发送给一个视图（view），通常会是JSP。控制器所做的最后一件事就是将模型数据打包，并且标出用于渲染输出的视图名。他接下来会将请求连通模型和视图名发送回DispatcherServlet④。 这样，控制器就不会与特定的视图相耦合，传递给DispatcherServlet的视图名不直接表示某个特定的JSP。实际上，它甚至并不能确定视图就是JSP。相反，它仅仅传递了一个逻辑名称，这个名字将会用来查找产生结果的真正视图。DispatcherServlet将会使用视图解析器（view resolver）⑤来讲逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是JSP。 既然DispatcherServlet已经知道由哪个视图渲染结果，那请求的任务基本上也就完成了。它的最后一站是视图的实现（可能是JSP）⑥，在这里他交付模型数据。请求的任务就完成了。试图将使用模型数据渲染输出，这个输出会通过响应对象传递给客户端。 搭建Spring MVC配置DispatcherServlet123456789101112131415161718192021package caicai.config;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //加载容器 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;; &#125; //加载webapp容器 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; WebConfig.class &#125;; &#125; //设置DispatcherServlet的拦截规则 / 代表拦截所有但是不包括jsp @Override protected String[] getServletMappings() &#123; return new String[] &#123; \"/\" &#125;; &#125;&#125; 要理解上述代码如何工作，我们可能只需要知道扩延AbstractAnnotationConfigDispatcherServletInitializer的任意类都会自动地配置DispatcherServlet和Spring应用上下文，Spring的应用上下文会位于应用程序的Servlet上下文之中。 AbstractAnnotationConfigDispatcherServletInitializer剖析： 在Servlet3.0环境中，容器会在类路径中查找实现java.servlet.ServletContainerInitializer接口的类，如果能发现的话，就会用它配置Servlet容器类。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给他们来完成。Spring3.2引入了一个便利的WebApplicationInitializer的基础实现，也就是AbstractAnnotationConfigDispatcherServletInitializer。因为我们的SpittrWebAppInitializer扩展了AbstractAnnotationConfig DispatcherServletInitializer（同时也就实现了WebApplicationInitializer)，因此当部署到Servlet3.0容器中的时候，容器会自动发现它，并用它来配置Servlet上下文。 尽管它的名字很长，但是AbstractAnnotationConfigDispatcherServletInitializer使用起来很简便。SpittrWebAppInitializer中重写了三个方法。第一个方法是getServletMappings() ，它会将一个或多个路径映射到DispatcherServlet上。在本例中，它映射的是“/”，这表示他会是应用的默认Servlet。他会处理进入应用的所有请求。 为了理解其他两个方法，我们首先要理解DispatcherServlet和一个Servlet监听器（也就是ContextLoaderListener）的关系。 两个应用上下文之间的故事当DispatcherServlet启动的时候，他会创建Spring应用上下文，并加载配置文件或配置类中所声明的bean。在getServletConfigClasses（）方法中，我们要求DispatcherServlet加载应用上下文时，使用定义在WebConfig配置类（使用Java配置）中的bean。 但是在SpringWeb应用中，通常还有另外一个应用上下文。另外的这个应用上下文是由ContextLoaderListener创建的。我们希望DispatcherServlet加载包含Web组件的bean，如控制器、视图解析器以及处理器映射，而ContextLoaderListener要加载应用中的其他bean。这些bean通常是驱动应用后端的中间层和数据层组件。 实际上，AbstractAnnotationConfigDispatcherrServletInitializer会同时创建DispatcherServlet和ContextLoaderListener。GetServletConfigClasses（）方法返回的带有@Configuration注解的类加ing会用来定义DispatcherServlet应用上下文中的bean。 在本例中，根据配置定义在RootConfig中，DispatcherServlet的配置声明在WebConfig中。 启用Spring MVC启用SpringMVC组件的方法不仅一种。以前，Spring是使用XML进行配置的，可以使用\\mvc:annotation-driven注解启用注解驱动的SpringMVC。现在我们能创建的最简单的SpringMVC配置就是一个带有@EnableWebMvc注解的类： 123456789package com.caicai.springmvc.spittr.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;@Configuration@EnableWebMvcpublic class WebConfig &#123;&#125; 这可以运行起来，它的确能够启用SpringMVC，但还有不少的问题需要解决： 没有配置视图解析器。这样的话，Spring默认会使用BeanNameView-Resolver，这个视图解析器会查找ID与视图名称匹配的bean，并且查找的bean要实现View接口，他以这样的方式来解析试图。 没有启用组件扫描。这样的结果就是Spring只能找到显式声明在配置类中的控制器。 这样配置的话，DispatcherServlet会映射为应用默认Servlet，所以他会处理所有请求，包括对静态资源的请求，如图片和样式表。 因此，我们需要在WebConfig这个最小的SpringMVC配置上再加一些内容，从而让他们变得真正有用。 1234567891011121314151617181920212223242526272829303132package caicai.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.stereotype.Controller;import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.ViewResolverRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;/** * Springweb应用的配置 相当于配置文件SpringMVC.xml * */@Configuration@EnableWebMvc//配置只会扫描Controller注解@ComponentScan(value = &#123;\"caicai\"&#125;,includeFilters=&#123;@ComponentScan.Filter(type= FilterType.ANNOTATION,value=&#123;Controller.class&#125;)&#125;,useDefaultFilters = false)public class WebConfig extends WebMvcConfigurerAdapter &#123; //配置视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; //默认前缀 /WEB-INF/ 后缀.jsp registry.jsp(); &#125; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;&#125; 在上述代码中第一件需要注意的事情是WebConfig现在添加了@Component-Scan注解。接下来我们设置了视图的默认前缀和后缀。最后，新的WebConfig类还扩展了WebMvcConfigurerAdapter并重写了其configureDefaultServletHandling()方法。通过调用DefaultServlet-HandlerConfigurer的enable（）方法，我们要求DispatcherServlet将对静态资源的请求转发到Servlet容器默认的Servlet上，而不是使用DispatcherServlet本身来处理此类请求。 WebConfig配置已经就绪，我们需要再配置RootConfig： 123456789101112131415package caicai.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.stereotype.Controller;/** * 这个是跟容器，相当于ApplicationContxt.xml,包扫描的时候要排除@Controller注解，避免重复扫描 */@ComponentScan(value =&#123;\"caicai\"&#125;, excludeFilters=&#123;@ComponentScan.Filter(type = FilterType.ANNOTATION,value = &#123;Controller.class&#125;)&#125;)@Configuration//声明这是一个配置类public class RootConfig &#123;&#125; 编写基本的控制器在SpringMVC中，控制器试试方法添加了@RequestMapping注解的类，这个注解声明了他们所要处理的请求。我们声明一个最简单的SpringMVC控制类： 1234567891011121314package caicai.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class HomeController &#123; @RequestMapping(value = \"/\", method = RequestMethod.GET) public String home() &#123; return \"home\"; &#125;&#125; 你可能注意到的一件事就是HomeController带有@Controller注解。很显然这个注解是用来声明控制器的，但实际上这个注解对SpringMVC本身的影响并不大。 HomeController是一个构造型（stereotype）的注解，它基于@Compont注解。在这里，他的目的就是辅助实现组件扫描。因为HomeController带有@Controller注解，因此组件扫描器会自动找到HomeController，并将其声明为Spring应用上下文中的一个bean。 其实也可以让HomeController带有@Component注解，他所实现的效果是一样的，但是在表意性上可能会差一点，无法确定HomeController是什么组件类型。 HomeController唯一的一个方法就是home（）方法，带有@RequestMapping注解。他的value属性制定了这个方法所要处理的请求路径，method属性细化了她所处理的HTTP方法。在本例中，当收到对/的HTTP GET请求时，就会调用home（）方法。home（）方法其实并没有做太多事：它返回了一个String类型的“home”。这个String将会把SpringMVC解读为要渲染的视图名称。DispatcherServlet会要求视图解析器将这个逻辑名解析为实际的视图。 鉴于我们配置InternalResourceViewResolver的方式，视图名“home”将会解析为“/WEB-INF/home.jsp”路径的JSP。 home.jsp代码如下： 12345678910111213141516&lt;%-- Created by IntelliJ IDEA. User: 1 Date: 2019/11/30 Time: 14:53 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 定义类级别的请求处理12345678910111213141516package caicai.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller@RequestMapping(\"/\")public class HomeController &#123; @RequestMapping(method = RequestMethod.GET) public String home() &#123; return \"home\"; &#125;&#125; 在这个新版本的HomeController中，路径现在被转移到类级别的@RequestMapping上，而HTTP方法易染映射在方法级别上。当控制器在类级别上添加@RequestMapping注解时，这个注解会应用到控制器的所有处理器方法上。处理器方法上的@RequestMapping注解会对类级别上的@RequestMapping的声明进行补充。 就HomeController而言，这里只有一个控制器方法。与类级别的@RequestMapping合并后，这个方法的@RequestMapping表明home()将会处理对”/“路径的GET请求。 换言之，我们没有改变任何功能，只是将一些代码换了个地方，HomeController所做的事情和以前是一样的。 传递模型数据到视图中到现在为止，就编写超级简单的控制器来说，HomeController已经是一个不错的样例了。但是大多数的控制器不是这么简单。在应用中，我们需要有一个页面展现最近提交的列表。因此，我们需要一个新的方法来 处理这个界面。 首先，需要定义一个数据访问的Repository。为了实现解耦以及避免陷入数据库访问的细节之中，我们将Repository定义为一个接口。我们只需要一个能够获取列表的Repository，如下所示的SpittleRepository功能已经足够了： 1234567package caicai.data;import java.util.List;public interface SpittleRepository &#123; List&lt;Spittle&gt; findSpittles(long max, int count);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package caicai.data;import java.util.Date;public class Spittle &#123; private final Long id; private final String message; private final Date time; private Double latitude; private Double longitude; public Spittle(String message, Date time) &#123; this(message, time, null, null); &#125; public Spittle(String message, Date time, Double longitude, Double latitude) &#123; this.id = null; this.message = message; this.time = time; this.longitude = longitude; this.latitude = latitude; &#125; public Long getId() &#123; return id; &#125; public String getMessage() &#123; return message; &#125; public Date getTime() &#123; return time; &#125; public Double getLatitude() &#123; return latitude; &#125; public Double getLongitude() &#123; return longitude; &#125;&#125; ## ​","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://caicaing.github.io/tags/Spring/"}]},{"title":"Spring面向切面编程","slug":"Spring面向切面编程","date":"2019-11-21T01:32:37.000Z","updated":"2019-11-26T13:50:52.113Z","comments":true,"path":"2019/11/21/Spring面向切面编程/","link":"","permalink":"https://caicaing.github.io/2019/11/21/Spring面向切面编程/","excerpt":"Spring面向切面编程","text":"Spring面向切面编程 Spring面向切面编程AOP术语通常切面的常用术语有通知(advice)、切点(pointcut)和连接点(joinpoint)。 通知(Advice)Spring切面可以应用5种类型的通知： 前置通知(Before):在目标方法被调用之前调用通知功能 后置通知(After):在目标方法完成之后调用通知,此时不会关心方法的输出是什么 返回通知(After-returning):在目标方法成功执行之后调用通知 异常通知(After-throwing):在目标方法抛出异常后调用通知 环绕通知(Around):通知包裹了被通知的方法,在被统治的方法调用之前和调用之后执行自定义的行为 连接点(Join Point)连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时，甚至是修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。 切点(Poincut)如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个节点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。 切面(Aspect)切面时通知和切点的集合。通知和切点共同定义了切面的全部内容——他是什么，何时何处完成。 引入(Introduction)引入允许我们向现有的类添加新的方法和属性。例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让他们具有新的行为和状态。 织入(Weaving)织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入： 编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。 类加载器：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader)，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入(load-time weaving ,LTW)就支持这种方式织入切面。 运行期：切面在应用运行时的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。 Spring对AOP的支持并不是所有的AOP框架都是相同的，他们在连接点模型上可能有强弱之分。有些允许在字段修饰符级别应用通知，而另一些只支持与方法调用相关的连接点。他们织入切面的方式和时机也有所不同。但是无论如何，创建切点来定义切面所织入的连接点是AOP框架的基本功能。 Spring提供了4中类型的AOP支持： 基于代理的经典Spring AOP 纯POJO切面 @AspectJ注解驱动的切面 注入式AspectJ切面（适用于Speing各版本） 前三种都是Spring AOP实现的变体，Spring AOP构建在动态代理基础之上，因此，Spring对AOP的支持局限方法拦截。 通过切点来选择连接点在Spring AOP中，要使用AspectJ的切点表达式语言来定义切点 AspectJ指示器 描述 arg() 限制连接点匹配参数为指定类型的执行方法 @args() 限制连接点匹配参数由指定注解标注的执行方法 execution() 用于匹配是连接点的执行方法 this() 限制连接点匹配AOP代理的bean引用为指定类型的类 target 限制连接点匹配目标对象为指定的类 @target() 限制连接点匹配特顶的执行对象，这些对象对应的类要具有指定类型的注解 within() 限制连接点匹配指定的类型 @within() 限制连接点匹配指定注解所标注的类型 @annotation 限定匹配带有指定注解的连接点 在Spring中常识使用AspectJ其他指示器时，将会抛出IllegalArgumentException异常。 当我们查看如上所展示的那些Spring指示的指示器时，注意只有execution指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器。在此基础上，我们能使用其他指示器来限制所匹配的切点。 使用注解创建切面使用注解创建切面是AspectJ5所引入的关键特性。AspectJ5之前，编写AspectJ切面需要学习一种java语言的扩展，但是AspectJ面向注解的模型可以非常渐变地通过少量注解把任意类型转变变为切面。 首先我们要定义一个Performance接口，它是切面中切点的目标对象。 123public interface Performance &#123; public void perform();&#125; 定义切面如果一场演出没有观众的话，那不能称之为演出。从演出的角度来看，观众是非常重要的，但是对演出的本身功能来讲，他并不是核心，这是一个单独的关注点。因此，将观众定义为一个切面，并将其应用到演出上就是较为明智的做法。 1234567891011121314151617181920212223242526272829import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class Audience &#123; @Before(\"execution(* com.example.demo.Performance.perform(..))\") public void silenceCellPhones() &#123; System.out.println(\"Silencing cell phones\"); &#125; @Before(\"execution(* com.example.demo.Performance.perform(..))\") public void takeSeats() &#123; System.out.println(\"Taking seats\"); &#125; @AfterReturning(\"execution(* com.example.demo.Performance.perform(..))\") public void applause() &#123; System.out.println(\"CLAP CLAP CLAP!!!\"); &#125; @AfterThrowing(\"execution(* com.example.demo.Performance.perform(..))\") public void demandRefund() &#123; System.out.println(\"Demanding a refund\"); &#125;&#125; Audience类使用@AspectJ注解进行了标注。该注解表明Audience不仅仅是一个POJO，还是一个切面。Audience类中的方法都是用注解来定义切面的具体行为。 Audience有四个方法，定义了一个观众在观看演出时可能会做的事情。在演出之前，观众要就做(takeSeats())并将手机调至静音状态(silenceCellPhones())。如果演出很精彩的话，观众应该会鼓掌喝彩(applause())。不过如果演出没有达到观众预期的话，观众会要求退款(demandRefundd())。 AspectJ提供了五个注解来定义通知： 注解 通知 @After 通知方法会在目标方法返回或抛出异常后调用 @AfterReturning 通知方法会在目标方法返回后调用 @AfterThrowing 通知方法会在目标方法抛出异常后调用 @Around 通知方法会将目标方法封装起来 @Before 通知方法会在目标方法调用之前运行 Audience使用到了前面五个注解中的三个。takeSeats()和silence CellPhones()方法都用到了@Before注解，表明他们应该在演出开始之前调用。applause()方法使用了AfterReturning注解，他会在演出成功返回后调用。de’man’d’Refund()方法上添加了@AfterThrowing注解，这表明他会在抛出异常以后执行。 在上述代码中，相同的一个切点表达式我们重复了四边，我们完全可以这样做：@Pointcut注解能够在一个@AspectJ切面内定义可重用的切点。接下来的程序清单4.2展现了新的Audience，现在它使用了@Pointcut。 123456789101112131415161718192021222324252627282930import org.aspectj.lang.annotation.*;@Aspectpublic class Audience1 &#123; @Pointcut(\"execution(* com.example.demo.Performance.perform(..)))\") public void performance() &#123; &#125; @Before(\"performance()\") public void silenceCellPhones() &#123; System.out.println(\"Silencing cell phones\"); &#125; @Before(\"performance()\") public void takeSeats() &#123; System.out.println(\"Taking seats\"); &#125; @AfterReturning(\"performance()\") public void applause() &#123; System.out.println(\"CLAP CLAP CLAP!!!\"); &#125; @AfterThrowing(\"performance()\") public void demandRefund() &#123; System.out.println(\"Demanding a refund\"); &#125;&#125; 在Audience中，performance()方法使用了@Pointcut注解。为@Pointcut注解设置的值是一个切点表达式，就像之前在通知注解上所设置的那样。通过在performance()方法上添加@Pointcut注解，我么恩实际上扩展了切点表达式语言。这样就可以在任何的且地点表达式中使用performance()了，如果不这样做的话，你需要在这些地方使用那个更长的切点表达式。我们现在把所有通知注解中的长表达式都换成了performance()。 performance()方法的实际内容并不重要，在这里它实际上因嘎嘎i是空的。其实该方法本身只是一个表示，供@pointcut注解依附。 需要注意的是，除了注解和没有实际操作的呃performance()方法，Audience类依然是一个POJO。我们能够像使用其他的java类那样调用它的方法，他的方法也能独立的进行单元测试，这与其他的Java类并没有什么区别。Audience只是一个Java类，只不过它通过注解表明会作为切面使用而已。 像其他java类一样，他可以装配为Spring中的bean： 1234@Beanpublic Audience audience() &#123; return new Audience();&#125; 如果就此止步的话，Audience只会是Spring容器中的一个bean。即便使用了AspectJ注解，但他并不会被视为切面，这些注解不会解析，也不会创建将其转换为切面的代理。 如果使用JavaConfig的话，可以在配置类的类级别上通过使用@EnableAspectJ-AutoProxy注解启用自动代理功能 1234567891011121314import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration@EnableAspectJAutoProxy@ComponentScanpublic class ConcertConfig &#123; @Bean public Audience audience() &#123; return new Audience(); &#125;&#125; 创建环绕通知环绕通知是最为强大的通知类型。他能够让你所编写的逻辑将被统治的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。 为了阐述环绕通知，我们重写Audience切面。这次我们使用一个环绕通知来代替之前多个不同的前置通知和后置通知。 12345678910111213141516171819202122import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;@Aspectpublic class Audience2 &#123; @Pointcut(\"execution(* com.example.demo.Performance.perform(..))\") public void performance() &#123; &#125; @Around(\"performance()\") public void watchPerformance(ProceedingJoinPoint jp) &#123; try &#123; System.out.println(\"Silencing cell phones\"); System.out.println(\"Taking seats\"); jp.proceed(); System.out.println(\"CLAP CLAP CLAP!!!\"); &#125; catch (Throwable e) &#123; System.out.println(\"Demanding a refund\"); &#125; &#125;&#125; 在这里，@Around注解表明watchPerformance()方法会作为performance()切点的环绕通知。在这个通知中，观众在演出之前会将手机调至静音并就做，演出结束后会鼓掌喝彩，如果演出失败的话，观众会要求退款。可以看到，这个通知所达到的效果与之前的前置通知和后置通知是一样的。但是，现在他们位于同一个方法中，不像之前那样分散在四个不同的方法里。 关于这个新的通知方法，你首先注意到的可能是它接收ProceedingJoinPoint作为参数。这个对象是必须要有的，因为你要在通知中通过它来调用被统治的方法。通知方法中可以做任何事情，当要将控制权交给被通知的方法是，他需要调用ProceedingJoinPoint的proceed()方法。 小结AOP是面向对象编程的一个强大补充。通过AspectJ，我们现在可以把之前分散在应用各处的行为放入可重用的模块中。我们显示地声明在何处如何应用该行为。这有效减少了代码冗余，并让我们的类关注自身的主要功能。 Spring提供了一个AOP框架，让我们把切面插入到方法执行的周围。关于在Spring应用中如何使用切面，我们可以有多种选择。通过使用@AspectJ注解和简化的配置命名空间，在Spring中装配通知和切点变得非常简单。","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://caicaing.github.io/tags/Spring/"}]},{"title":"Spring 运行时注入","slug":"Spring-运行时注入","date":"2019-11-19T10:47:01.000Z","updated":"2019-11-21T01:29:23.258Z","comments":true,"path":"2019/11/19/Spring-运行时注入/","link":"","permalink":"https://caicaing.github.io/2019/11/19/Spring-运行时注入/","excerpt":"Spring运行时注入","text":"Spring运行时注入 运行时注入当讨论依赖注入时候，我们通常所讨论的时将一个bean注入到另一个bean的属性或者构造器参数中。它通常来讲是指将一个对象与另一个对象进行关联。 但是bean装配的另外一个方面指的是将一个值注入到bean的属性或者构造器参数中。有时候硬编码是可以的，但是有的时候，我们可能会希望避免硬编码值，而是想让这些值在运行的时候再确定，为了实现这些功能，Spring提供了两种再运行时求值的方式： 属性占位符（Property placeholder） Spring表达式语言（SpEL） 这两种技术的用法是类似的，不过他们的目的和行为是有所差别的。 注入外部的值在Spring中，处理外部值的最简单方式就是声明属性源并通过Spring的Environment来检索属性。 123456789101112@Configuration@PropertySource(\"classpath:/application.properties\")public class ExpressiveConfig &#123; @Autowired Environment environment; @Bean public BlackDisc disc()&#123; return new BlackDisc(environment.getProperty(\"disc.title\"),environment.getProperty(\"disc.artist\")); &#125;&#125; 1234567891011121314151617public class BlackDisc &#123; private String title; private String artist; @Override public String toString() &#123; return \"BlackDisc&#123;\" + \"title='\" + title + '\\'' + \", artist='\" + artist + '\\'' + '&#125;'; &#125; public BlackDisc(String title, String artist) &#123; this.title = title; this.artist = artist; &#125;&#125; 本例中@PropertySource引用了类路径中一个名为application.properties的文件，内容大致如下所示： 12disc.title = Sgt. Peppers Lonely Hearts Clud Banddisc.artist = The Beatles 这个属性文件会加载到Spring的Environment中，稍后可以从这里检索属性。 深入学习Spring的EnvironmentEnvironment中getProperty（）方法中有四个重载的变种形式： String getProperty(String key) String getProperty(String key, String defaultValue) T getProperty(String key, Class type) T getProperty(String key, Class type, T defaultValue) 前两种形式的getProperty返回的是String类型的值， 第二种比第一种增加了一个默认值，如果指定属性不存在的时候就会使用这个默认值。剩下的两种可以返回对象类型。如果我们从属性文件中得到的是一个String类型的值，并且在使用之前需要将其转换为Integer类型，如果使用第三四中方式可以非常方便的解决这个问题： 1int connectionCount = environment.getProperty(\"db.connection.count\", Integer.class, 30) 当在使用getProperty()方法时没有指定默认值，并且属性没有定义的话，获取到的是null，如果希望属性必须要定义，那么可以使用getRequiredProperty（）方法，如下所示： 1234@Beanpublic BlackDisc disc() &#123; return new BlackDisc(environment.getRequiredProperty(\"disc.title\"), environment.getRequiredProperty(\"disc.artist\"));&#125; 如果disc.title或disc.artist属性没有定义的话，将会抛出IllegalStateException异常。 如果想检查某个属性是否存在，可以调用Environment的containsProperty（）方法。 1boolean titleExists = environment.containsProperty(\"disc.title\"); 解析占位符Spring 一直支持将属性定义到外部的属性文件中，并使用占位符值将其插入到Spring bean中。在Spring装配中，占位符的形式为使用${…} 包装的属性名称。配合@Value注解BlankDisc可以改成如下所示 1234567891011121314public class BlackDisc &#123; @Value(\"$&#123;disc.title&#125;\") private String title; @Value(\"$&#123;disc.artist&#125;\") private String artist; @Override public String toString() &#123; return \"BlackDisc&#123;\" + \"title='\" + title + '\\'' + \", artist='\" + artist + '\\'' + '&#125;'; &#125;&#125; 为了使用占位符，我们需要配置一个PropertySourcesPlaceholderConfigurer，如下的@Bean方法在java中配置了PropertySourcesPlaceholderConfigurer： 1234@Beanpublic PropertySourcesPlaceholderConfigurer placeholderConfigurer() &#123; return new PropertySourcesPlaceholderConfigurer();&#125; 使用Spring表达式语言进行装配Spring3引入了Spring表达式语言（Spring Expression Language SpEL)，他能够以一种强大和简洁的方式将值装配到bean属性装配到bean属性和构造器参数中，在这个过程中所使用的表达式会在运行时计算得到值。 SpEL有很多特性： 使用bean的ID来引用bean 调用方法和访问对象的属性 对值进行算数、关系和逻辑运算 正则表达式匹配 集合操作 SpEL样例#{1} 除去#{} 标记后，剩下的就是SpEL的表达式体了，也就是一个数字常量。 #（T(System).currentTimeMillins())} 他的最终结果是计算表达式得到那一刻当前时间的毫秒数。T()表达式会将java.lang.System视为java中对应的类型 ，因此可以调用其static修饰的currentTimeMillis()方法。 SpEL表达式也可以引用qitabean 或其他bean 打的属性。例如 #{sgtPeppers.artist} 我们使用SpEL来表达式来重新修改BlankDisc： 1234567891011121314public class BlackDisc &#123; @Value(\"#&#123;systemProperties['disc.title']&#125;\") private String title; @Value(\"#&#123;systemProperties['disc.artist']&#125;\") private String artist; @Override public String toString() &#123; return \"BlackDisc&#123;\" + \"title='\" + title + '\\'' + \", artist='\" + artist + '\\'' + '&#125;'; &#125;&#125; 标识字面值下面的SpEL表达式表示的是浮点值： #{3.14159} 数值还可以用科学计数法的方式进行表示： #{9.87E4} SpEL表达式也可以用来计算String类型的字面值，如: #{‘hello’} 最后字面值true和false的计算结果就是他们对应的Boolean类型的值，例如： #{false} 引用bean、属性和方法SpEL所能做的另外一件事就是通过ID引用其他的bean。例如，你可以使用SpEL将一个bean装配到另外一个bean属性中，此时要使用beanID作为SpEL表达式，例如： #{sgtPeppers} 现在 假设我们想在一个表达式中引用sgtPeppers的artist属性： #{sgtPeppers.artis} 除了引用属性，我们还可以调用bean上的方法，例如： #{artistSelector.selectArtist()} 对于被调用方法的返回值来说，我们同样可以调用它的方法，例如，如果selectArtist()方法返回的是一个String，那么可以调用toUpperCase()将整个字符串变为大写。 #{artistSelector.selectArtist().toUpperCase()} 为了避免selectArtist()返回值是null我们可以使用类型安全的运算符： #{artistSelector.selectArtist()?.toUpperCase()} 与之前只是使用点号(.)不同，我们使用(?.)运算符，这个运算符能够在访问他右边的内容之前，确保他所对应的元素不是null。所以如果selectArtist()返回的值是null，那么SpEL将不会调用toUpperCase()方法。表达式的返回值会是null。 在表达式中使用类型如果要在SpEL中访问类作用域的方法和常量的话，要以来T()这个关键的运算符。例如，为了在SpEL中表达Java的Math类，需要按照如下的方式使用T()运算符： T(java.lang.Math) 这里所示的T()运算符的结果是一个Class对象，代表了java.lang.Math。如果需要的话，我们甚至可以将其装配到一个class类型的bean属性中。但是T()运算符的真正价值在于它能够访问目标类型的静态方法和常量。例如要将PI的值装配到bean属性中。使用如下SpEL就能完成任务 T(java.lang.Math).PI SpEL运算符SpEL提供了多个运算符，这些运算符可以用在SpEL表达式上 运算符类型 运算符 算数运算 +、-、*、/、%、^ 比较运算 &lt;、&gt;、 == 、 &lt;= 、&gt;=、lt、gt、eq、le、ge 逻辑运算 and、or、not、\\ 条件运算 ?: (ternary)、?:(Elvis) 正则表达式 matches 计算集合SpEL中可以引用列表中的一个元素，例如： #{jukebox.songs[4].title} 这个表达式会计算songs集合中第五个元素的title属性，这个集合来源于id为jukebox bean “[]”运算符除了可以从集合或数组按照索引获取元素，实际上，它还可以从String中获取一个字符。比如： #{‘This is a test’[3]} 这个表达式引用了String中的第四个字符，也就是“s” SpEL还提供了查询运算符(.?[])，他会对集合进行过滤，得到集合的一个子集。例如： #{jukebox.songs.?[artist eq ‘Aerosmith’]} 这样就得到了Aerosmith的所有歌曲。当SpEL迭代歌曲列表时候，会对歌曲集合中的每一个条目计算这个表达式。如果表达式的计算结果是true的话，那么条目会放到新的集合中。否则，他就不会放到新的集合中。 SpEL还提供了另外两个查询运算符：”.^[]” 和”.$[]”,他们分别用来在集合中查询第一个匹配项和最后一个匹配项。最后，SpEL还提供了投影运算符(.![])，他会从集合的每个成员中选择特顶的属性放到另外一个集合中。","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://caicaing.github.io/tags/Spring/"}]},{"title":"Spring bean的作用域","slug":"Spring-bean的作用域","date":"2019-11-19T08:31:09.000Z","updated":"2019-11-20T02:00:36.623Z","comments":true,"path":"2019/11/19/Spring-bean的作用域/","link":"","permalink":"https://caicaing.github.io/2019/11/19/Spring-bean的作用域/","excerpt":"Spring bean的作用域","text":"Spring bean的作用域 bean 的作用域默认情况下，Spring应用上下文中所有的bean都是作为以单例创建的的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。在大多数情况下，单例bean是很理想的方案，但是有时候所用的类是易变的，他们会保持一些状态，所以重用是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了，因为对象会被污染，稍后重用的时候会发生意想不到的问题。 Spring定义了多种作用域，可以基于这些作用域创建bean，包括： 单例（Singleton）：在整个应用中，只创建一个bean的一个实例。 原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候都会创建一个新的bean实例。 会话（Session）：在web应用中，为每个会话创建一个bean实例。 请求（Request）；在web应用中，为每个请求创建一个bean实例。 单例是默认的作用域，但是正如之前所述对于易变的类型，这并不合适。如果选择其他的作用域，要使用@Scope注解，它可以与@Component注解和@Bean一起使用。 例如如果使用组件扫描来发现和声明bean，那么可以在bean的类上使用@Scope注解，将其声明为原型的bean： 1234@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class Notepad &#123;&#125; 这里使用ConfigurableBeanFactory的SCOPE_PROTOTYPE常量设置了原型作用域，当然也可以使用@Scope（”prototype”)，但是使用常量更加安全且不容易出错。 同样，如果使用xml来配置bean，可以使用bean标签的scope属性来设置作用域： 1&lt;bean id = \"noteped\" class = \"com.myapp.Notepad\" scope = \"protorype\" /&gt; 不管使用哪种方式来声明原型作用域，每次注入或从Spring应用上下文中检索该bean的时候都会创建新的实例。 使用会话和请求作用域在web应用中如果能够实例化在会话和请求范围内共享的bean，那将是非常有价值的事情。例如，在典型的电子商务应用中，可能会有一个bean代表用户的购物车。如果购物车是单例的话，那么将会导致所有打的用户都会向同一个购物车中添加商品，在应用的另一个地方可能就不可用了，因为这里注入的是另外一个原型作用域的购物车。 就购物车bean来说，会话作用域是最为合适的因为他与给定的用户关联性最大。要制定会话作用域，我们可以使用@Scope注解，他的使用方式和原型作用域是相同的 12345@Component@Scope(value = WebApplicationContext.SCOPE_SESSION ,proxyMode = ScopedProxyMode.INTERFACES)public class ShoppingCart &#123;&#125; 这里我们将value设置成了WebApplicationContext.SCOPE_SESSION常量（它的值是session）。这回告诉Spring为Web应用中的每个会话创建一个ShoppingCart。这会创建多个ShoppingCart bean的实例，但是对于给定的会话只会创建一个实例，在当前会话相关的操作中，这个bean实际上相当于单例的。 @Scope同时还有一个proxyMode属性，他被设置成了ScopedProxyMode.INTERFACES。这个属性解决了将对话或请求作用域的bean注入到单例bean中所遇到的问题。我们先来看一下proxyMode所解决问题的场景。 假设我们要将ShoppingCart bean注入到单例storeService bean的Setter方法中，如下所示： 123456789@Componentpublic class StoreService &#123; private ShoppingCart shoppingCart; @Autowired public void setShoppingCart(ShoppingCart shoppingCart) &#123; this.shoppingCart = shoppingCart; &#125;&#125; 因为StoreService是一个单例的bean，会在Spring应用上下文加载的时候创建。当它创建的时候，Spring会试图将ShoppingCart bean注入到setShoppingCart()方法中。但是shoppingCart bean 是会话作用域，此时并不存在，直到某个用户进入系统，创建了会话之后，才会出现ShoppingCart实例。 另外，系统中将会有多个ShoppingCart实例：每个用户一个。我们并不想让Spring注入某个固定的ShoppingCart 实例到StoreService中。我们希望的是当StoreService处理购物车功能时，它所使用的ShoppingCart实例刚好是当前会话所对应的那个。 Spring并不会将实际的ShoppingCart bean 注入到StoreService中，Spring会注入一个到ShoppingCart bean 的代理，这个代理会暴露与ShoppingCart相同的方法，所以StoreService会认为啊就是一个购物车。但是，当StoreService嗲啊用ShoppingCart的方法时，代理会对其进行懒解析并且将调用委托给会话作用域内的真正的ShoppingCart bean。 如配置所示，proxyMode属性被设置为了ScopedProxyMode.INTERFACES，这表明这个代理要实现ShoppingCart接口，并且调用委托给实现bean。 如果ShoppingCart是接口而不是类的话，这是可以的。但如果ShoppingCart是一个具体的二类的话，Sping就没有办法创建基于接口的代理了。所以，如果bean类型是具体类的话，我们必须要将proxyMode属性设置为ScopedProxyMode.TARGET_CLASS，以此来表明要以生成目标扩展的方式创建代理。","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://caicaing.github.io/tags/Spring/"}]},{"title":"设计模式-命令模式","slug":"设计模式-命令模式","date":"2019-11-07T07:37:27.000Z","updated":"2019-11-10T03:15:54.087Z","comments":true,"path":"2019/11/07/设计模式-命令模式/","link":"","permalink":"https://caicaing.github.io/2019/11/07/设计模式-命令模式/","excerpt":"设计模式之命令模式","text":"设计模式之命令模式 命令模式定义命令模式讲请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。 一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。要达到这一点，命令对象将动作和接收者包进对象中。这个对象只暴露出一个execute()方法，当此方法呗调用的时候，接收者就会进行这些动作。从外面来看，其他对象不知道究竟哪个接收者进行了哪些动作，只知道如果调用execute（）方法，请求的目的就能达到。 简单命令模式代码示例1234567891011package restaurant;/** * @ClassName: Command * @Author: 1 * @Description: * @Version: 1.0 */public interface Command &#123; public void execute();&#125; 12345678910111213package restaurant;/** * @ClassName: Light * @Author: 1 * @Description: * @Version: 1.0 */public class Light &#123; public void on() &#123; System.out.println(\"light on\"); &#125;&#125; 123456789101112131415161718192021package restaurant;/** * @ClassName: LightOnCommand * @Author: 1 * @Description: * @Version: 1.0 */public class LightOnCommand implements Command &#123; Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.on(); &#125;&#125; 12345678910111213141516171819202122package restaurant;/** * @ClassName: SimpleRemoteControl * @Author: 1 * @Description: * @Version: 1.0 */public class SimpleRemoteControl &#123; Command command; public SimpleRemoteControl() &#123; &#125; public void setCommand(Command command) &#123; this.command = command; &#125; public void buttonWasPressed() &#123; command.execute(); &#125;&#125; 1234567891011121314151617package restaurant;/** * @ClassName: RemoteControlTest * @Author: 1 * @Description: * @Version: 1.0 */public class RemoteControlTest &#123; public static void main(String [] args) &#123; SimpleRemoteControl remote = new SimpleRemoteControl(); Light light = new Light(); LightOnCommand lightOn = new LightOnCommand(light); remote.setCommand(lightOn); remote.buttonWasPressed(); &#125;&#125; 通过运行RemoteControlTest的Main函数得到运行结果 1light on 遥控器实现遥控器有多个按钮，每个按钮对应不同的操作。我们打算将遥控器的每个按钮对应到一个命令，这样就可以让遥控器变成调用者，当按下按钮时，相应命令对象的execute()方法就会被i调用，结果就是接收者的动作被调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package remote;/** * @ClassName: RemoteControl * @Author: 1 * @Description: * @Version: 1.0 */public class RemoteControl &#123; Command[] onCommands; Command[] offCommands; public RemoteControl() &#123; onCommands = new Command[7]; offCommands = new Command[7]; Command noCommand = new NoCommand(); for (int i = 0; i &lt; 7; i++) &#123; onCommands[i] = noCommand; offCommands[i] = noCommand; &#125; &#125; public void setCommand(int slot, Command onCommand, Command offCommand) &#123; onCommands[slot] = onCommand; offCommands[slot] = offCommand; &#125; public void onButtonWasPushed(int slot) &#123; onCommands[slot].execute(); &#125; public void offButtonWasPushed(int slot) &#123; offCommands[slot].execute(); &#125; @Override public String toString() &#123; StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(\"\\n ---------Remote Control --------\\n\"); for (int i = 0; i &lt; onCommands.length; i++) &#123; stringBuffer.append(\"[slot\" + i + \"] \" + onCommands.getClass().getName() + \" \" + offCommands[i].getClass().getName() + \"\\n\"); &#125; return stringBuffer.toString(); &#125;&#125; 1234567891011121314package remote;/** * @ClassName: NoCommand * @Author: 1 * @Description: * @Version: 1.0 */public class NoCommand implements Command &#123; @Override public void execute() &#123; &#125;&#125; 1234567891011121314151617181920package remote;/** * @ClassName: RemoteLoader * @Author: 1 * @Description: * @Version: 1.0 */public class RemoteLoader &#123; public static void main(String[] args) &#123; RemoteControl remoteControl = new RemoteControl(); Light light = new Light(); Command lightOnCommand = new LightOnCommand(light); Command lightOffCommand = new LightOffCommand(light); remoteControl.setCommand(0,lightOnCommand,lightOffCommand); remoteControl.onButtonWasPushed(0); remoteControl.offButtonWasPushed(0); &#125;&#125; RemoteLoader中，将命令对象通过setCommand方法为每个插槽的按钮绑定事件。通过调用 onButtonWasPushed和offButtonWasPushed来控制第几个按钮的开和关动作。上述代码中，为了不想每次都检查某个插槽是否加载了命令，比如在onButtonWasPushed()方法中我们需要添加验证是否是空 12345public void onButtonWasPushed(int slot) &#123;if ( onCommands[slot] != null)&#123; onCommands[slot].execute();&#125;&#125; 为了避免上述做法，我们实现了一个不做任何事情的命令，这么一来在RemoteControl构造器中，我们将每个插槽都预先指定NoCommand对象，以便确定每个插槽永远都有对象。所以在测试的输出中，没有被明确指定命令的插槽，其命令将是默认的NoCommand对象。举例来说，遥控器不可能一出厂就设置了有意义的命令对象，所以提供了NoCommand对象作为代用品，当调用他的execute（）方法时，这种对象什么事情都不做。在组多设计模式中，都会看到空对象的使用。甚至有些时候，空对象本身也被视为是一种设计模式。 最后我们需要添加对撤销按钮的支持。撤销按钮会将上一个动作取消，例如电灯是关闭的当你按下开启按钮后打开，继续按下撤销按钮时，开启操作应该被撤销，灯应该回到熄灭状态。我们首先将Command接口添加一个撤回的方法 12345public interface Command &#123; public void execute(); public void undo();&#125; 之后在各个命令中实现undo方法，对于撤销来说也就是应该执行与当前命令相反的命令，关闭灯的撤销命令就应该开启灯。 123456789101112131415161718public class LightOffCommand implements Command &#123; Light light; public LightOffCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.off(); &#125; @Override public void undo() &#123; light.on(); &#125;&#125; 12345678910111213141516171819202122232425262728package remote;/** * @ClassName: LightOnCommand * @Author: 1 * @Description: * @Version: 1.0 */public class LightOnCommand implements Command &#123; Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.on(); &#125; @Override public void undo() &#123; light.off(); &#125;&#125; 最后我们要对遥控器做一些小修改。能够让他追踪最后被调用的命令，不管何时撤销按钮被按下我们都可以取出这个命令并调用它的undo方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package remote;/** * @ClassName: RemoteControl * @Author: 1 * @Description: * @Version: 1.0 */public class RemoteControlWithUndo &#123; Command[] onCommands; Command[] offCommands; // 记录上一次操作的命令变量 Command undoCommand; public RemoteControlWithUndo() &#123; onCommands = new Command[7]; offCommands = new Command[7]; Command noCommand = new NoCommand(); for (int i = 0; i &lt; 7; i++) &#123; onCommands[i] = noCommand; offCommands[i] = noCommand; &#125; undoCommand = noCommand; &#125; public void setCommand(int slot, Command onCommand, Command offCommand) &#123; onCommands[slot] = onCommand; offCommands[slot] = offCommand; &#125; public void onButtonWasPushed(int slot) &#123; onCommands[slot].execute(); // 每次执行命令的时候都赋值给undoCommand undoCommand = onCommands[slot]; &#125; public void offButtonWasPushed(int slot) &#123; offCommands[slot].execute(); undoCommand = offCommands[slot]; &#125; public void undoButtonWasPushed() &#123; undoCommand.undo(); &#125; @Override public String toString() &#123; StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(\"\\n ---------Remote Control --------\\n\"); for (int i = 0; i &lt; onCommands.length; i++) &#123; stringBuffer.append(\"[slot\" + i + \"] \" + onCommands.getClass().getName() + \" \" + offCommands[i].getClass().getName() + \"\\n\"); &#125; return stringBuffer.toString(); &#125;&#125; 要点 命令模式将发出请求的对象和执行请求的对象解耦。 在被解耦的两者之间是通过命令对象进行沟通的，命令对象封装了接收者和一个或一组动作。 调用者通过调用命令对象的execute（）发出请求，这会使得接受者的动作被调用。 调用者可以接受命令当作参数，甚至在运行时动态的进行。 命令可以支持撤销，做法是实现一个undo（）方法来回到execute（）被执行的状态。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://caicaing.github.io/tags/设计模式/"}]},{"title":"设计模式--单例模式","slug":"设计模式-单例模式","date":"2019-10-13T02:58:14.000Z","updated":"2019-10-14T09:17:40.630Z","comments":true,"path":"2019/10/13/设计模式-单例模式/","link":"","permalink":"https://caicaing.github.io/2019/10/13/设计模式-单例模式/","excerpt":"设计模式之单例模式","text":"设计模式之单例模式 单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 下面直接上代码： 123456789101112131415161718192021222324package singleton;/** * @ClassName: Singleton * @Author: 1 * @Description: * @Version: 1.0 */public class Singleton &#123; private static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; 通过构造方法私有化，使用getInstance来获取实例，如果刚开始uniqueInstance为空则new一个实例出来。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://caicaing.github.io/tags/设计模式/"}]},{"title":"设计模式--装饰者模式","slug":"设计模式-装饰者模式","date":"2019-10-12T06:57:47.000Z","updated":"2019-11-10T03:21:17.568Z","comments":true,"path":"2019/10/12/设计模式-装饰者模式/","link":"","permalink":"https://caicaing.github.io/2019/10/12/设计模式-装饰者模式/","excerpt":"设计模式之装饰者模式","text":"设计模式之装饰者模式 装饰者模式装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。 拿一个很常见的事来举例：吃火锅。我们吃火锅的时候首先需要点锅底，锅底有很多种，如清汤，牛油，番茄，鸳鸯等。点完锅底之后我们需要点菜品。那么我们如何来设计一个火锅类来表示一个火锅里到底有什么菜品？比较容易想到的事建立一个火锅类，然后在类中设置不同的布尔变量来标记火锅中是否有某种菜品。这样是可行的，但是却存在一些缺点，当我们需要去扩展代码时候，例如火锅店又推出了几款新的菜品或者删除了几款菜品，我们都需要在火锅类的代码里进行增加或者删除代码。我们违反了一个设计模式中的重要原则：类应该对扩展开放，对修改关闭。我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。具体设计如下： 1.建立火锅的超类(被装饰对象超类)： 12345public abstract class HuoGuo &#123; public abstract float cost(); public abstract String name();&#125; 2.定义具体锅底（具体被装饰对象）： 123456789101112131415161718192021222324public class FanQieGuo extends HuoGuo &#123; @Override public float cost() &#123; return 66.6f; &#125; @Override public String name() &#123; return \"番茄锅底\"; &#125;&#125;public class NiuYouGuo extends CaiPin &#123; @Override public float cost() &#123; return 88.8f; &#125; @Override public String name() &#123; return \"牛油锅低\"; &#125;&#125; 3.定义菜品抽象类（装饰者超类）： 123public abstract class CaiPin extends HuoGuo &#123; HuoGuo guoDi;&#125; 4.定义具体菜品（具体的装饰者）： 12345678910111213141516171819202122232425262728293031323334public class FeiNiu extends CaiPin &#123; public FeiNiu(HuoGuo guoDi) &#123; this.guoDi = guoDi; &#125; @Override public float cost() &#123; return guoDi.cost() + 50f; &#125; @Override public String name() &#123; return guoDi.name() + \" + 肥牛\"; &#125;&#125;public class MaoDu extends CaiPin &#123; public MaoDu(HuoGuo guoDi) &#123; this.guoDi = guoDi; &#125; @Override public float cost() &#123; return guoDi.cost() + 40f; &#125; @Override public String name() &#123; return guoDi.name() + \" + 毛肚\"; &#125;&#125; 5.测试 123456789public class Test &#123; public static void main(String[] args) &#123; HuoGuo huoGuo = new FanQieGuo(); huoGuo = new FeiNiu(huoGuo); huoGuo = new MaoDu(huoGuo); System.out.println(huoGuo.name() + \" 共计 \" + huoGuo.cost() + \"元\"); &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://caicaing.github.io/tags/设计模式/"}]},{"title":"设计模式--工厂模式","slug":"设计模式-工厂模式","date":"2019-10-10T07:13:46.000Z","updated":"2019-10-11T08:13:39.376Z","comments":true,"path":"2019/10/10/设计模式-工厂模式/","link":"","permalink":"https://caicaing.github.io/2019/10/10/设计模式-工厂模式/","excerpt":"设计模式之工厂模式。","text":"设计模式之工厂模式。 工厂模式简单工厂简单工厂的定义：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类。 假如有一个披萨店，当下订单的时候代码可能是这样写的： 12345678Pizza orderPizza() &#123; Pizza pizza = new Pizza(); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza;&#125; 我们发现在上述代码中实例化对象的时候使用了 new Object()的形式。但对于披萨来说，有很多类型。所以为了能够按照用户下单时所选择的类型进行制作披萨，必须增加一些代码。 1234567891011121314151617181920Pizza orderPizza() &#123; Pizza pizza; /** * 根据pizza的类型来实例化具体的类，然后赋值给pizza变量。值得注意的是，这里的任何披萨都必须实现Pizza接口 */ if (type.equals(\"cheese\")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals(\"pepperoni\")) &#123; pizza = new PepperoniPizza(); &#125; else if (type.equals(\"clam\")) &#123; pizza = new ClamPizza(); &#125; else if (type.equals(\"veggie\")) &#123; pizza = new VeggiePizza(); &#125; pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza;&#125; 但是在经营过程中，可能有的一些新口味的披萨开始流行需要加入到菜单中，或是有的口味的披萨由于销售量太低想从菜单中去除。随着时间的变化，对应的代码就必须一改再改。而对于pizza的制作过程来说是不易改变的。考虑到已经知道哪些会改变，哪些不会改变，该是使用封装的时候了。我们应该将披萨对象的创建移动到orderPizza()之外，把创建披萨的代码移动到另外一个对象中，让这个新对象专职创建披萨。我们称这个新对象就为“工厂”。 将披萨的生成交给工厂后，orderPizza()方法便不在需要关心生成披萨的细节问题，只关心从工厂得到了一个披萨，并且这个披萨实现了Pizza接口，所以它可以调用prepare(),bake(),cut(),box()来进行准备、烘烤 、切片、装盒。具体实现代码如下： 123456789101112131415161718192021package pizzas;public class SimplePizzaFactory &#123; /** * 创建pizza对象的工厂方法 */ public Pizza createPizza(String type) &#123; Pizza pizza = null; if (type.equals(\"cheese\")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals(\"pepperoni\")) &#123; pizza = new PepperoniPizza(); &#125; else if (type.equals(\"clam\")) &#123; pizza = new ClamPizza(); &#125; else if (type.equals(\"veggie\")) &#123; pizza = new VeggiePizza(); &#125; return pizza; &#125;&#125; 1234567891011121314151617181920212223package pizzas;public class PizzaStore &#123; SimplePizzaFactory factory; public PizzaStore(SimplePizzaFactory factory) &#123; this.factory = factory; &#125; public Pizza orderPizza(String type) &#123; Pizza pizza; //把new一个对象替换为用工厂对象创建对象，不再使用具体实例化。 pizza = factory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125;&#125; 工厂方法工厂方法模式是对简单工厂模式进一步的解耦，因为在工厂方法模式中是一个子类对应一个工厂类，而这些工厂类都实现于一个抽象接口。这相当于是把原本会因为业务代码而庞大的简单工厂类，拆分成了一个个的工厂类，这样代码就不会都耦合在同一个类里了。 还是拿披萨店来举例子，当披萨店的经济效益越来越好，大家都希望披萨店能够有更多的加盟店。但是不同区域的加盟店提供的披萨口味可能存在差异。如果利用简单工厂写出几种不同的工厂来对应不同区域的确可以解决披萨口味不同的问题。但是对于其他部分却限制不够，各地的加盟店可以对制作流程进行改变，有的店可能会选择不将披萨切片，或者使用其他厂商的包装盒。但是作为一种品牌的加盟，希望的是能够有统一的标准，所以品牌会希望建立一个框架，能够把加盟店和创建披萨捆绑在一起，并且还能保持一定的弹性。 有个做法可以让披萨制作活动局限于PizzaStore类，而同时又能让这些加盟店依然可以自由的制作该地区的口味。我们将createPizza()方法放回到PizzaStore中并且将它设置成抽象方法，然后为每个区域口味来创建一个PizzaStore的子类。 12345678910111213141516package pizzafm;public abstract class PizzaStore &#123; abstract Pizza createPizza(String item); public Pizza orderPizza(String type) &#123; Pizza pizza = createPizza(type); System.out.println(\"--- Making a \" + pizza.getName() + \" ---\"); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125;&#125; 现在有了一个PizzaStore作为超类，让每个区域类型都继承这个超类，然后自己决定如何制造披萨。 对于披萨本身来说，我们也需要一个超类，让不同类别的披萨能够继承这个超类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package pizzafm;import java.util.ArrayList;public abstract class Pizza &#123; String name; String dough; String sauce; ArrayList&lt;String&gt; toppings = new ArrayList&lt;String&gt;(); void prepare() &#123; System.out.println(\"Prepare \" + name); System.out.println(\"Tossing dough...\"); System.out.println(\"Adding sauce...\"); System.out.println(\"Adding toppings: \"); for (String topping : toppings) &#123; System.out.println(\" \" + topping); &#125; &#125; void bake() &#123; System.out.println(\"Bake for 25 minutes at 350\"); &#125; void cut() &#123; System.out.println(\"Cut the pizza into diagonal slices\"); &#125; void box() &#123; System.out.println(\"Place pizza in official PizzaStore box\"); &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; StringBuffer display = new StringBuffer(); display.append(\"---- \" + name + \" ----\\n\"); display.append(dough + \"\\n\"); display.append(sauce + \"\\n\"); for (String topping : toppings) &#123; display.append(topping + \"\\n\"); &#125; return display.toString(); &#125;&#125; 现在我们已经创建了披萨和商店的超类，接下来是他们的实现类 1234567891011121314151617package pizzafm;public class ChicagoStyleCheesePizza extends Pizza &#123; public ChicagoStyleCheesePizza() &#123; name = \"Chicago Style Deep Dish Cheese Pizza\"; dough = \"Extra Thick Crust Dough\"; sauce = \"Plum Tomato Sauce\"; toppings.add(\"Shredded Mozzarella Cheese\"); &#125; @Override void cut() &#123; System.out.println(\"Cutting the pizza into square slices\"); &#125;&#125; 1234567891011121314151617package pizzafm;public class ChicagoStyleClamPizza extends Pizza &#123; public ChicagoStyleClamPizza() &#123; name = \"Chicago Style Clam Pizza\"; dough = \"Extra Thick Crust Dough\"; sauce = \"Plum Tomato Sauce\"; toppings.add(\"Shredded Mozzarella Cheese\"); toppings.add(\"Frozen Clams from Chesapeake Bay\"); &#125; @Override void cut() &#123; System.out.println(\"Cutting the pizza into square slices\"); &#125;&#125; 1234567891011121314151617181920package pizzafm;public class ChicagoStylePepperoniPizza extends Pizza &#123; public ChicagoStylePepperoniPizza() &#123; name = \"Chicago Style Pepperoni Pizza\"; dough = \"Extra Thick Crust Dough\"; sauce = \"Plum Tomato Sauce\"; toppings.add(\"Shredded Mozzarella Cheese\"); toppings.add(\"Black Olives\"); toppings.add(\"Spinach\"); toppings.add(\"Eggplant\"); toppings.add(\"Sliced Pepperoni\"); &#125; @Override void cut() &#123; System.out.println(\"Cutting the pizza into square slices\"); &#125;&#125; 12345678910111213141516171819package pizzafm;public class ChicagoStyleVeggiePizza extends Pizza &#123; public ChicagoStyleVeggiePizza() &#123; name = \"Chicago Deep Dish Veggie Pizza\"; dough = \"Extra Thick Crust Dough\"; sauce = \"Plum Tomato Sauce\"; toppings.add(\"Shredded Mozzarella Cheese\"); toppings.add(\"Black Olives\"); toppings.add(\"Spinach\"); toppings.add(\"Eggplant\"); &#125; @Override void cut() &#123; System.out.println(\"Cutting the pizza into square slices\"); &#125;&#125; 123456789101112package pizzafm;public class NYStyleCheesePizza extends Pizza &#123; public NYStyleCheesePizza() &#123; name = \"NY Style Sauce and Cheese Pizza\"; dough = \"Thin Crust Dough\"; sauce = \"Marinara Sauce\"; toppings.add(\"Grated Reggiano Cheese\"); &#125;&#125; 12345678910111213package pizzafm;public class NYStyleClamPizza extends Pizza &#123; public NYStyleClamPizza() &#123; name = \"NY Style Clam Pizza\"; dough = \"Thin Crust Dough\"; sauce = \"Marinara Sauce\"; toppings.add(\"Grated Reggiano Cheese\"); toppings.add(\"Fresh Clams from Long Island Sound\"); &#125;&#125; 1234567891011121314151617package pizzafm;public class NYStylePepperoniPizza extends Pizza &#123; public NYStylePepperoniPizza() &#123; name = \"NY Style Pepperoni Pizza\"; dough = \"Thin Crust Dough\"; sauce = \"Marinara Sauce\"; toppings.add(\"Grated Reggiano Cheese\"); toppings.add(\"Sliced Pepperoni\"); toppings.add(\"Garlic\"); toppings.add(\"Onion\"); toppings.add(\"Mushrooms\"); toppings.add(\"Red Pepper\"); &#125;&#125; 12345678910111213141516package pizzafm;public class NYStyleVeggiePizza extends Pizza &#123; public NYStyleVeggiePizza() &#123; name = \"NY Style Veggie Pizza\"; dough = \"Thin Crust Dough\"; sauce = \"Marinara Sauce\"; toppings.add(\"Grated Reggiano Cheese\"); toppings.add(\"Garlic\"); toppings.add(\"Onion\"); toppings.add(\"Mushrooms\"); toppings.add(\"Red Pepper\"); &#125;&#125; 12345678910111213141516171819package pizzafm;public class ChicagoPizzaStore extends PizzaStore &#123; @Override Pizza createPizza(String item) &#123; if (item.equals(\"cheese\")) &#123; return new ChicagoStyleCheesePizza(); &#125; else if (item.equals(\"veggie\")) &#123; return new ChicagoStyleVeggiePizza(); &#125; else if (item.equals(\"clam\")) &#123; return new ChicagoStyleClamPizza(); &#125; else if (item.equals(\"pepperoni\")) &#123; return new ChicagoStylePepperoniPizza(); &#125; else &#123; return null; &#125; &#125;&#125; 12345678910111213141516171819package pizzafm;public class NYPizzaStore extends PizzaStore &#123; @Override Pizza createPizza(String item) &#123; if (item.equals(\"cheese\")) &#123; return new NYStyleCheesePizza(); &#125; else if (item.equals(\"veggie\")) &#123; return new NYStyleVeggiePizza(); &#125; else if (item.equals(\"clam\")) &#123; return new NYStyleClamPizza(); &#125; else if (item.equals(\"pepperoni\")) &#123; return new NYStylePepperoniPizza(); &#125; else &#123; return null; &#125; &#125;&#125; 最后创建测试类： 123456789101112131415161718192021222324252627282930313233package pizzafm;public class PizzaTestDrive &#123; public static void main(String[] args) &#123; PizzaStore nyStore = new NYPizzaStore(); PizzaStore chicagoStore = new ChicagoPizzaStore(); Pizza pizza = nyStore.orderPizza(\"cheese\"); System.out.println(\"Ethan ordered a \" + pizza.getName() + \"\\n\"); pizza = chicagoStore.orderPizza(\"cheese\"); System.out.println(\"Joel ordered a \" + pizza.getName() + \"\\n\"); pizza = nyStore.orderPizza(\"clam\"); System.out.println(\"Ethan ordered a \" + pizza.getName() + \"\\n\"); pizza = chicagoStore.orderPizza(\"clam\"); System.out.println(\"Joel ordered a \" + pizza.getName() + \"\\n\"); pizza = nyStore.orderPizza(\"pepperoni\"); System.out.println(\"Ethan ordered a \" + pizza.getName() + \"\\n\"); pizza = chicagoStore.orderPizza(\"pepperoni\"); System.out.println(\"Joel ordered a \" + pizza.getName() + \"\\n\"); pizza = nyStore.orderPizza(\"veggie\"); System.out.println(\"Ethan ordered a \" + pizza.getName() + \"\\n\"); pizza = chicagoStore.orderPizza(\"veggie\"); System.out.println(\"Joel ordered a \" + pizza.getName() + \"\\n\"); &#125;&#125; 抽象工厂在上述的例子中，比萨店的设计已经变得很棒：具有弹性的框架，而且遵循设计原则。现在，比萨店的成功关键在于新鲜高质量的原料。而且通过导入新的框架，加盟店将遵循你的流程，但是有一些加盟店使用低价的原料来增加利润。如何确保每家加盟店使用高质量的原料变成了一个问题。 为了解决原料的问题，我们要建一个工厂来生产原料，这个工厂负责创建原料家族中的每一种原料。我们需要做的事： 1.为工厂定义一个接口，这个接口负责创建所有的原料 2.为每个区域建造一个工厂。需要创建一个继承自PizzaIngredientFactory的子类来实现每一个创建方法 3.实现一组原料类供工厂使用，这些类可以在合适的区域间共享 4.然后最后将一切组织起来，将新的原料工厂整合进久得PizzaStore代码中 在创建披萨的时候通过工厂的形式来创建原材料 12PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory(); NYPizzaIngredientFactory是一个实现了PizzaIngredientFactory的类,其中函数返回的对象都是实现了对应接口的原材料。 1234567891011121314151617181920212223242526272829package pizzaaf;public class NYPizzaIngredientFactory implements PizzaIngredientFactory &#123; public Dough createDough() &#123; return new ThinCrustDough(); &#125; public Sauce createSauce() &#123; return new MarinaraSauce(); &#125; public Cheese createCheese() &#123; return new ReggianoCheese(); &#125; public Veggies[] createVeggies() &#123; Veggies veggies[] = &#123; new Garlic(), new Onion(), new Mushroom(), new RedPepper() &#125;; return veggies; &#125; public Pepperoni createPepperoni() &#123; return new SlicedPepperoni(); &#125; public Clams createClam() &#123; return new FreshClams(); &#125;&#125; 123456789101112package pizzaaf;public interface PizzaIngredientFactory &#123; public Dough createDough(); public Sauce createSauce(); public Cheese createCheese(); public Veggies[] createVeggies(); public Pepperoni createPepperoni(); public Clams createClam(); &#125; 完整代码请访问 https://github.com/caicaing/pizzaaf 一连串的代码的改变，我们到底做了什么？我们通过引入新类型的工厂，也就是所谓的抽象工厂，来创建披萨家族。通过抽象工厂所提供的接口，可以创建产品的家族，利用这个接口书写代码。我们的代码将从实际工厂解耦，以便于在不同上下文中实现各式各样的工厂，制造出各种不同的产品。因为代码从实际的产品中解耦了，所以我们可以替换不同的工厂来取得不同的行为。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://caicaing.github.io/tags/设计模式/"}]},{"title":"设计模式--观察者模式","slug":"设计模式-观察者模式","date":"2019-10-08T09:59:31.000Z","updated":"2019-10-08T11:26:19.958Z","comments":true,"path":"2019/10/08/设计模式-观察者模式/","link":"","permalink":"https://caicaing.github.io/2019/10/08/设计模式-观察者模式/","excerpt":"设计模式之观察者模式。","text":"设计模式之观察者模式。 观察者模式概念观察者模式（有时又被称为模型（Model）-视图（View）模式、源-收听者(Listener)模式或从属者模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。 优缺点观察者模式的主要的作用就是对对象解耦，将观察者和被观察者完全隔离。 1、观察者模式的优点 观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。 2、观察者模式的缺点 在应用观察者模式时需要考虑一下开发小路问题，程序中包括一个被观察者和多个被观察者，开发和调试比较复杂，而且Java中的消息的通知默认是顺序执行的，一个观察者的卡顿会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。 观察者模式应用引入一个很常见的案例。现在有一家气象站负责发布气象消息。客户希望气象站能够建立一个应用，有三种布告板，分别显示目前的状况，气象统计以及简单的预报。当获得最新的测量数据的时候，三种布告板必须实时更新。而且要求这是一个可以扩展的气象站，气象站需要公布一组API，好让其他开发人员可以写出自己的气象布告板并且插入此应用中。 此系统中的三个部分是气象站（获取实际气象数据的物理装置）、WeatherData对象（追踪来自气象站的数据，并更新布告板）和布告板（显示目前天气状况给用户看）。 如果了解报纸的订阅是怎么回事，其实就可以理解观察者模式是怎回事了，只是名称不太一样。对于报纸的订阅来说： 1、报社的业务就是出版报纸 2、向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的门户，你就会一直收到新报纸。 3、当你不再想看报纸的时候，取消订阅，他们就不会再送新报纸来。 4、只要报社还在运营，就会一直有人向他们订阅报纸或者取消订阅报纸。 接下来按照观察者模式的思路来实现气象站： 首先创建观察者和主题的接口和展示数据的接口 1234567public interface Observer &#123; /** * 更新数据 */ void update(float temp, float humidity, float pressure);&#125; 1234567891011121314151617181920public interface Subject &#123; /** * 注册一个观察者 */ void registerObserver(Observer observer); /** * 移除一个观察者 */ void removeObserver(Observer observer); /** * 更新后提醒 */ void notifyObservers();&#125; 123456public interface DisplayElement &#123; /** * 展示数据 */ public void display();&#125; 创建气象站类，并实现主题的接口： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.ArrayList;public class WeatherData implements Subject &#123; private float temperature; private float humidity; private float pressure; private ArrayList&lt;Observer&gt; observers; public WeatherData() &#123; observers = new ArrayList(); &#125; @Override public void registerObserver(Observer observer) &#123; observers.add(observer); &#125; @Override public void removeObserver(Observer observer) &#123; int i = observers.indexOf(observer); if (i &gt;= 0) &#123; observers.remove(observer); &#125; &#125; @Override public void notifyObservers() &#123; for (Observer observer : observers) &#123; observer.update(temperature, humidity, pressure); &#125; &#125; public void measurementsChanged() &#123; notifyObservers(); &#125; public void setMeasurements(float temperature, float humidety, float pressure)&#123; this.temperature = temperature; this.humidity = humidety; this.pressure = pressure; measurementsChanged(); &#125;&#125; 创建观察者类并实现接口： 123456789101112131415161718192021222324252627public class ConcreteObserver implements Observer ,DisplayElement&#123; private float tempreature; private float humidity; private float pressure; private Subject weatherData; public ConcreteObserver(Subject weatherData)&#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; @Override public void update(float tempreature, float humidity, float pressure) &#123; this.tempreature = tempreature; this.humidity = humidity; this.pressure = pressure; display(); &#125; @Override public void display() &#123; System.out.println(\"tempreature = \" + tempreature + \" humidity = \" + humidity + \" pressure =\" + pressure); &#125;&#125; 创建测试类： 123456789public class WeatherStation &#123; public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); ConcreteObserver concreteObserver = new ConcreteObserver(weatherData); weatherData.setMeasurements(50, 42, 30); &#125;&#125; Java内置的观察者模式在java.util包中，包含了最基本的Observer接口和Observable类，并且已经事先准备好了许多功能，你甚至可以用push或者pull的方式传送数据。 利用内置的观察者模式重做气象站： 12345678910111213141516171819202122232425262728293031323334353637383940package obser;import observe.DisplayElement;import java.util.Observable;import java.util.Observer;public class ConcreteObserver implements Observer, DisplayElement &#123; float tempreature; float humidity; float pressure; private Observable observable; public ConcreteObserver(Observable observable) &#123; this.observable = observable; observable.addObserver(this); &#125; @Override public void display() &#123; System.out.println(\"tempreature = \" + tempreature + \" humidity = \" + humidity + \" pressure =\" + pressure); &#125; @Override public void update(Observable observable, Object o) &#123; if (o instanceof WeatherData) &#123; WeatherData weatherData = (WeatherData) o; this.tempreature = weatherData.getTemperature(); this.humidity = weatherData.getHumidity(); this.pressure = weatherData.getPressure(); display(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package obser;import java.util.Observable;import java.util.Observer;public class WeatherData extends Observable &#123; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; &#125; public void measurementsChanged() &#123; setChanged(); notifyObservers(this); &#125; public void setMeasurements(float temperature, float humidety, float pressure) &#123; this.temperature = temperature; this.humidity = humidety; this.pressure = pressure; measurementsChanged(); &#125; public float getTemperature() &#123; return temperature; &#125; public float getHumidity() &#123; return humidity; &#125; public float getPressure() &#123; return pressure; &#125;&#125; 12345678package obser;public class Main &#123; public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); ConcreteObserver concreteObserver = new ConcreteObserver(weatherData); weatherData.setMeasurements(502, 42, 30); &#125;&#125; java.util.Observable的缺点Observable是一个类而不是一个接口，如果想使用Observable就必须继承他，如果某类想同时具有Observable的行为和另一个超类的行为就会陷入两难，因为java不支持多继承。这限制了Observable的复用潜力。 Observable将setChanged()方法定义为了protected，意味着除非继承Observable，否则无法创建Observable实例并组合到自己的对象中来。 总结观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都会收到通知并自动更新。观察者模式提供了一种对象设计，让主题和观察者之间松耦合，但是他们可以进行交互，只是双方不清楚彼此的细节。在任何时候我们都可以增加新的观察者，因为主题唯一的以来的东西是一个实现了观察者接口的对象列表，所以我们可以随时增加观察者。事实上，在运行时我们可以用新的观察者取代现有的观察者，主题不会受到任何影响。同样的也可以在任何时候删除某些观察者。松耦合的设计之所以让我们建立富有弹性的OO系统，能够应对变化是因为对象之间的互相依赖降到了最低。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://caicaing.github.io/tags/设计模式/"}]},{"title":"设计模式--策略模式","slug":"设计模式-策略模式","date":"2019-10-07T10:45:46.000Z","updated":"2019-10-07T11:59:22.712Z","comments":true,"path":"2019/10/07/设计模式-策略模式/","link":"","permalink":"https://caicaing.github.io/2019/10/07/设计模式-策略模式/","excerpt":"设计模式之策略模式。","text":"设计模式之策略模式。 策略模式概念策略模式的思想是针对一组算法，将每种算法都封装到具有共同接口的独立的类中，从而使他们可以互相替换。策略模式的最大特点是使算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。 特点策略模式体现了面向对象程序设计中的非常重要的两个原则： 1.封装变化的概念。 2.编程中使用接口，而不是使用的是具体的实现类（面向接口编程）。 策略模式的应用在正式应用策略模式之前，我们先讲一个小故事：现在小刘上班的公司做了一套相当成功的模拟鸭子游戏。游戏中会出现各种鸭子，一边游泳戏水，一边呱呱叫，此系统的内部设计使用了标准的OO技术，设计了一个鸭子的超类，并且让各种鸭子继承了此超类。去年公司的竞争压力加剧，在经过了为期一周的头脑风暴会议后，公司主管认为是该创新的时候了，他们需要展示一些让人真正印象深刻的东西来振奋人心。主管们决定此模拟程序需要会飞的鸭子来将竞争者抛在脑后。小刘的经理拍胸脯告诉主管们，小刘需要一个星期就能搞定。“毕竟，小刘是一个OO程序猿……这有什么困难？” 当需求传达给小刘的时候小刘心想：“既然所有的鸭子都继承自鸭子的超类，那么只需要在超类中加上fly()方法，那么所有的鸭子都会继承fly()，所有的鸭子都会飞了。”小刘迅速的修改了代码，果真所有的鸭子都能飞了。然而，问题出现了……在一次产品展示上，经理发现居然有很多“橡皮鸭子”在屏幕上飞来飞去。小刘在修改代码的时候忽略了一件事，不是所有的鸭子都会飞，小刘在超类中加了飞的行为会使一些不该有此行为的子类也拥有了此行为。对代码所作的局部修改，影响层面却不只是局部。他深刻体会到了一件事：当涉及“维护”时，为了“复用”而使用继承，结局并不完美。 小刘为了解决橡皮鸭子会飞的这个bug又想了新的办法：将橡皮鸭中的fly()方法覆盖掉，让其什么也不做。但是小刘又发愁：如果以后有新鸭子需要添加，他们可能有的只会叫不会飞，有的可能不会飞也不会叫，那么他都要去检查并且可能需要覆盖鸭子的行为，这简直是无穷无尽的噩梦。所以他需要一个更加清晰的方法，让某些鸭子类型可飞或者可叫。小刘心想他可以把fly()从超类中取出来做成一个接口，有鸭子会飞就实现这个接口，这样的话就实现了只有某些鸭子会飞。然而小刘的同事告诉他：“这个主意坏透了，你没发现这样重复的代码会变多吗？而且假如有50类鸭子都实现了这个接口，某天需要修改一下飞的行为，你又怎么说？”小刘听了陷入无尽的思考当中。 小刘的同事小杨看到小刘苦苦想不出答案决定帮帮他：“既然鸭子的飞和叫的行为会随着鸭子的不同而改变，为了能够把这两个行为从鸭子类中分开，为何不考虑将他们从鸭子类中取出来，建立一组新类来代表每个行为呢？飞行行为有很多，可能用翅膀飞，也可能飞不起来，也可能靠风吹着飞，完全可以将飞作为接口，上述这三种飞行方式为飞行接口的实现类，到时候只需要在鸭子类中声明接口并且赋予飞行方式就好了。”小刘听了小杨的话恍然大悟，原来这就是面向接口编程。小刘在跟小杨的讨论中确定了实现方式并且写出了如下代码： 123456/** * 飞行行为接口 */public interface FlyBehavior &#123; void fly();&#125; 123456789/** * 翅膀飞行实现类 */public class FlyWithWings implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(\"i'm flying!\"); &#125;&#125; 123456789/** * 不能飞行实现类 */public class FlyNoWay implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(\"i can't fly\"); &#125;&#125; 1234567891011121314151617181920/** * 鸭子超类 */public abstract class Duck &#123; FlyBehavior flyBehavior; public void swim() &#123; System.out.println(\"All dicks float, even decoys!\"); &#125; public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior; &#125; public abstract void display(); public void performFly() &#123; flyBehavior.fly(); &#125;&#125; 12345678910111213/** * 绿头鸭实现类 */public class MallardDuck extends Duck &#123; public MallardDuck()&#123; flyBehavior = new FlyWithWings(); &#125; @Override public void display() &#123; System.out.println(\"i'm a real mallard duck\"); &#125;&#125; 123456789public class Main &#123; public static void main(String[] args) &#123; Duck mallardDuck = new MallardDuck(); mallardDuck.display(); mallardDuck.performFly(); &#125;&#125; 小刘测试后发现果真使用面向接口编程可以有效地将代码解耦，而且在程序运行中可以方便的改变鸭子的飞行方式。假如有只绿头鸭不能飞了只需要 1mallardDuck.setFlyBehavior(new FlyNoWay()); 就可以将鸭子设置为不能飞的状态。 小刘经过此次经历获得了很多感悟： 在程序设计中，应当多用组合少用继承，使用组合建立系统具有很大的弹性。不仅可以将算法族封装成类，更可以在在运行时动态的改变行为，只要组合的行为对象符合正确的接口标准即可。例如鸭子模拟系统中，鸭子的行为不是继承来的，而是和适当的行为对象组合来的。当鸭子增加了新的飞行方式时，例如喷气火箭飞行只需要创建喷气火箭飞行类并且实现飞行的接口即可。不会对原有代码产生影响。 1234567public class FlyRocketPowered implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(\"i'm flying with a rocket!\"); &#125;&#125; 策略模式正式定义：策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://caicaing.github.io/tags/设计模式/"}]},{"title":"网络科学导论简记","slug":"网络科学导论","date":"2019-09-08T01:33:08.000Z","updated":"2019-09-08T14:06:33.000Z","comments":true,"path":"2019/09/08/网络科学导论/","link":"","permalink":"https://caicaing.github.io/2019/09/08/网络科学导论/","excerpt":"网络科学导论简记","text":"网络科学导论简记 \\ 网络基本拓扑性质鲁棒性​ 鲁棒是Robust的音译，也就是健壮和强壮的意思。它是在异常和危险情况下系统生存的关键。比如说，计算机软件在输入错误、磁盘故障、网络过载或有意攻击情况下，能否不死机、不崩溃，就是该软件的鲁棒性。所谓“鲁棒性”，是指控制系统在一定（结构，大小）的参数摄动下，维持其它某些性能的特性。根据对性能的不同定义，可分为稳定鲁棒性和性能鲁棒性。以闭环系统的鲁棒性作为目标设计得到的固定控制器称为鲁棒控制器。 无向网络中的巨片​ 网络平均距离和直径等概念严格来说只有对连通图才是有限值。经验和实证研究表明，许多实际的大规模复杂网络都是不连通的，但是往往会存在一个特别大的连通片，它包含了整个网络中的相当比例的节点，这一连通片成为巨片。 有向网络中的蝴蝶结结构​ 实际的大规模有向网络往往既不是强连通也不是弱连通的，但是许多有向网络往往有一个包含了网络中相当部分节点的很大弱连通片，成为弱连通巨片。这一若连通巨片又往往具有一种包含四个部分的蝴蝶结结构。 12345强连通核（SCC）：位于网络中心，其中的任意两个节点之间都是强连通的入部（IN）：包含可以从通过有向路径到达SCC但不能从SCC反向到达的节点出部（OUT）：包含可以从SCC通过有向路径到达但不能到达SCC的节点卷须（Tendrils）：包含既无法到达SCC也无法从SCC到达的节点管子（Tube）：可以从入部不经过SCC到达出部的节点 度与平均度​ 节点的度指与节点直接相连的边的数目，对于没有自环和重边的简单图，节点的度是与节点直接有边连接的其他节点的数目。度包括出度和入度。节点所有的度的平均值为网络的平均度 ​ 节点的强度是针对加权网络而言的。一个节点的强度为这个节点到其他节点的权值之和。 网络的稀疏性与稠密化​ 对于无向网络，密度的定义为网络中实际存在的边数M与最大可能的边数之比。对于无向网络： 对于有向网络，上式分母中的1/2去掉即可。当N趋于正无穷时，若网络密度趋于非零常数，那就可以认为网络时稠密的。若网络密度趋于0那么网络就是稀疏的。 平均路径长度​ 网络中两个节点i和j之间的最短路径也成为测地路径，是指连接这两个节点的边数最少的路径。距离定义为连接两个节点的最短路径的边的数目。网络的平均路径长度定义为任意两个节点之间的距离的平均值。 Dijkstra算法实现聚类系数​ 聚类系数为节点与其临节点之间实际存在的边数与最多可存在的边数的比值。聚类系数是0到1之间的一个数，越趋近于1表示网络更加紧密。","categories":[],"tags":[{"name":"网络科学导论","slug":"网络科学导论","permalink":"https://caicaing.github.io/tags/网络科学导论/"}]},{"title":"spring boot邮件发送和定时任务","slug":"spring-boot邮件发送","date":"2019-09-03T11:34:10.000Z","updated":"2019-09-04T02:15:27.000Z","comments":true,"path":"2019/09/03/spring-boot邮件发送/","link":"","permalink":"https://caicaing.github.io/2019/09/03/spring-boot邮件发送/","excerpt":"使用SpringBoot整合Mail发送邮件和定时任务,自用","text":"使用SpringBoot整合Mail发送邮件和定时任务,自用 \\ pom.xml: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springboot-task&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-task&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.properties: 123456spring.mail.host=smtp.qq.comspring.mail.username=5426482@qq.comspring.mail.password=bphrczxkemzubibfspring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=true SpringbootTaskApplication 1package com.example.springboottask;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableAsync;import org.springframework.scheduling.annotation.EnableScheduling;@EnableScheduling@EnableAsync@SpringBootApplicationpublic class SpringbootTaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootTaskApplication.class, args); &#125;&#125; ScheduledService 1package com.example.springboottask.service;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Service;@Servicepublic class ScheduledService &#123; @Scheduled(cron = \"0 * * * * MON-FRI\") public void hello()&#123; System.out.println(\"hello\"); &#125;&#125; AsyncService 1package com.example.springboottask.service;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;@Servicepublic class AsyncService &#123; @Async public void hello()&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"处理数据中\"); &#125;&#125; AsynController 1package com.example.springboottask.controller;import com.example.springboottask.service.AsyncService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AsyncController &#123; @Autowired AsyncService asyncService; @GetMapping(\"/hello\") public String hello() &#123; asyncService.hello(); return \"success\"; &#125;&#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"}]},{"title":"python list.append方法数据覆盖","slug":"python-list-append方法数据覆盖","date":"2019-09-01T01:27:12.000Z","updated":"2019-09-01T01:42:15.000Z","comments":true,"path":"2019/09/01/python-list-append方法数据覆盖/","link":"","permalink":"https://caicaing.github.io/2019/09/01/python-list-append方法数据覆盖/","excerpt":"python循环中添加list数据覆盖问题。","text":"python循环中添加list数据覆盖问题。 测试代码如下: 12345678910111213def test(): for i in range(5): a.append(i) b.append(a) print(b)if __name__ == '__main__': global a global b a = list() b = list() test() 运行结果: 1[[0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4]] 然而此函数预期的结果应该为: 1[[0], [0, 1], [0, 1, 2], [0, 1, 2, 3], [0, 1, 2, 3, 4]] 这是因为当向listb中添加lista时添加的相当于a的地址,当在循环中修改了lista的数据时候,由于listb中所有的指向都为lista所以所有的数据都会随之改变。若想在listb中展示预期数据，应当新建一个list再将其添加到listb中，此处使用python自带的深拷贝函数进行拷贝原来的a。代码如下： 123456789101112131415import copydef test(): for i in range(5): a.append(i) c = copy.deepcopy(a) b.append(c) print(b)if __name__ == '__main__': global a global b a = list() b = list() test()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://caicaing.github.io/tags/python/"}]},{"title":"docker安装mysql","slug":"docker安装mysql","date":"2019-07-15T00:27:24.000Z","updated":"2019-07-15T01:09:14.000Z","comments":true,"path":"2019/07/15/docker安装mysql/","link":"","permalink":"https://caicaing.github.io/2019/07/15/docker安装mysql/","excerpt":"使用使用docker 安装mysql,并且进行远程访问连接","text":"使用使用docker 安装mysql,并且进行远程访问连接 实验环境 centos7.3 docker mysql-8.0.16.0 实验步骤升级yum1yum update -y 安装docker1yum install docker -y 启动docker12systemctl start docker # 启动systemctl enable docker # 设置开机启动 查找mysql镜像1docker search mysql 拉取mysql镜像1docker pull mysql #默认为下载最新版 查看mysql镜像1docker images 启动mysql1docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql （参数 -p 设置端口，–name 取名 ，-e MYSQL_ROOT_PASSWORD=123456 设置 账号为 root ，密码为 123456 -d 表示作为一个守护进程在后台运行 ） 查看运行中的容器1docker ps 远程连接mysql及错误解决在上文中,我们已经创建了一个mysql容器,在连接过程中使用navicat报错错误信息如下: 为了对mysql进行操作首先要进入docker中的mysql 1docker exec -it mysql bash 登录mysql 1mysql -u root -p 执行sql语句 12ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '你的密码';ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码'; 执行后再次连接,连接成功","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://caicaing.github.io/tags/docker/"},{"name":"mysql","slug":"mysql","permalink":"https://caicaing.github.io/tags/mysql/"}]},{"title":"SpringBoot+ajax跨域请求","slug":"SpringBoot-ajax跨域请求","date":"2019-07-11T10:29:07.000Z","updated":"2019-07-12T02:47:17.000Z","comments":true,"path":"2019/07/11/SpringBoot-ajax跨域请求/","link":"","permalink":"https://caicaing.github.io/2019/07/11/SpringBoot-ajax跨域请求/","excerpt":"在使用ajax请求SpringBoot + SpringSecurity后端时遇到的一些坑。","text":"在使用ajax请求SpringBoot + SpringSecurity后端时遇到的一些坑。 不集成SpringSecurity的情况下进行跨域访问错误信息在使用ajax请求后端的时候在浏览器控制台会输出如下信息： 1Access to XMLHttpRequest at 'http://localhost:8080/test' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 从源’本地路径’访问 ‘目标路径(请求链接)’文本传输请求已被CORS策略阻塞:对预置请求的响应未通过访问控制检查:请求的资源上不存在’Access- control - allow - origin ‘报头。 错误原因本地路径和目标路径不是同一个域名下引起的跨域问题 解决方案在对应的Controller类前上@CrossOrigin注解 例如： 1234567891011121314151617181920212223242526272829package com.example.demo.controller;import org.springframework.web.bind.annotation.CrossOrigin;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;/** * @program: demo * @description: * @author: liu * @create: 2019-07-11 18:14 **/@RestController@CrossOriginpublic class TestController &#123; @PostMapping(\"/testPost\") public String testPost() &#123; System.out.println(\"testPost成功\"); return \"testPost跨域请求成功\"; &#125; @GetMapping(\"/testGet\") public String testGet() &#123; System.out.println(\"testGet成功\"); return \"testGet跨域请求成功\"; &#125;&#125; 集成SpringSecurity的情况下进行跨域访问错误信息集成SpringSecurity后get请求正常，但是对于post请求仍然会显示错误信息 12jquery.min.js:4 POST http://localhost:8080/testPost 403list_student.html:1 Access to XMLHttpRequest at 'http://localhost:8080/testPost' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 解决方案添加WebSecurityConfiguration配置文件可关闭csrf 1234567891011121314151617181920212223242526272829303132package com.example.demo;import org.springframework.context.annotation.Configuration;import org.springframework.core.annotation.Order;import org.springframework.http.HttpMethod;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)@Order(-1)public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123;// http.requestMatchers().antMatchers(HttpMethod.OPTIONS, \"/oauth/**\",\"/login/**\",\"/logout/**\")// .and()// .authorizeRequests()// .antMatchers().permitAll()// .and()// .formLogin().permitAll(); //新增login form 支持用户登录及授权 http.requestMatchers().antMatchers(HttpMethod.OPTIONS, \"/oauth/**\") .and() .cors() .and() .csrf().disable(); &#125;&#125;","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caicaing.github.io/tags/SpringBoot/"},{"name":"ajax","slug":"ajax","permalink":"https://caicaing.github.io/tags/ajax/"}]},{"title":"SpringBoot整合Activiti7使用","slug":"SpringBoot整合Activiti7使用","date":"2019-07-10T02:42:22.000Z","updated":"2019-07-10T06:05:45.000Z","comments":true,"path":"2019/07/10/SpringBoot整合Activiti7使用/","link":"","permalink":"https://caicaing.github.io/2019/07/10/SpringBoot整合Activiti7使用/","excerpt":"最近做的一个项目中需要实现员工请假的功能，计划使用activiti来实现请假流程，所以去学习了一下相关的知识。并且完成了一个简单的请假实例。","text":"最近做的一个项目中需要实现员工请假的功能，计划使用activiti来实现请假流程，所以去学习了一下相关的知识。并且完成了一个简单的请假实例。 Activiti相关Activiti介绍Activiti是基于Apache许可的开源BPM平台，创始人Tom Baeyens原是JBPM架构师，可以理解为与JBPM出自同一祖师爷。它提供了Eclipse插件，开发可以通过插件直接绘制业务流程图。基于Spring，ibatis等框架，并在此之上构建了非常清晰的开发框架。是由Alfresco软件发布的业务流程管理（BPM）框架，它是覆盖了业务流程管理、工作流、服务协作等领域的一个开源的、灵活的、易扩展的可执行流程语言框架。 本文基于Activiti7的Activiti Core，基于Spring Boot做简单学习总结。 Acticiti核心类介绍ProcessEngine流程引擎的抽象，可以通过此类获取需要的所有服务。 Service类 通过ProcessEngine获取，Activiti将不同生命周期的服务封装在不同Service中，包括定义、部署、运行。通过服务类可获取相关生命周期中的服务信息。 taskService流程运行过程中，每个任务节点的相关操作接口，如complete,delete,delegate等。 RepositoryService流程定义和部署相关的存储服务 RuntimeService流程运行时相关的服务，如根据流程好启动流程实例startProcessInstanceByKey。 HistoryService历史记录相关服务接口。 项目搭建创建SpringBoot项目并且添加maven依赖pom.xml: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 添加配置文件application.yml： 12345678910111213141516spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/test2?nullCatalogMeansCurrent=true driver-class-name: com.mysql.cj.jdbc.Driver devtools: restart: enabled: true #设置开启热部署 activiti: database-schema-update: true history-level: full db-history-used: truedebug: true 创建流程图在创建流程图之前首先需要安装idea支持bpm文件的插件 安装成功后在resources目录下创建processes文件夹并新建holiday.bpmn文件并且创建流程 对应xml文件代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt;&lt;definitions xmlns=\"http://www.omg.org/spec/BPMN/20100524/MODEL\" xmlns:activiti=\"http://activiti.org/bpmn\" xmlns:bpmndi=\"http://www.omg.org/spec/BPMN/20100524/DI\" xmlns:omgdc=\"http://www.omg.org/spec/DD/20100524/DC\" xmlns:omgdi=\"http://www.omg.org/spec/DD/20100524/DI\" xmlns:tns=\"http://www.activiti.org/test\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" expressionLanguage=\"http://www.w3.org/1999/XPath\" id=\"m1562573992349\" name=\"\" targetNamespace=\"http://www.activiti.org/test\" typeLanguage=\"http://www.w3.org/2001/XMLSchema\"&gt; &lt;process id=\"myProcess_1\" isClosed=\"false\" isExecutable=\"true\" processType=\"None\"&gt; &lt;startEvent id=\"_2\" name=\"StartEvent\"/&gt; &lt;userTask activiti:assignee=\"$&#123;userId&#125;\" activiti:exclusive=\"false\" id=\"_3\" name=\"填写申请单\"/&gt; &lt;userTask activiti:assignee=\"department\" activiti:exclusive=\"true\" id=\"_4\" name=\"审核\"/&gt; &lt;endEvent id=\"_6\" name=\"EndEvent\"/&gt; &lt;sequenceFlow id=\"_7\" sourceRef=\"_2\" targetRef=\"_3\"/&gt; &lt;sequenceFlow id=\"_8\" sourceRef=\"_3\" targetRef=\"_4\"/&gt; &lt;sequenceFlow id=\"_11\" sourceRef=\"_4\" targetRef=\"_6\"/&gt; &lt;/process&gt; &lt;bpmndi:BPMNDiagram documentation=\"background=#3C3F41;count=1;horizontalcount=1;orientation=0;width=842.4;height=1195.2;imageableWidth=832.4;imageableHeight=1185.2;imageableX=5.0;imageableY=5.0\" id=\"Diagram-_1\" name=\"New Diagram\"&gt; &lt;bpmndi:BPMNPlane bpmnElement=\"myProcess_1\"&gt; &lt;bpmndi:BPMNShape bpmnElement=\"_2\" id=\"Shape-_2\"&gt; &lt;omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"225.0\" y=\"175.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=\"_3\" id=\"Shape-_3\"&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"85.0\" x=\"435.0\" y=\"175.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"85.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=\"_4\" id=\"Shape-_4\"&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"85.0\" x=\"655.0\" y=\"175.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"55.0\" width=\"85.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=\"_6\" id=\"Shape-_6\"&gt; &lt;omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"875.0\" y=\"185.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNEdge bpmnElement=\"_7\" id=\"BPMNEdge__7\" sourceElement=\"_2\" targetElement=\"_3\"&gt; &lt;omgdi:waypoint x=\"257.0\" y=\"191.0\"/&gt; &lt;omgdi:waypoint x=\"435.0\" y=\"202.5\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"0.0\" width=\"0.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=\"_8\" id=\"BPMNEdge__8\" sourceElement=\"_3\" targetElement=\"_4\"&gt; &lt;omgdi:waypoint x=\"520.0\" y=\"202.5\"/&gt; &lt;omgdi:waypoint x=\"655.0\" y=\"202.5\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"0.0\" width=\"0.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=\"_11\" id=\"BPMNEdge__11\" sourceElement=\"_4\" targetElement=\"_6\"&gt; &lt;omgdi:waypoint x=\"740.0\" y=\"202.5\"/&gt; &lt;omgdi:waypoint x=\"875.0\" y=\"201.0\"/&gt; &lt;bpmndi:BPMNLabel&gt; &lt;omgdc:Bounds height=\"0.0\" width=\"0.0\" x=\"0.0\" y=\"0.0\"/&gt; &lt;/bpmndi:BPMNLabel&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;/bpmndi:BPMNPlane&gt; &lt;/bpmndi:BPMNDiagram&gt;&lt;/definitions&gt; 运行Application启动后查看数据库发现springboot 自动读取了processes下的holiday.bpmn文件并且部署任务流程到activiti。数据库中生成了25张工作表。 并且在ACT_GE_BYTEARRAY表中也存在部署的信息 编写实例开启请假流程12345678910111213@Testpublic void start() &#123; String instanceKey = \"myProcess_1\"; logger.info(\"开启请假流程...\"); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); //在holiday.bpmn中,填写请假单的任务办理人为动态传入的userId,此处模拟一个id map.put(\"userId\", \"10001\"); ProcessInstance instance = runtimeService.startProcessInstanceByKey(instanceKey, map); logger.info(\"启动流程实例成功:&#123;&#125;\", instance); logger.info(\"流程实例ID:&#123;&#125;\", instance.getId()); logger.info(\"流程定义ID:&#123;&#125;\", instance.getProcessDefinitionId());&#125; 运行结果： 运行后成功开启了一个请假实例并且获取到id为：adc6a5f0-a2c3-11e9-bb83-00e04c83a7ff。 填写请假单通过实例id可以查询到实例所对应的任务，模拟用户请假的内容存入map中添加为流程变量。 12345678910111213141516@Testpublic void employeeApply() &#123; String instanceId = \"adc6a5f0-a2c3-11e9-bb83-00e04c83a7ff\"; // 任务ID String leaveDays = \"10\"; // 请假天数 String leaveReason = \"回老家结婚\"; // 请假原因 Task task = taskService.createTaskQuery().processInstanceId(instanceId).singleResult(); if (task == null) &#123; logger.info(\"任务ID:&#123;&#125;查询到任务为空！\", instanceId); &#125; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"days\", leaveDays); map.put(\"date\", new Date()); map.put(\"reason\", leaveReason); taskService.complete(task.getId(), map); logger.info(\"执行【员工申请】环节，流程推动到【上级审核】环节\");&#125; 运行结果如下： 流程变量查看上级审核的时候需要查看到员工所提交的请假相关信息，可以通过taskService.getVariable的形式来获取。 1234567891011121314@Testpublic void showTaskVariable ()&#123; String instanceId = \"adc6a5f0-a2c3-11e9-bb83-00e04c83a7ff\"; // 任务ID Task task = taskService.createTaskQuery().processInstanceId(instanceId).singleResult(); String days = (String) taskService.getVariable(task.getId(), \"days\"); Date date = (Date) taskService.getVariable(task.getId(), \"date\"); String reason = (String) taskService.getVariable(task.getId(), \"reason\"); String userId = (String) taskService.getVariable(task.getId(), \"userId\"); System.out.println(\"请假天数: \" + days); System.out.println(\"请假理由: \" + reason); System.out.println(\"请假人id: \" + userId); System.out.println(\"请假日期: \" + date.toString());&#125; 运行结果： 上级审批上级审批并且添加意见 12345678910@Testpublic void departmentAudit() &#123; String instanceId = \"adc6a5f0-a2c3-11e9-bb83-00e04c83a7ff\"; // 任务ID String departmentalOpinion = \"早去早回\"; Task task = taskService.createTaskQuery().processInstanceId(instanceId).singleResult(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"departmentalOpinion\", departmentalOpinion); taskService.complete(task.getId(), map); logger.info(\"添加审批意见,请假流程结束\");&#125; 运行结果： 总结使用Activiti可以方便对流程进行控制。本文只是对简单的请假流程做了实例，没有涉及到多任务或多分支等情景。对于此类情况以后再做补充。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caicaing.github.io/tags/SpringBoot/"},{"name":"Activiti7","slug":"Activiti7","permalink":"https://caicaing.github.io/tags/Activiti7/"}]},{"title":"Thumbnailator图片处理","slug":"Thumbnailator图片处理","date":"2019-06-18T00:22:26.000Z","updated":"2019-06-18T01:19:46.000Z","comments":true,"path":"2019/06/18/Thumbnailator图片处理/","link":"","permalink":"https://caicaing.github.io/2019/06/18/Thumbnailator图片处理/","excerpt":"Thumbnailator 是一个优秀的图片处理的Google开源Java类库。处理效果远比Java API的好。从API提供现有的图像文件和图像对象的类中简化了处理过程，两三行代码就能够从现有图片生成处理后的图片，且允许微调图片的生成方式，同时保持了需要写入的最低限度的代码量。还支持对一个目录的所有图片进行批量处理操作。 支持的处理操作：图片缩放，区域裁剪，水印，旋转，保持比例。","text":"Thumbnailator 是一个优秀的图片处理的Google开源Java类库。处理效果远比Java API的好。从API提供现有的图像文件和图像对象的类中简化了处理过程，两三行代码就能够从现有图片生成处理后的图片，且允许微调图片的生成方式，同时保持了需要写入的最低限度的代码量。还支持对一个目录的所有图片进行批量处理操作。 支持的处理操作：图片缩放，区域裁剪，水印，旋转，保持比例。 导入依赖123456&lt;!-- https://mvnrepository.com/artifact/net.coobird/thumbnailator --&gt;&lt;dependency&gt; &lt;groupId&gt;net.coobird&lt;/groupId&gt; &lt;artifactId&gt;thumbnailator&lt;/artifactId&gt; &lt;version&gt;0.4.8&lt;/version&gt;&lt;/dependency&gt; 函数示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495从图像文件创建缩略图Thumbnails.of(new File(\"original.jpg\")) .size(160, 160) .toFile(new File(\"thumbnail.jpg\"));在此示例中，图像来自original.jpg调整大小，然后保存到thumbnail.jpg。或者，Thumbnailator将接受文件名作为String。File不需要使用对象指定图像文件：Thumbnails.of(\"original.jpg\") .size(160, 160) .toFile(\"thumbnail.jpg\");在编写快速原型代码或从脚本语言中使用Thumbnailator时，此表单非常有用。使用旋转和水印创建缩略图Thumbnails.of(new File(\"original.jpg\")) .size(160, 160) .rotate(90) .watermark(Positions.BOTTOM_RIGHT, ImageIO.read(new File(\"watermark.png\")), 0.5f) .outputQuality(0.8) .toFile(new File(\"image-with-watermark.jpg\"));在此示例中，original.jpg调整图像大小，然后顺时针旋转90度，然后在右下角放置一个半透明水印，然后image-with-watermark.jpg以80％压缩质量设置保存。创建缩略图并写入 OutputStreamOutputStream os = ...; Thumbnails.of(\"large-picture.jpg\") .size(200, 200) .outputFormat(\"png\") .toOutputStream(os);在此示例中，将文件中的图像large-picture.jpg调整为最大尺寸200 x 200（保持原始图像的纵横比），并将其写入指定OutputStream的PNG图像。创建固定大小的缩略图BufferedImage originalImage = ImageIO.read(new File(\"original.png\"));BufferedImage thumbnail = Thumbnails.of(originalImage) .size(200, 200) .asBufferedImage();上面的代码采用图像originalImage并创建一个200像素乘200像素的缩略图，并使用并存储结果thumbnail。按给定因子缩放图像BufferedImage originalImage = ImageIO.read(new File(\"original.png\"));BufferedImage thumbnail = Thumbnails.of(originalImage) .scale(0.25) .asBufferedImage();上面的代码将图像originalImage带入并创建一个缩略图，该缩略图是原始图像的25％，并使用默认缩放技术来制作存储在其中的缩略图thumbnail。创建缩略图时旋转图像BufferedImage originalImage = ImageIO.read(new File(\"original.jpg\"));BufferedImage thumbnail = Thumbnails.of(originalImage) .size(200, 200) .rotate(90) .asBufferedImage();上面的代码采用原始图像并创建一个顺时针旋转90度的缩略图。使用水印创建缩略图BufferedImage originalImage = ImageIO.read(new File(\"original.jpg\"));BufferedImage watermarkImage = ImageIO.read(new File(\"watermark.png\"));BufferedImage thumbnail = Thumbnails.of(originalImage) .size(200, 200) .watermark(Positions.BOTTOM_RIGHT, watermarkImage, 0.5f) .asBufferedImage();如图所示，可以通过调用该watermark方法将水印添加到缩略图。可以从Positions枚举中选择定位。缩略图的不透明度（或相反地，透明度）可以通过改变最后一个参数来调整，其中0.0f缩略图是完全透明的，并且1.0f水印是完全不透明的。将缩略图写入特定目录File destinationDir = new File(\"path/to/output\");Thumbnails.of(\"apple.jpg\", \"banana.jpg\", \"cherry.jpg\") .size(200, 200) .toFiles(destinationDir, Rename.PREFIX_DOT_THUMBNAIL);此示例将获取源图像，并将缩略图作为文件写入destinationDir（path/to/output目录），同时thumbnail.在文件名前添加重命名。因此，缩略图将被写为以下文件：path/to/output/thumbnail.apple.jpgpath/to/output/thumbnail.banana.jpgpath/to/output/thumbnail.cherry.jpg写入指定目录时，也可以保留原始文件名：File destinationDir = new File(\"path/to/output\");Thumbnails.of(\"apple.jpg\", \"banana.jpg\", \"cherry.jpg\") .size(200, 200) .toFiles(destinationDir, Rename.NO_CHANGE);在上面的代码中，缩略图将写入：path/to/output/apple.jpgpath/to/output/banana.jpgpath/to/output/cherry.jpg","categories":[],"tags":[{"name":"Thumbnailator","slug":"Thumbnailator","permalink":"https://caicaing.github.io/tags/Thumbnailator/"}]},{"title":"lucene全文检索操作实例","slug":"lucene操作实例","date":"2019-06-03T15:00:01.000Z","updated":"2019-06-03T15:44:24.000Z","comments":true,"path":"2019/06/03/lucene操作实例/","link":"","permalink":"https://caicaing.github.io/2019/06/03/lucene操作实例/","excerpt":"Lucene是apache下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。","text":"Lucene是apache下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。 全文检索将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。 例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。 这种先建立索引，再对索引进行搜索的过程就叫全文检索**(Full-text Search)**。 虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。对于数据量大、数据结构不固定的数据可采用全文检索方式搜索，比如百度、Google等搜索引擎、论坛站内搜索、电商网站站内搜索等。 Tip:lucene对java环境的最低要求为JAVA1.8 创建索引第一步：创建一个java工程，并导入jar包。 工程所需jar包: 第二步：创建一个indexwriter对象。 1）指定索引库的存放位置Directory对象 2）指定一个IndexWriterConfig对象。 第二步：创建document对象。 第三步：创建field对象，将field添加到document对象中。 第四步：使用indexwriter对象将document对象写入索引库，此过程进行索引创建。并将索引和document对象写入索引库。 第五步：关闭IndexWriter对象。 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839@Test public void createIndex() throws Exception &#123; //创建一个Director对象,指定索引库保存的位置 Directory directory = FSDirectory.open(new File(\"c:\\\\temp\\\\index\").toPath()); //基于directory对象创建一个IndexWriter对象 IndexWriter indexWriter = new IndexWriter(directory, new IndexWriterConfig()); //读取磁盘上的文件 File dir = new File(\"C:\\\\Users\\\\liu\\\\Desktop\\\\searchsource\"); //原始文档的路径 File[] files = dir.listFiles(); for (File f : files) &#123; String name = f.getName(); String filePath = f.getPath(); String fileContent = FileUtils.readFileToString(f, \"utf-8\"); long fileSize = FileUtils.sizeOf(f); //创建Field //第一个参数：域的名称 //第二个参数：域的内容 //第三个参数：是否存储 Field fieldName = new TextField(\"name\", name, Field.Store.YES); //文件路径域（不分析、不索引、只存储） Field fieldPath = new TextField(\"path\", filePath, Field.Store.YES); //文件内容域 Field fieldContent = new TextField(\"content\", fileContent, Field.Store.YES); //文件大小域 Field fieldSize = new TextField(\"size\", fileSize + \"\", Field.Store.YES); //创建文档对象 Document document = new Document(); document.add(fieldName); document.add(fieldPath); document.add(fieldContent); document.add(fieldSize); //把文档对象写入索引库 indexWriter.addDocument(document); &#125; //关闭indexwriter indexWriter.close(); &#125; createIndex方法运行后会在c:\\\\temp\\\\index文件夹下生成索引文件,如下图: 生成的索引文件为二进制文件,可以使用luke打开索引 查看索引luck开始界面如下,在indexPath中选择索引存储位置文件夹即可 查询索引第一步：创建一个Directory对象，也就是索引库存放的位置。 第二步：创建一个indexReader对象，需要指定Directory对象。 第三步：创建一个indexsearcher对象，需要指定IndexReader对象 第四步：创建一个TermQuery对象，指定查询的域和查询的关键词。 第五步：执行查询。 第六步：返回查询结果。遍历查询结果并输出。 第七步：关闭IndexReader对象 代码如下: 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void searchIndex() throws Exception &#123; //指定索引库存放的路径 Directory directory = FSDirectory.open(new File(\"c:\\\\temp\\\\index\").toPath()); //创建indexReader对象 IndexReader indexReader = DirectoryReader.open(directory); //创建indexsearcher对象 IndexSearcher indexSearcher = new IndexSearcher(indexReader); //创建查询 Query query = new TermQuery(new Term(\"content\", \"spring\")); //执行查询 //第一个参数是查询对象，第二个参数是查询结果返回的最大值 TopDocs topDocs = indexSearcher.search(query, 10); //查询结果的总条数 System.out.println(\"查询总记录数:\" + topDocs.totalHits); //遍历查询结果 //topDocs.scoreDocs存储了document对象的id ScoreDoc[] scoreDocs = topDocs.scoreDocs; for (ScoreDoc doc : scoreDocs) &#123; //scoreDoc.doc属性就是document对象的id //根据document的id找到document对象 int docId = doc.doc; Document document = indexSearcher.doc(docId); System.out.println(document.get(\"name\")); System.out.println(document.get(\"path\")); System.out.println(document.get(\"size\")); System.out.println(document.get(\"content\")); System.out.println(\"--------------------------\"); &#125; //关闭indexreader对象 indexReader.close();&#125; 部分查询结果如下图:","categories":[],"tags":[{"name":"lucene","slug":"lucene","permalink":"https://caicaing.github.io/tags/lucene/"}]},{"title":"centos7.3搭建gogs","slug":"centos7-3搭建gogs","date":"2019-05-31T06:14:14.000Z","updated":"2019-05-31T07:34:26.000Z","comments":true,"path":"2019/05/31/centos7-3搭建gogs/","link":"","permalink":"https://caicaing.github.io/2019/05/31/centos7-3搭建gogs/","excerpt":"Gogs 是一款类似GitHub的开源文件/代码管理系统（基于Git），Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。使用 Go 语言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 所有平台，包括 Linux、Mac OS X、Windows 以及 ARM 平台。","text":"Gogs 是一款类似GitHub的开源文件/代码管理系统（基于Git），Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。使用 Go 语言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 所有平台，包括 Linux、Mac OS X、Windows 以及 ARM 平台。 安装docker升级centos内核到最新版本在安装响应包之前先将centos的系统版本和内核升级,防止出现docker启动gogs时候报错 1yum -y update 安装docker123456# 通过yum源安装dockeryum -y install docker# 启动dockersystemctl start docker# 设置开机自启sudo systemctl enable docker 下载gogs镜像1docker pull gogs/gogs 创建gogs存储目录1mkdir -p /var/gogs 运行镜像,产生容器1docker run --name=gogs -p 10022:22 -p 10080:3000 -v /var/gogs:/data gogs/gogs 运行并配置配置gogs 配置完成后点击立即安装开始安装 创建仓库注册登录后,在控制面版中可以看到我的仓库,点击 ‘+’ 可以创建新的仓库: 创建仓库的时候可以选择使用选定的文件和模板初始化仓库,如果不勾选初始化则创建一个空的仓库. 克隆仓库打开想要克隆的仓库,复制http url连接,在想要克隆的目录下使用git clone url 即可 提交本地仓库如下图所示,在克隆下来的仓库中添加了一张图片,现在要想整个本地仓库再上传到gogs中 使用如下命令: 123456#添加所有文件git add -A #提交到本地仓库git commit -m \"first commit\"#提交到gogs仓库git push","categories":[],"tags":[{"name":"gogs","slug":"gogs","permalink":"https://caicaing.github.io/tags/gogs/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2019-05-24T23:42:52.000Z","updated":"2019-05-25T00:09:19.000Z","comments":true,"path":"2019/05/25/git常用命令/","link":"","permalink":"https://caicaing.github.io/2019/05/25/git常用命令/","excerpt":"git常用命令","text":"git常用命令 git init ​ 在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹. git clone ​ 获取一个url对应的远程Git repo, 创建一个local copy. ​ 一般的格式是git clone [url]. ​ clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定. git status ​ 查询repo的状态. ​ git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言. git log ​ show commit history of a branch. ​ git log –oneline –number: 每条log只显示一行,显示number条. ​ git log –oneline –graph:可以图形化地表示出分支合并历史. ​ git log branchname可以显示特定分支的log. ​ git log –oneline branch1 ^branch2,可以查看在分支1,却不在分支2中的提交.^表示排除这个分支(Window下可能要给^branch2加上引号). ​ git log –decorate会显示出tag信息. ​ git log –author=[author name] 可以指定作者的提交历史. ​ git log –since –before –until –after 根据提交时间筛选log. ​ –no-merges可以将merge的commits排除在外. ​ git log –grep 根据commit信息过滤log: git log –grep=keywords ​ 默认情况下, git log –grep –author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上–all-match的option. ​ git log -S: filter by introduced diff. ​ 比如: git log -SmethodName (注意S和后面的词之间没有等号分隔). ​ git log -p: show patch introduced at each commit. ​ 每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看. ​ 另一种方法是git show [SHA]. ​ git log –stat: show diffstat of changes introduced at each commit. ​ 同样是用来看改动的相对信息的,–stat比-p的输出更简单一些. ​ git add ​ 在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动. ​ git add . ​ 会递归地添加当前工作目录中的所有文件. git diff ​ 不加参数的git diff: ​ show diff of unstaged changes. ​ 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容. ​ 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用: ​ git diff –cached 命令. ​ show diff of staged changes. ​ (Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的). ​ git diff HEAD ​ show diff of all staged or unstated changes. ​ 也即比较woking directory和上次提交之间所有的改动. ​ 如果想看自从某个版本之后都改动了什么,可以用: ​ git diff [version tag] ​ 跟log命令一样,diff也可以加上–stat参数来简化输出. ​ git diff [branchA] [branchB]可以用来比较两个分支. ​ 它实际上会返回一个由A到B的patch,不是我们想要的结果. ​ 一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令: ​ git diff [branchA]…[branchB]给出的. ​ 实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果. git commit ​ 提交已经被add进来的改动. ​ git commit -m “the commit message” ​ git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下. ​ git commit –amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消. git reset ​ undo changes and commits. ​ 这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本. ​ git reset HEAD: unstage files from index and reset pointer to HEAD ​ 这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD - - filename, 这个- - 也可以不加. ​ git reset –soft ​ move HEAD to specific commit reference, index and staging are untouched. ​ git reset –hard ​ unstage files AND undo any changes in the working directory since last commit. ​ 使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态. ​ 这里的HEAD可以被写成任何一次提交的SHA-1. ​ 不带soft和hard参数的git reset,实际上带的是默认参数mixed. ​ 总结: ​ git reset –mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容. ​ git reset –soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容. ​ git reset –hard id.是将git的HEAD变了,文件也变了. ​ 按改动范围排序如下: ​ soft (commit) &lt; mixed (commit + add) &lt; hard (commit + add + local working) git revert ​ 反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了. ​ git revert HEAD: 撤销最近的一个提交. ​ git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交. ​ git rm ​ git rm file: 从staging区移除文件,同时也移除出工作目录. ​ git rm –cached: 从staging区移除文件,但留在工作目录中. ​ git rm –cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树. git clean ​ git clean是从工作目录中移除没有track的文件. ​ 通常的参数是git clean -df: ​ -d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行. git mv ​ git rm - - cached orig; mv orig new; git add new git stash ​ 把当前的改动压入一个栈. ​ git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处. ​ git stash list会显示这个栈的list. ​ git stash apply:取出stash中的上一个项目(stash@{0}),并且应用于当前的工作目录. ​ 也可以指定别的项目,比如git stash apply stash@{1}. ​ 如果你在应用stash中项目的同时想要删除它,可以用git stash pop ​ 删除stash中的项目: ​ git stash drop: 删除上一个,也可指定参数删除指定的一个项目. ​ git stash clear: 删除所有项目. git branch ​ git branch可以用来列出分支,创建分支和删除分支. ​ git branch -v可以看见每一个分支的最后一次提交. ​ git branch: 列出本地所有分支,当前分支会被星号标示出. ​ git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的). ​ git branch -d (branchname): 删除一个分支. ​ 删除remote的分支: ​ git push (remote-name) :(branch-name): delete a remote branch. ​ 这个是因为完整的命令形式是: ​ git push remote-name local-branch:remote-branch ​ 而这里local-branch的部分为空,就意味着删除了remote-branch git checkout git checkout (branchname) 切换到一个分支. ​ git checkout -b (branchname): 创建并切换到新的分支. ​ 这个命令是将git branch newbranch和git checkout newbranch合在一起的结果. ​ checkout还有另一个作用:替换本地改动: ​ git checkout – ​ 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响. ​ 注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的. git merge ​ 把一个分支merge进当前的分支. ​ git merge [alias]/[branch] ​ 把远程分支merge到当前分支. ​ 如果出现冲突,需要手动修改,可以用git mergetool. ​ 解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved. git tag ​ tag a point in history as import. ​ 会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag. ​ 比如: git tag v1.0 ​ git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag. ​ 当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息. ​ ​ 我们可以利用commit SHA来给一个过去的提交打tag: ​ git tag -a v0.9 XXXX ​ push的时候是不包含tag的,如果想包含,可以在push时加上–tags参数. ​ fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上–tags选项. git remote ​ list, add and delete remote repository aliases. ​ 因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list. ​ git remote: 列出remote aliases. ​ 如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin. ​ git remote -v:可以看见每一个别名对应的实际url. ​ git remote add [alias] [url]: 添加一个新的remote repo. ​ git remote rm [alias]: 删除一个存在的remote alias. ​ git remote rename [old-alias] [new-alias]: 重命名. ​ git remote set-url [alias] [url]:更新url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址. git fetch ​ download new branches and data from a remote repository. ​ 可以git fetch [alias]取某一个远程repo,也可以git fetch –all取到全部repo ​ fetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们. git pull ​ fetch from a remote repo and try to merge into the current branch. ​ pull == fetch + merge FETCH_HEAD ​ git pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit. ​ 如果使用–rebase参数,它会执行git rebase来取代原来的git merge. git rebase ​ –rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上. ​ rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要: ​ git rebase –continue就会继续打余下的补丁. ​ git rebase –abort将会终止rebase,当前分支将会回到rebase之前的状态. git push ​ push your new branches and data to a remote repository. ​ git push [alias] [branch] ​ 将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支. ​ 如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来. git reflog ​ git reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化. ​ 当git reflog不指定引用的时候,默认列出HEAD的reflog. ​ HEAD@{0}代表HEAD当前的值,HEAD@{3}代表HEAD在3次变化之前的值. ​ git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中.","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://caicaing.github.io/tags/git/"}]},{"title":"Java Builder Pattern","slug":"Java-Builder-Pattern","date":"2019-05-15T01:33:28.000Z","updated":"2019-05-15T02:18:54.000Z","comments":true,"path":"2019/05/15/Java-Builder-Pattern/","link":"","permalink":"https://caicaing.github.io/2019/05/15/Java-Builder-Pattern/","excerpt":"静态工厂和构造函数有一个共同的限制:它们不能很好地扩展到大量可选参数，所以考虑通过构造器来构造一个类的实例。","text":"静态工厂和构造函数有一个共同的限制:它们不能很好地扩展到大量可选参数，所以考虑通过构造器来构造一个类的实例。 Telescoping constructor pattern通常我们在创建一个类的实例时候都是用它的构造函数来创建。例如： 1234567891011121314151617181920212223242526272829303132333435363738// Telescoping constructor pattern - does not scale well!public class NutritionFacts &#123; private final int servingSize; // (mL) required private final int servings; // (per container) required private final int calories; // (per serving) optional private final int fat; // (g/serving) optional private final int sodium; // (mg/serving) optional private final int carbohydrate; // (g/serving) optional public NutritionFacts(int servingSize, int servings) &#123; this(servingSize, servings, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories) &#123; this(servingSize, servings, calories, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat) &#123; this(servingSize, servings, calories, fat, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) &#123; this(servingSize, servings, calories, fat, sodium, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) &#123; this.servingSize = servingSize; this.servings = servings; this.calories = calories; this.fat = fat; this.sodium = sodium; this.carbohydrate = carbohydrate; &#125;&#125; 12NutritionFacts cocaCola =new NutritionFacts(240, 8, 100, 0, 35, 27); 但是这种方式存在很多不便之处： 即使只需要设定一部分参数也要为不需要设置的参数设置默认值 当参数过多的时候，尤其是存在许多同类型的参数的时候，很容易产生参数设置的混淆，这种混淆编译是不会发现的，在程序运行的时候才会产生错误 代码不易读懂，用户使用函数时候需要参照api JavaBeans Pattern另外一种可选的方式是javabean的形式，其主要理念是通过空构造函数来创建一个实例，然后通过set方法对参数进行赋值。例如： 1234567891011121314151617181920212223242526272829303132333435363738// JavaBeans Pattern - allows inconsistency, mandates mutabilitypublic class NutritionFacts &#123; // Parameters initialized to default values (if any) private int servingSize = -1; // Required; no default value private int servings = -1; // Required; no default value private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public NutritionFacts() &#123; &#125; // Setters public void setServingSize(int val) &#123; servingSize = val; &#125; public void setServings(int val) &#123; servings = val; &#125; public void setCalories(int val) &#123; calories = val; &#125; public void setFat(int val) &#123; fat = val; &#125; public void setSodium(int val) &#123; sodium = val; &#125; public void setCarbohydrate(int val) &#123; carbohydrate = val; &#125;&#125; 这种模式没有Telescoping constructor pattern的任何缺点。 创建实例很容易，虽然有点冗长，并且很容易读取生成的代码: 123456NutritionFacts cocaCola = new NutritionFacts();cocaCola.setServingSize(240);cocaCola.setServings(8);cocaCola.setCalories(100);cocaCola.setSodium(35);cocaCola.setCarbohydrate(27); 但是，javabean模式本身有严重的缺点。因为构造是在多个调用之间分割的，所以JavaBean在构造过程中可能处于不一致的状态。 Builder pattern客户机不直接生成所需的对象，而是使用所有必需的参数调用构造函数(或静态工厂)并获得一个构建器对象。然后客户端调用builder对象上类似setter的方法来设置每个可选参数。最后，客户端调用一个无参数的构建方法来生成对象，该对象通常是不可变的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * @Author liu * @Description //TODO * @Date 9:08 2019/5/15 * @Param * @return **/public class NutritionFacts &#123; private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder &#123; // Required parameters private final int servingSize; private final int servings; // Optional parameters - initialized to default values private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int servings) &#123; this.servingSize = servingSize; this.servings = servings; &#125; public Builder calories(int val) &#123; calories = val; return this; &#125; public Builder fat(int val) &#123; fat = val; return this; &#125; public Builder sodium(int val) &#123; sodium = val; return this; &#125; public Builder carbohydrate(int val) &#123; carbohydrate = val; return this; &#125; public NutritionFacts build() &#123; return new NutritionFacts(this); &#125; &#125; private NutritionFacts(Builder builder) &#123; servingSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; &#125; public static void main(String[] args) &#123; NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) .calories(100).sodium(35).carbohydrate(27).build(); &#125;&#125; Builder pattern也有缺点。为了创建对象，必须首先创建它的构建器。虽然在实践中创建这个构建器的成本不太可能显著，但在性能关键的情况下，它可能会成为一个问题。此外，Builder pattern的代码较为冗长，在设计构造函数或静态工厂有多个参数的类时，尤其是当许多参数是可选的或具有相同类型时，Builder模式是一个很好的选择，因为它更易读、更安全。","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://caicaing.github.io/tags/JAVA/"}]},{"title":"java异常、线程","slug":"java异常、线程","date":"2019-05-12T01:00:40.000Z","updated":"2019-05-12T01:01:54.000Z","comments":true,"path":"2019/05/12/java异常、线程/","link":"","permalink":"https://caicaing.github.io/2019/05/12/java异常、线程/","excerpt":"异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。","text":"异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 1.1 异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 1.2 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。 1.3 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 1.4 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。 工具类 1234567public class ArrayTools &#123; // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) &#123; int element = arr[index]; return element; &#125;&#125; 测试类 12345678public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123; 34, 12, 67 &#125;; intnum = ArrayTools.getElement(arr, 4) System.out.println(\"num=\" + num); System.out.println(\"over\"); &#125;&#125; 上述程序执行过程图解： 第二章 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 2.1 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 123throw new NullPointerException(\"要访问的arr数组不存在\");throw new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\"); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 123456789101112131415161718192021222324252627public class ThrowDemo &#123; public static void main(String[] args) &#123; //创建一个数组 int[] arr = &#123;2,4,52,2&#125;; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(\"over\"); &#125; /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException(\"哥们，角标越界了~~~\"); &#125; int element = arr[index]; return element; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 2.2 Objects非空判断还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作： 12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 2.3 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 声明异常的代码演示： 12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read(\"a.txt\"); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 123456789101112131415public class ThrowsDemo2 &#123; public static void main(String[] args) throws IOException &#123; read(\"a.txt\"); &#125; public static void read(String path)throws FileNotFoundException, IOException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; if (!path.equals(\"b.txt\")) &#123; throw new IOException(); &#125; &#125;&#125; 2.4 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 演示如下： 123456789101112131415161718192021public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(\"b.txt\"); &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​ 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 2.4 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read(\"a.txt\"); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println(\"不管程序怎样，这里都将会被执行。\"); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 2.5 异常注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 第三章 自定义异常3.1 概述为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个注册异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 3.2 自定义异常的练习要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： 12345678910111213141516// 业务逻辑异常public class RegisterException extends Exception &#123; /** * 空参构造 */ public RegisterException() &#123; &#125; /** * * @param message 表示异常提示 */ public RegisterException(String message) &#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 123456789101112131415161718192021222324252627public class Demo &#123; // 模拟数据库中已存在账号 private static String[] names = &#123;\"bill\",\"hill\",\"jill\"&#125;; public static void main(String[] args) &#123; //调用方法 try&#123; // 可能出现异常的代码 checkUsername(\"nill\"); System.out.println(\"注册成功\");//如果没有异常就是注册成功 &#125;catch(RegisterException e)&#123; //处理异常 e.printStackTrace(); &#125; &#125; //判断当前注册账号是否存在 //因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException&#123; for (String name : names) &#123; if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常 throw new RegisterException(\"亲\"+name+\"已经被注册了！\"); &#125; &#125; return true; &#125;&#125; 第四章 多线程我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？ 要解决上述问题,咱们得使用多进程或者多线程来解决. 4.1 并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 4.2 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程： 进程 线程 线程调度: 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 4.3 创建线程类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 代码如下： 测试类： 123456789101112public class Demo01 &#123; public static void main(String[] args) &#123; //创建自定义线程对象 MyThread mt = new MyThread(\"新的线程！\"); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"main线程！\"+i); &#125; &#125;&#125; 自定义线程类： 12345678910111213141516public class MyThread extends Thread &#123; //定义指定线程名称的构造方法 public MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name); &#125; /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName()+\"：正在执行！\"+i); &#125; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://caicaing.github.io/tags/java/"}]},{"title":"java集合工具对自定义类进行排序","slug":"java集合工具对自定义类进行排序","date":"2019-05-11T14:13:23.000Z","updated":"2019-05-12T01:01:09.000Z","comments":true,"path":"2019/05/11/java集合工具对自定义类进行排序/","link":"","permalink":"https://caicaing.github.io/2019/05/11/java集合工具对自定义类进行排序/","excerpt":"想要被排序的类需要实现Comparable接口并且重写compareTo方法。 this - 传进来的参数为升序。","text":"想要被排序的类需要实现Comparable接口并且重写compareTo方法。 this - 传进来的参数为升序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.text.ParseException;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class Main &#123; public static void main(String[] args) throws ParseException &#123; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(65, \"小张\")); list.add(new User(77, \"小强\")); list.add(new User(39, \"小明\")); list.add(new User(99, \"小红\")); Collections.sort(list); System.out.println(list); &#125;&#125;class User implements Comparable&lt;User&gt; &#123; private int score; private String name; public User(int score, String name) &#123; this.score = score; this.name = name; &#125; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"score=\" + score + \", name='\" + name + '\\'' + '&#125;'; &#125; @Override public int compareTo(User o) &#123; return this.getScore() - o.getScore(); &#125;&#125;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://caicaing.github.io/tags/JAVA/"}]},{"title":"java常用类api","slug":"java常用类api","date":"2019-05-10T03:23:26.000Z","updated":"2019-05-10T03:24:01.000Z","comments":true,"path":"2019/05/10/java常用类api/","link":"","permalink":"https://caicaing.github.io/2019/05/10/java常用类api/","excerpt":"java常用类api","text":"java常用类api Object类1.1 概述java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个： public String toString()：返回该对象的字符串表示。 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 1.2 toString方法方法摘要 public String toString()：返回该对象的字符串表示。 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; // 省略构造器与Getter Setter&#125; 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。如下图所示： 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 1.3 equals方法方法摘要 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。如下图所示： 1.4 Objects类在刚才IDEA自动重写equals代码中，使用到了java.util.Objects类，那么这个类是什么呢？ 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 我们可以查看一下源码，学习一下： 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125; 日期时间类2.1 Date类概述java.util.Date类 表示特定的瞬间，精确到毫秒。 继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。 public Date()：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; // 创建日期对象，把当前的时间 System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018 // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 常用方法Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 2.2 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。 创建SimpleDateFormat对象的代码如： 123456789import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat &#123; public static void main(String[] args) &#123; // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); &#125; &#125; 常用方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法使用format方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod &#123; public static void main(String[] args) &#123; Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = df.format(date); System.out.println(str); // 2008年1月23日 &#125;&#125; parse方法使用parse方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod &#123; public static void main(String[] args) throws ParseException &#123; DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = \"2018年12月11日\"; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 &#125;&#125; 2.4 Calendar类概念日历我们都见过 java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 获取方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： 1234567import java.util.Calendar;public class Demo06CalendarInit &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); &#125; &#125; 常用方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： 123456789101112131415import java.util.Calendar;public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); &#125; &#125; 123456789import java.util.Calendar;public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日 &#125;&#125; add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： 123456789101112import java.util.Calendar;public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; &#125;&#125; getTime方法Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 12345678910import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 3.1 currentTimeMillis方法实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 12345678import java.util.Date;public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; 练习验证for循环打印数字1-9999所需要使用的时间（毫秒） 12345678910public class SystemTest1 &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); &#125; long end = System.currentTimeMillis(); System.out.println(\"共耗时毫秒：\" + (end - start)); &#125;&#125; 3.2 arraycopy方法 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为： 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 练习将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] 12345678910111213import java.util.Arrays;public class Demo11SystemArrayCopy &#123; public static void main(String[] args) &#123; int[] src = new int[]&#123;1,2,3,4,5&#125;; int[] dest = new int[]&#123;6,7,8,9,10&#125;; System.arraycopy( src, 0, dest, 0, 3); /*代码运行后：两个数组中的元素发生了变化 src数组元素[1,2,3,4,5] dest数组元素[1,2,3,9,10] */ &#125;&#125; StringBuilder类4.1 字符串拼接问题由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： 1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s = \"Hello\"; s += \"World\"; System.out.println(s); &#125;&#125; 在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。 根据这句话分析我们的代码，其实总共产生了三个字符串，即&quot;Hello&quot;、&quot;World&quot;和&quot;HelloWorld&quot;。引用变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWord 。 由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 4.2 StringBuilder概述查阅java.lang.StringBuilder的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 4.3 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 123456789public class StringBuilderDemo &#123; public static void main(String[] args) &#123; StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder(\"itcast\"); System.out.println(sb2); // itcast &#125;&#125; 4.4 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： 12345678910111213141516171819202122public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append(\"hello\"); //对比一下 System.out.println(\"builder:\"+builder); System.out.println(\"builder2:\"+builder2); System.out.println(builder == builder2); //true // 可以添加 任何类型 builder.append(\"hello\"); builder.append(\"world\"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append(\"hello\").append(\"world\").append(true).append(100); System.out.println(\"builder:\"+builder); &#125;&#125; 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 包装类5.1 概述Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 5.2 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可） 基本数值—-&gt;包装对象 12Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 包装对象—-&gt;基本数值 1int num = i.intValue(); 5.3自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 5.3 基本类型与字符串之间的转换基本类型转换为String 基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： 1基本类型直接与””相连接即可；如：34+&quot;&quot; String转换成对应的基本类型 除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 12345public class Demo18WrapperParse &#123; public static void main(String[] args) &#123; int num = Integer.parseInt(\"100\"); &#125;&#125; 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://caicaing.github.io/tags/java/"}]},{"title":"Spring Boot单/多文件上传","slug":"Spring-Boot单文件上传","date":"2019-05-06T07:18:38.000Z","updated":"2019-11-19T10:49:16.478Z","comments":true,"path":"2019/05/06/Spring-Boot单文件上传/","link":"","permalink":"https://caicaing.github.io/2019/05/06/Spring-Boot单文件上传/","excerpt":"Spring Bootd单/多文件上传","text":"Spring Bootd单/多文件上传 单/多文件上传upload.html： 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\"&gt; 上传文件1：&lt;input type=\"file\" name=\"file\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; UploadController: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.example.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartHttpServletRequest;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException;import java.util.List;@Controllerpublic class UploadController &#123; @GetMapping(\"/upload\") public String upload() &#123; return \"upload\"; &#125; @GetMapping(\"/multiUpload\") public String multiUpload() &#123; return \"multiUpload\"; &#125; @PostMapping(\"/multiUpload\") @ResponseBody public String multiUpload(HttpServletRequest request) &#123; List&lt;MultipartFile&gt; files = ((MultipartHttpServletRequest) request).getFiles(\"file\"); String filePath = \"D:/path/\"; for (int i = 0; i &lt; files.size(); i++) &#123; MultipartFile file = files.get(i); if (file.isEmpty()) &#123; return \"上传第\" + (i++) + \"个文件失败\"; &#125; String fileName = file.getOriginalFilename(); File dest = new File(filePath + fileName); try &#123; file.transferTo(dest); &#125; catch (IOException e) &#123; return \"上传第\" + (i++) + \"个文件失败\"; &#125; &#125; return \"上传成功\"; &#125; @PostMapping(\"/upload\") @ResponseBody public String upload(@RequestParam(\"file\") MultipartFile file) &#123; if (file.isEmpty()) &#123; return \"上传失败，请选择文件\"; &#125; String fileName = file.getOriginalFilename(); String filePath = \"D:/path/\"; File dest = new File(filePath + fileName); try &#123; file.transferTo(dest); return \"上传成功\"; &#125; catch (IOException e) &#123; &#125; return \"上传失败！\"; &#125;&#125; multiUpload.html 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/multiUpload\" enctype=\"multipart/form-data\" method=\"post\"&gt; 上传文件：&lt;input type=\"file\" name=\"file\"&gt;&lt;br/&gt; 上传文件：&lt;input type=\"file\" name=\"file\"&gt;&lt;br/&gt; 上传文件：&lt;input type=\"file\" name=\"file\"&gt;&lt;br/&gt; 上传文件：&lt;input type=\"file\" name=\"file\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 设置上传文件大小的两种方式springboot 1.5.X系列处理方式创建tomcat配置类123456789@Bean public MultipartConfigElement multipartConfigElement() &#123; MultipartConfigFactory factory = new MultipartConfigFactory(); //文件最大 factory.setMaxFileSize(\"10240KB\"); //KB,MB /// 设置总上传数据总大小 factory.setMaxRequestSize(\"102400KB\"); return factory.createMultipartConfig(); &#125; 注意spring.http.multipart.maxFileSize=10Mbspring.http.multipart.maxRequestSize=10Mb已经过期 &gt;&gt;&gt;&gt; 在application.properties中添加如下配置信息application.properties 12spring.servlet.multipart.max-file-size=20MBspring.servlet.multipart.max-request-size=20MB maxFileSize 是单个文件大小maxRequestSize是设置总上传的数据大小 Springboot 2.X系列配置创建tomcat配置类123456789101112131415@Configurationpublic class TomcatConfig &#123; @Bean public MultipartConfigElement multipartConfigElement() &#123; MultipartConfigFactory factory = new MultipartConfigFactory(); //文件最大10M,DataUnit提供5中类型B,KB,MB,GB,TB factory.setMaxFileSize(DataSize.of(100, DataUnit.MEGABYTES)); /// 设置总上传数据总大小10M factory.setMaxRequestSize(DataSize.of(100, DataUnit.MEGABYTES)); return factory.createMultipartConfig(); &#125;&#125; 配置文件配置application.properties 12spring.servlet.multipart.max-file-size=20MBspring.servlet.multipart.max-request-size=20MB","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"}]},{"title":"JAVAWEB文件上传","slug":"form表单文件上传","date":"2019-05-06T05:46:37.000Z","updated":"2019-05-06T06:49:11.000Z","comments":true,"path":"2019/05/06/form表单文件上传/","link":"","permalink":"https://caicaing.github.io/2019/05/06/form表单文件上传/","excerpt":"对于文件上传，浏览器在上传的过程中是将文件以流的形式提交到服务器端的，如果直接使用Servlet获取上传文件的输入流然后再解析里面的请求参数是比较麻烦，所以一般选择采用apache的开源工具common-fileupload这个文件上传组件。这个common-fileupload上传组件的jar包可以去apache官网上面下载，也可以在struts的lib文件夹下面找到，struts上传的功能就是基于这个实现的。common-fileupload是依赖于common-io这个包的，所以还需要下载这个包。","text":"对于文件上传，浏览器在上传的过程中是将文件以流的形式提交到服务器端的，如果直接使用Servlet获取上传文件的输入流然后再解析里面的请求参数是比较麻烦，所以一般选择采用apache的开源工具common-fileupload这个文件上传组件。这个common-fileupload上传组件的jar包可以去apache官网上面下载，也可以在struts的lib文件夹下面找到，struts上传的功能就是基于这个实现的。common-fileupload是依赖于common-io这个包的，所以还需要下载这个包。 UploadHandleServlet的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175package me.gacl.web.controller;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.util.List;import java.util.UUID;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadBase;import org.apache.commons.fileupload.ProgressListener;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;/*** @ClassName: UploadHandleServlet**/ public class UploadHandleServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //得到上传文件的保存目录，将上传的文件存放于WEB-INF目录下，不允许外界直接访问，保证上传文件的安全 String savePath = this.getServletContext().getRealPath(\"/WEB-INF/upload\"); //上传时生成的临时文件保存目录 String tempPath = this.getServletContext().getRealPath(\"/WEB-INF/temp\"); File tmpFile = new File(tempPath); if (!tmpFile.exists()) &#123; //创建临时目录 tmpFile.mkdir(); &#125; //消息提示 String message = \"\"; try&#123; //使用Apache文件上传组件处理文件上传步骤： //1、创建一个DiskFileItemFactory工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); //设置工厂的缓冲区的大小，当上传的文件大小超过缓冲区的大小时，就会生成一个临时文件存放到指定的临时目录当中。 factory.setSizeThreshold(1024*100);//设置缓冲区的大小为100KB，如果不指定，那么缓冲区的大小默认是10KB //设置上传时生成的临时文件的保存目录 factory.setRepository(tmpFile); //2、创建一个文件上传解析器 ServletFileUpload upload = new ServletFileUpload(factory); //监听文件上传进度 upload.setProgressListener(new ProgressListener()&#123; public void update(long pBytesRead, long pContentLength, int arg2) &#123; System.out.println(\"文件大小为：\" + pContentLength + \",当前已处理：\" + pBytesRead); /** * 文件大小为：14608,当前已处理：4096 文件大小为：14608,当前已处理：7367 文件大小为：14608,当前已处理：11419 文件大小为：14608,当前已处理：14608 */ &#125; &#125;); //解决上传文件名的中文乱码 upload.setHeaderEncoding(\"UTF-8\"); //3、判断提交上来的数据是否是上传表单的数据 if(!ServletFileUpload.isMultipartContent(request))&#123; //按照传统方式获取数据 return; &#125; //设置上传单个文件的大小的最大值，目前是设置为1024*1024字节，也就是1MB upload.setFileSizeMax(1024*1024); //设置上传文件总量的最大值，最大值=同时上传的多个文件的大小的最大值的和，目前设置为10MB upload.setSizeMax(1024*1024*10); //4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List&lt;FileItem&gt;集合，每一个FileItem对应一个Form表单的输入项 List&lt;FileItem&gt; list = upload.parseRequest(request); for(FileItem item : list)&#123; //如果fileitem中封装的是普通输入项的数据 if(item.isFormField())&#123; String name = item.getFieldName(); //解决普通输入项的数据的中文乱码问题 String value = item.getString(\"UTF-8\"); //value = new String(value.getBytes(\"iso8859-1\"),\"UTF-8\"); System.out.println(name + \"=\" + value); &#125;else&#123;//如果fileitem中封装的是上传文件 //得到上传的文件名称， String filename = item.getName(); System.out.println(filename); if(filename==null || filename.trim().equals(\"\"))&#123; continue; &#125; //注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如： c:\\a\\b\\1.txt，而有些只是单纯的文件名，如：1.txt //处理获取到的上传文件的文件名的路径部分，只保留文件名部分 filename = filename.substring(filename.lastIndexOf(\"\\\\\")+1); //得到上传文件的扩展名 String fileExtName = filename.substring(filename.lastIndexOf(\".\")+1); //如果需要限制上传的文件类型，那么可以通过文件的扩展名来判断上传的文件类型是否合法 System.out.println(\"上传的文件的扩展名是：\"+fileExtName); //获取item中的上传文件的输入流 InputStream in = item.getInputStream(); //得到文件保存的名称 String saveFilename = makeFileName(filename); //得到文件的保存目录 String realSavePath = makePath(saveFilename, savePath); //创建一个文件输出流 FileOutputStream out = new FileOutputStream(realSavePath + \"\\\\\" + saveFilename); //创建一个缓冲区 byte buffer[] = new byte[1024]; //判断输入流中的数据是否已经读完的标识 int len = 0; //循环将输入流读入到缓冲区当中，(len=in.read(buffer))&gt;0就表示in里面还有数据 while((len=in.read(buffer))&gt;0)&#123; //使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath + \"\\\\\" + filename)当中 out.write(buffer, 0, len); &#125; //关闭输入流 in.close(); //关闭输出流 out.close(); //删除处理文件上传时生成的临时文件 //item.delete(); message = \"文件上传成功！\"; &#125; &#125; &#125;catch (FileUploadBase.FileSizeLimitExceededException e) &#123; e.printStackTrace(); request.setAttribute(\"message\", \"单个文件超出最大值！！！\"); request.getRequestDispatcher(\"/message.jsp\").forward(request, response); return; &#125;catch (FileUploadBase.SizeLimitExceededException e) &#123; e.printStackTrace(); request.setAttribute(\"message\", \"上传文件的总的大小超出限制的最大值！！！\"); request.getRequestDispatcher(\"/message.jsp\").forward(request, response); return; &#125;catch (Exception e) &#123; message= \"文件上传失败！\"; e.printStackTrace(); &#125; request.setAttribute(\"message\",message); request.getRequestDispatcher(\"/message.jsp\").forward(request, response); &#125; /** * @Method: makeFileName */ private String makeFileName(String filename)&#123; //2.jpg //为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名 return UUID.randomUUID().toString() + \"_\" + filename; &#125; /** * 为防止一个目录下面出现太多文件，要使用hash算法打散存储 */ private String makePath(String filename,String savePath)&#123; //得到文件名的hashCode的值，得到的就是filename这个字符串对象在内存中的地址 int hashcode = filename.hashCode(); int dir1 = hashcode&amp;0xf; //0--15 int dir2 = (hashcode&amp;0xf0)&gt;&gt;4; //0-15 //构造新的保存目录 String dir = savePath + \"\\\\\" + dir1 + \"\\\\\" + dir2; //upload\\2\\3 upload\\3\\5 //File既可以代表文件也可以代表目录 File file = new File(dir); //如果目录不存在 if(!file.exists())&#123; //创建目录 file.mkdirs(); &#125; return dir; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; upload.jsp页面的代码如下： 12345678910111213141516&lt;%@ page language=\"java\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;文件上传&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/servlet/UploadHandleServlet\" enctype=\"multipart/form-data\" method=\"post\"&gt; 上传用户：&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; 上传文件1：&lt;input type=\"file\" name=\"file1\"&gt;&lt;br/&gt; 上传文件2：&lt;input type=\"file\" name=\"file2\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://caicaing.github.io/tags/JAVA/"}]},{"title":"vue学习笔记(二)","slug":"vue学习笔记-二","date":"2019-04-19T00:58:42.000Z","updated":"2019-04-20T12:09:53.000Z","comments":true,"path":"2019/04/19/vue学习笔记-二/","link":"","permalink":"https://caicaing.github.io/2019/04/19/vue学习笔记-二/","excerpt":"Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。","text":"Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 Class与Style绑定绑定HTML Class对象语法可以传给v-bind:class一个对象,动态的切换class: 1&lt;div class=\"static\" id = \"div1\" v-bind:class=\"&#123;'active': isActive, 'text-danger' : hasError&#125;\"&gt; 1234567new Vue(&#123; el:'#div1', data:&#123; isActive : true, hasError : true &#125;&#125;) 当对应的属性的值为true的时候,div的class里就会增加相应的格式,上述例子的class为: 1static active text-danger 绑定的数据对象不必内联定义在模板里： 1&lt;div id=\"div2\" v-bind:class=\"classObject\"&gt;&lt;/div&gt; 123456789new Vue(&#123; el:'#div2', data:&#123; classObject:&#123; avtive:true, 'text-danger':true &#125;, &#125;&#125;) 也可以使 div class=”avtive text-danger” 我们也可以在这里绑定一个返回对象的计算属性: 1&lt;div id=\"div3\" v-bind:class=\"classObject3\"&gt;&lt;/div&gt; 123456789101112131415new Vue(&#123; el:'#div3', data:&#123; isActive:true, error: null &#125;, computed:&#123; classObject3:function()&#123; return &#123; active:this.isActive&amp;&amp;!this.error,'text-danger':this.error&amp;&amp;this.error.type ==='fatal' &#125; &#125; &#125;&#125;) 数组语法:我们可以把一个数组传给v-bind:class,以应用一个class列表: 1&lt;div id = \"div4\" v-bind:class=\"[activeClass, errorClass]\"&gt;div4&lt;/div&gt; 1234567new Vue(&#123; el:'#div4', data:&#123; activeClass: 'active', errorClass: 'text-danger' &#125;&#125;) 也可以用三元表达式来按条件切换class 1&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt;&lt;/div&gt; 用在组件上当在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。 例如，如果你声明了这个组件： 123Vue.component(&apos;my-component&apos;, &#123; template: &apos;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&apos;&#125;) 然后在使用它的时候添加一些 class： 1&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt; HTML 将被渲染为: 1&lt;p class=\"foo bar baz boo\"&gt;Hi&lt;/p&gt; html对于带数据绑定 class 也同样适用： 1&lt;my-component v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/my-component&gt; 当 isActive 为 truthy[1] 时，HTML 将被渲染成为： 1&lt;p class=\"foo bar active\"&gt;Hi&lt;/p&gt; 绑定内联样式对象语法1&lt;div id=\"div5\" v-bind:style=\"&#123;color: activeColor, fontSize:fontSize + 'px'&#125;\"&gt; div5&lt;/div&gt; 12345678new Vue(&#123; el: '#div5', data: &#123; activeColor: 'red', fontSize: 30 &#125;&#125;) 直接绑定到一个样式对象会让模板更清晰： 1&lt;div id=\"div6\" v-bind:style=\"styleObject\"&gt; div6&lt;/div&gt; 123456789new Vue(&#123; el: '#div6', data: &#123; styleObject:&#123; color: 'red', fontSize: '30px' &#125; &#125;&#125;) 数组语法v-bind:style的数组语法可以将多个样式对象应用到同一个元素上: 数组语法v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上： 1&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt; 自动添加前缀当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。 条件渲染v-if12345678&lt;div id=\"example\"&gt; &lt;p v-if=\"greeting\"&gt; Directive1 &lt;/p&gt; &lt;p v-else=\"greeting\"&gt; Directive2 &lt;/p&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example', data: &#123; greeting: true &#125;&#125;); v-else必须要和v-if匹配使用，v-else不能单独使用。只有v-if的值为false时，v-else模块才会显示出来。 因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 &lt;template&gt; 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 &lt;template&gt; 元素。 在template 元素上使用v-if 条件渲染分组12345&lt;template v-if=\"ok\"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-else-ifv-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： 123456789101112&lt;div v-if=\"type === 'A'\"&gt; A&lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt; B&lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 用key管理可复用的元素Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换： 12345678&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\"&gt;&lt;/template&gt; 添加一个具有唯一值的 key 属性,每次切换时，输入框都将被重新渲染。 12345678&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\" key=\"username-input\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\" key=\"email-input\"&gt;&lt;/template&gt; v-showv-show 只是简单地切换元素的 CSS 属性 display。 1&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt; v-if 和v-show区别 v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://caicaing.github.io/tags/vue-js/"}]},{"title":"vue学习笔记(一)","slug":"vue学习笔记-一","date":"2019-04-18T11:46:55.000Z","updated":"2019-04-20T12:07:40.000Z","comments":true,"path":"2019/04/18/vue学习笔记-一/","link":"","permalink":"https://caicaing.github.io/2019/04/18/vue学习笔记-一/","excerpt":"Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。","text":"Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 引入vue可以通过如下方式引入vue 或者 或者去 下载vue.js文件本地引入 vue的使用:创建vue实例:123456var vm = new Vue(&#123; el: '#app', data: &#123; message: 'hello Vue.js' &#125;&#125;) 对应的html的id为app的div: 123&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; 当运行时,message会被替换为data中的 message的值 ‘hello Vue.js’ ,值得注意的是使用双大括号会把值解析为纯文本,所以即使Vue的定义为: 123456var vm = new Vue(&#123; el: '#app', data: &#123; message: '&lt;h1&gt;标题&lt;/h1&gt;' &#125;&#125;) message的值也会被解析为标题 文本,而不会被解析为html的格式 数据与方法:当一个 Vue 实例被创建时，它将 data 对象中的所有的属性加入到 Vue 的响应式系统中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 &lt;div id=&quot;app1&quot;&gt; {{data}} &lt;/div&gt; 1234567&lt;script&gt; var data = \"1\" var vm = new Vue(&#123; el: '#app1', data: data &#125;)&lt;/script&gt; 在上述代码中,我们在js控制台中无论改变data的值或者vm.data的值,两者都会一起改变.值得注意的是只有当实例被创建时 data 中存在的属性才是响应式的。也就是说如果你添加一个新的属性，比如： vm.b = ‘hi’那么对 b 的改动将不会触发任何视图的更新。 除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。例如： 12345678910111213var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: '#example', data: data&#125;)vm.$data === data // =&gt; truevm.$el === document.getElementById('example') // =&gt; true// $watch 是一个实例方法vm.$watch('a', function (newValue, oldValue) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 生命周期钩子:例如create 可以用来在一个实例被创建之后执行代码,： 123456789new Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;&#125;) 钩子 beforeCreate 创建实例之前执行 created 实例创建完成后执行 beforeMount 将编译完成的HTML挂载到对应虚拟dom时触发的钩子,此时页面并没有内容 mounted 将编译完成的HTML挂载到页面完成后执行的钩子,此时钩子函数中一般会做一些ajax请求获取数据进行数据初始化,mounted在整个实例中只执行一次 beforeUpdate 实时监控数据变化并随之更新DOM updated 更新之后的钩子 beforeDestroy 实例销毁之前执行的钩子 destroyed 实例销毁完成执行的钩子 使用JavaScript表达式:对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。 1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id=\"'list-' + id\"&gt;&lt;/div&gt; 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。 12345&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 指令:指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 12345678910111213141516171819202122232425&lt;div id=\"app2\"&gt; &lt;span v-bind:title=\"message\"&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息; &lt;/span&gt;&lt;/div&gt; &lt;div id=\"app3\"&gt; &lt;p v-if=\"seen\"&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt;&lt;div id=\"app4\"&gt; &lt;ol&gt; &lt;li v-for=\"todo in todos\"&gt; &#123;&#123;todo.text&#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;div id=\"app5\"&gt; &lt;p&gt; &#123;&#123;message&#125;&#125; &lt;/p&gt; &lt;button v-on:click=\"reverseMessage\"&gt; 逆转消息&lt;/button&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243var app2 = new Vue(&#123; el: '#app2', data: &#123; message: '页面加载于' + new Date().toLocaleDateString() &#125;&#125;) var app3 = new Vue(&#123; el: '#app3', data: &#123; seen: true &#125;&#125;)var app4 = new Vue(&#123; el: '#app4', data: &#123; todos: [&#123; text: '学习javascript' &#125;, &#123; text: '学习vue' &#125;, &#123; text: '整个牛项目' &#125; ] &#125;&#125;)var app5 = new Vue(&#123; el: '#app5', data: &#123; message: 'Hello Vue.js' &#125;, methods: &#123; reverseMessage: function() &#123; this.message = this.message.split('').reverse().join('') &#125; &#125;&#125;) 在app2,app3,app4.app5中分别实现了绑定鼠标事件,if判断,for循环,函数功能 动态参数:12&lt;a id = \"a1\" v-bind:[url]=\"url\"&gt; ... &lt;/a&gt; &lt;br&gt;&lt;a id = \"a2\" v-on:[name]=\"doSomething\"&gt; ... &lt;/a&gt; 123456789101112131415161718new Vue(&#123; el:'#a1', data:&#123; url:'href' &#125;&#125;) new Vue(&#123; el:'#a2', data:&#123; name:'dblclick' &#125;, methods:&#123; doSomething : function ()&#123; alert(\"函数执行\") &#125; &#125;&#125;) 从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数： a1 中 v-bind:[url] ,中括号内的url会被替换为Vue中定义的url值:href a2中v-on:[name],中括号内的name会被替换为Vue中定义的name值:dblclick","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://caicaing.github.io/tags/vue-js/"}]},{"title":"org.springframework.expression.spel.SpelEvaluationException: EL1008E:","slug":"org-springframework-expression-spel-SpelEvaluationException-EL1008E","date":"2019-04-15T07:00:52.000Z","updated":"2019-04-15T07:33:00.000Z","comments":true,"path":"2019/04/15/org-springframework-expression-spel-SpelEvaluationException-EL1008E/","link":"","permalink":"https://caicaing.github.io/2019/04/15/org-springframework-expression-spel-SpelEvaluationException-EL1008E/","excerpt":"今天发生了一个很诡异的事情,在进行thymeleaf进行前端视图显示的时候总是出现SpelEvaluationException异常.刚开始以为自己的属性名字填错了,经过反复确认发现没填错.后来考虑是不是get方法的问题.去类里一看,果真是get方法出了问题.","text":"今天发生了一个很诡异的事情,在进行thymeleaf进行前端视图显示的时候总是出现SpelEvaluationException异常.刚开始以为自己的属性名字填错了,经过反复确认发现没填错.后来考虑是不是get方法的问题.去类里一看,果真是get方法出了问题. 正确的get方法是 123public Long getDid() &#123; return did;&#125; 然而我的get方法是从原来改的,当时为了省劲就直接把名字改了改,直接输入了did,导致在使用${dept.did}时找不到did属性 123public Long getdid() &#123; return did;&#125; 错误信息:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990org.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field 'did' cannot be found on object of type 'com.caicai.aidangjian.entity.Department' - maybe not public or not valid? at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:217) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:51) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:406) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:90) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:109) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:328) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:263) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:144) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.engine.OpenElementTag.beHandled(OpenElementTag.java:205) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.engine.Model.process(Model.java:290) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.engine.IteratedGatheringModelProcessable.processIterationModel(IteratedGatheringModelProcessable.java:367) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.engine.IteratedGatheringModelProcessable.process(IteratedGatheringModelProcessable.java:221) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.engine.ProcessorTemplateHandler.handleCloseElement(ProcessorTemplateHandler.java:1640) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleCloseElementEnd(TemplateHandlerAdapterMarkupHandler.java:388) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleCloseElementEnd(InlinedOutputExpressionMarkupHandler.java:322) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleCloseElementEnd(OutputExpressionInlinePreProcessorHandler.java:220) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleCloseElementEnd(InlinedOutputExpressionMarkupHandler.java:164) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.attoparser.HtmlElement.handleCloseElementEnd(HtmlElement.java:169) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.attoparser.HtmlMarkupHandler.handleCloseElementEnd(HtmlMarkupHandler.java:412) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.attoparser.MarkupEventProcessorHandler.handleCloseElementEnd(MarkupEventProcessorHandler.java:473) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.attoparser.ParsingElementMarkupUtil.parseCloseElement(ParsingElementMarkupUtil.java:201) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:725) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE] at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1370) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1116) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1055) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.16.jar:9.0.16] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_201] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_201] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.16.jar:9.0.16] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201] ##","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"}]},{"title":"JPA Space is not allowed after parameter prefix ':'","slug":"JPA-Space-is-not-allowed-after-parameter-prefix","date":"2019-04-14T08:43:02.000Z","updated":"2019-04-15T07:35:05.000Z","comments":true,"path":"2019/04/14/JPA-Space-is-not-allowed-after-parameter-prefix/","link":"","permalink":"https://caicaing.github.io/2019/04/14/JPA-Space-is-not-allowed-after-parameter-prefix/","excerpt":"查询时候想根据分数排序并且添加对应的名词序号,所以mysql语句中出现了(@i:=@i+1),在navicat下可以正常的运行.但是在使用@Query时出现’JPA Space is not allowed after parameter prefix ‘’:’’’错误;","text":"查询时候想根据分数排序并且添加对应的名词序号,所以mysql语句中出现了(@i:=@i+1),在navicat下可以正常的运行.但是在使用@Query时出现’JPA Space is not allowed after parameter prefix ‘’:’’’错误; @Query注解如下: 1@Query(value = \"select (@i:=@i+1)pm from record s,(select @i:=0)t order by score desc;\",nativeQuery = true) 去查资料,解决方案是把:转义 变成//: 1@Query(value = \"select (@i\\\\:=@i+1)pm from record s,(select @i\\\\:=0)t order by score desc;\",nativeQuery = true)","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"},{"name":"JPA","slug":"JPA","permalink":"https://caicaing.github.io/tags/JPA/"}]},{"title":"Echarts","slug":"Echarts","date":"2019-04-13T07:31:57.000Z","updated":"2019-10-07T09:15:20.010Z","comments":true,"path":"2019/04/13/Echarts/","link":"","permalink":"https://caicaing.github.io/2019/04/13/Echarts/","excerpt":"ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。","text":"ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。 引入Echarts.js文件 Echarts.js文件可以到 echarts官网下载 12&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&gt; 准备一个存放图表的容器1&lt;div id=\"box\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt; 设置参数 初始化图表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 &lt;script&gt; var myChart = echarts.init(document.getElementById(\"box\")); var option = &#123; title : &#123; text: '未来一周气温变化', subtext: '纯属虚构' &#125;, tooltip : &#123; trigger: 'axis' &#125;, legend: &#123; data:['最高气温','最低气温'] &#125;, toolbox: &#123; show : true, feature : &#123; mark : &#123;show: true&#125;, dataView : &#123;show: true, readOnly: false&#125;, magicType : &#123;show: true, type: ['line', 'bar']&#125;, restore : &#123;show: true&#125;, saveAsImage : &#123;show: true&#125; &#125; &#125;, calculable : true, xAxis : [ &#123; type : 'category', boundaryGap : false, data : ['周一','周二','周三','周四','周五','周六','周日'] &#125; ], yAxis : [ &#123; type : 'value', axisLabel : &#123; formatter: '&#123;value&#125; °C' &#125; &#125; ], series : [ &#123; name:'最高气温', type:'line', data:[11, 11, 15, 13, 12, 13, 10], markPoint : &#123; data : [ &#123;type : 'max', name: '最大值'&#125;, &#123;type : 'min', name: '最小值'&#125; ] &#125;, markLine : &#123; data : [ &#123;type : 'average', name: '平均值'&#125; ] &#125; &#125;, &#123; name:'最低气温', type:'line', data:[1, -2, 2, 5, 3, 2, 0], markPoint : &#123; data : [ &#123;name : '周最低', value : -2, xAxis: 1, yAxis: -1.5&#125; ] &#125;, markLine : &#123; data : [ &#123;type : 'average', name : '平均值'&#125; ] &#125; &#125; ] &#125;; myChart.setOption(option);&lt;/script&gt; 效果图 ​ 各个配置参数的说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738theme = &#123; // 全图默认背景 // backgroundColor: 'rgba(0,0,0,0)', // 默认色板 color: ['#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed', '#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0', '#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700', '#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'], // 图表标题 title: &#123; x: 'left', // 水平安放位置，默认为左对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ &#123;number&#125;（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ &#123;number&#125;（y坐标，单位px） //textAlign: null // 水平对齐方式，默认根据x设置自动调整 backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 标题边框颜色 borderWidth: 0, // 标题边框线宽，单位px，默认为0（无边框） padding: 5, // 标题内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 主副标题纵向间隔，单位px，默认为10， textStyle: &#123; fontSize: 18, fontWeight: 'bolder', color: '#333' // 主标题文字颜色 &#125;, subtextStyle: &#123; color: '#aaa' // 副标题文字颜色 &#125; &#125;, // 图例 legend: &#123; orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' x: 'center', // 水平安放位置，默认为全图居中，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ &#123;number&#125;（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ &#123;number&#125;（y坐标，单位px） backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 图例边框颜色 borderWidth: 0, // 图例边框线宽，单位px，默认为0（无边框） padding: 5, // 图例内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 图例图形宽度 itemHeight: 14, // 图例图形高度 textStyle: &#123; color: '#333' // 图例文字颜色 &#125; &#125;, // 值域 dataRange: &#123; orient: 'vertical', // 布局方式，默认为垂直布局，可选为： // 'horizontal' ¦ 'vertical' x: 'left', // 水平安放位置，默认为全图左对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ &#123;number&#125;（x坐标，单位px） y: 'bottom', // 垂直安放位置，默认为全图底部，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ &#123;number&#125;（y坐标，单位px） backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 值域边框颜色 borderWidth: 0, // 值域边框线宽，单位px，默认为0（无边框） padding: 5, // 值域内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 值域图形宽度，线性渐变水平布局宽度为该值 * 10 itemHeight: 14, // 值域图形高度，线性渐变垂直布局高度为该值 * 10 splitNumber: 5, // 分割段数，默认为5，为0时为线性渐变 color:['#1e90ff','#f0ffff'],//颜色 //text:['高','低'], // 文本，默认为数值文本 textStyle: &#123; color: '#333' // 值域文字颜色 &#125; &#125;, toolbox: &#123; orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' x: 'right', // 水平安放位置，默认为全图右对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ &#123;number&#125;（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ &#123;number&#125;（y坐标，单位px） color : ['#1e90ff','#22bb22','#4b0082','#d2691e'], backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色 borderColor: '#ccc', // 工具箱边框颜色 borderWidth: 0, // 工具箱边框线宽，单位px，默认为0（无边框） padding: 5, // 工具箱内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemSize: 16, // 工具箱图形宽度 featureImageIcon : &#123;&#125;, // 自定义图片icon featureTitle : &#123; mark : '辅助线开关', markUndo : '删除辅助线', markClear : '清空辅助线', dataZoom : '区域缩放', dataZoomReset : '区域缩放后退', dataView : '数据视图', lineChart : '折线图切换', barChart : '柱形图切换', restore : '还原', saveAsImage : '保存为图片' &#125; &#125;, // 提示框 tooltip: &#123; trigger: 'item', // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis' showDelay: 20, // 显示延迟，添加显示延迟可以避免频繁切换，单位ms hideDelay: 100, // 隐藏延迟，单位ms transitionDuration : 0.4, // 动画变换时间，单位s backgroundColor: 'rgba(0,0,0,0.7)', // 提示背景颜色，默认为透明度为0.7的黑色 borderColor: '#333', // 提示边框颜色 borderRadius: 4, // 提示边框圆角，单位px，默认为4 borderWidth: 0, // 提示边框线宽，单位px，默认为0（无边框） padding: 5, // 提示内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css axisPointer : &#123; // 坐标轴指示器，坐标轴触发有效 type : 'line', // 默认为直线，可选为：'line' | 'shadow' lineStyle : &#123; // 直线指示器样式设置 color: '#48b', width: 2, type: 'solid' &#125;, shadowStyle : &#123; // 阴影指示器样式设置 width: 'auto', // 阴影大小 color: 'rgba(150,150,150,0.3)' // 阴影颜色 &#125; &#125;, textStyle: &#123; color: '#fff' &#125; &#125;, // 区域缩放控制器 dataZoom: &#123; orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' // x: &#123;number&#125;, // 水平安放位置，默认为根据grid参数适配，可选为： // &#123;number&#125;（x坐标，单位px） // y: &#123;number&#125;, // 垂直安放位置，默认为根据grid参数适配，可选为： // &#123;number&#125;（y坐标，单位px） // width: &#123;number&#125;, // 指定宽度，横向布局时默认为根据grid参数适配 // height: &#123;number&#125;, // 指定高度，纵向布局时默认为根据grid参数适配 backgroundColor: 'rgba(0,0,0,0)', // 背景颜色 dataBackgroundColor: '#eee', // 数据背景颜色 fillerColor: 'rgba(144,197,237,0.2)', // 填充颜色 handleColor: 'rgba(70,130,180,0.8)' // 手柄颜色 &#125;, // 网格 grid: &#123; x: 80, y: 60, x2: 80, y2: 60, // width: &#123;totalWidth&#125; - x - x2, // height: &#123;totalHeight&#125; - y - y2, backgroundColor: 'rgba(0,0,0,0)', borderWidth: 1, borderColor: '#ccc' &#125;, // 类目轴 categoryAxis: &#123; position: 'bottom', // 位置 nameLocation: 'end', // 坐标轴名字位置，支持'start' | 'end' boundaryGap: true, // 类目起始和结束两端空白策略 axisLine: &#123; // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#48b', width: 2, type: 'solid' &#125; &#125;, axisTick: &#123; // 坐标轴小标记 show: true, // 属性show控制显示与否，默认不显示 interval: 'auto', // onGap: null, inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#333', width: 1 &#125; &#125;, axisLabel: &#123; // 坐标轴文本标签，详见axis.axisLabel show: true, interval: 'auto', rotate: 0, margin: 8, // formatter: null, textStyle: &#123; // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, splitLine: &#123; // 分隔线 show: true, // 默认显示，属性show控制显示与否 // onGap: null, lineStyle: &#123; // 属性lineStyle（详见lineStyle）控制线条样式 color: ['#ccc'], width: 1, type: 'solid' &#125; &#125;, splitArea: &#123; // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 // onGap: null, areaStyle: &#123; // 属性areaStyle（详见areaStyle）控制区域样式 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] &#125; &#125; &#125;, // 数值型坐标轴默认参数 valueAxis: &#123; position: 'left', // 位置 nameLocation: 'end', // 坐标轴名字位置，支持'start' | 'end' nameTextStyle: &#123;&#125;, // 坐标轴文字样式，默认取全局样式 boundaryGap: [0, 0], // 数值起始和结束两端空白策略 splitNumber: 5, // 分割段数，默认为5 axisLine: &#123; // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#48b', width: 2, type: 'solid' &#125; &#125;, axisTick: &#123; // 坐标轴小标记 show: false, // 属性show控制显示与否，默认不显示 inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#333', width: 1 &#125; &#125;, axisLabel: &#123; // 坐标轴文本标签，详见axis.axisLabel show: true, rotate: 0, margin: 8, // formatter: null, textStyle: &#123; // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, splitLine: &#123; // 分隔线 show: true, // 默认显示，属性show控制显示与否 lineStyle: &#123; // 属性lineStyle（详见lineStyle）控制线条样式 color: ['#ccc'], width: 1, type: 'solid' &#125; &#125;, splitArea: &#123; // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 areaStyle: &#123; // 属性areaStyle（详见areaStyle）控制区域样式 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] &#125; &#125; &#125;, polar : &#123; center : ['50%', '50%'], // 默认全局居中 radius : '75%', startAngle : 90, splitNumber : 5, name : &#123; show: true, textStyle: &#123; // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, axisLine: &#123; // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#ccc', width: 1, type: 'solid' &#125; &#125;, axisLabel: &#123; // 坐标轴文本标签，详见axis.axisLabel show: false, textStyle: &#123; // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, splitArea : &#123; show : true, areaStyle : &#123; color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] &#125; &#125;, splitLine : &#123; show : true, lineStyle : &#123; width : 1, color : '#ccc' &#125; &#125; &#125;, // 柱形图默认参数 bar: &#123; barMinHeight: 0, // 最小高度改为0 // barWidth: null, // 默认自适应 barGap: '30%', // 柱间距离，默认为柱形宽度的30%，可设固定值 barCategoryGap : '20%', // 类目间柱形距离，默认为类目间距的20%，可设固定值 itemStyle: &#123; normal: &#123; // color: '各异', barBorderColor: '#fff', // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125;, emphasis: &#123; // color: '各异', barBorderColor: 'rgba(0,0,0,0)', // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125; &#125; &#125;, // 折线图默认参数 line: &#123; itemStyle: &#123; normal: &#123; // color: 各异, label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, lineStyle: &#123; width: 2, type: 'solid', shadowColor : 'rgba(0,0,0,0)', //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 &#125; &#125;, emphasis: &#123; // color: 各异, label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125; &#125;, //smooth : false, //symbol: null, // 拐点图形类型 symbolSize: 2, // 拐点图形大小 //symbolRotate : null, // 拐点图形旋转控制 showAllSymbol: false // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略） &#125;, // K线图默认参数 k: &#123; // barWidth : null // 默认自适应 // barMaxWidth : null // 默认自适应 itemStyle: &#123; normal: &#123; color: '#fff', // 阳线填充颜色 color0: '#00aa11', // 阴线填充颜色 lineStyle: &#123; width: 1, color: '#ff3200', // 阳线边框颜色 color0: '#00aa11' // 阴线边框颜色 &#125; &#125;, emphasis: &#123; // color: 各异, // color0: 各异 &#125; &#125; &#125;, // 散点图默认参数 scatter: &#123; //symbol: null, // 图形类型 symbolSize: 4, // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 图形旋转控制 large: false, // 大规模散点图 largeThreshold: 2000,// 大规模阀值，large为true且数据量&gt;largeThreshold才启用大规模模式 itemStyle: &#123; normal: &#123; // color: 各异, label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125;, emphasis: &#123; // color: '各异' label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125; &#125; &#125;, // 雷达图默认参数 radar : &#123; itemStyle: &#123; normal: &#123; // color: 各异, label: &#123; show: false &#125;, lineStyle: &#123; width: 2, type: 'solid' &#125; &#125;, emphasis: &#123; // color: 各异, label: &#123; show: false &#125; &#125; &#125;, //symbol: null, // 拐点图形类型 symbolSize: 2 // 可计算特性参数，空数据拖拽提示图形大小 //symbolRotate : null, // 图形旋转控制 &#125;, // 饼图默认参数 pie: &#123; center : ['50%', '50%'], // 默认全局居中 radius : [0, '75%'], clockWise : false, // 默认逆时针 startAngle: 90, minAngle: 0, // 最小角度改为0 selectedOffset: 10, // 选中是扇区偏移量 itemStyle: &#123; normal: &#123; // color: 各异, borderColor: '#fff', borderWidth: 1, label: &#123; show: true, position: 'outer' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, labelLine: &#123; show: true, length: 20, lineStyle: &#123; // color: 各异, width: 1, type: 'solid' &#125; &#125; &#125;, emphasis: &#123; // color: 各异, borderColor: 'rgba(0,0,0,0)', borderWidth: 1, label: &#123; show: false // position: 'outer' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, labelLine: &#123; show: false, length: 20, lineStyle: &#123; // color: 各异, width: 1, type: 'solid' &#125; &#125; &#125; &#125; &#125;, map: &#123; mapType: 'china', // 各省的mapType暂时都用中文 mapLocation: &#123; x : 'center', y : 'center' // width // 自适应 // height // 自适应 &#125;, showLegendSymbol : true, // 显示图例颜色标识（系列标识的小圆点），存在legend时生效 itemStyle: &#123; normal: &#123; // color: 各异, borderColor: '#fff', borderWidth: 1, areaStyle: &#123; color: '#ccc'//rgba(135,206,250,0.8) &#125;, label: &#123; show: false, textStyle: &#123; color: 'rgba(139,69,19,1)' &#125; &#125; &#125;, emphasis: &#123; // 也是选中样式 // color: 各异, borderColor: 'rgba(0,0,0,0)', borderWidth: 1, areaStyle: &#123; color: 'rgba(255,215,0,0.8)' &#125;, label: &#123; show: false, textStyle: &#123; color: 'rgba(139,69,19,1)' &#125; &#125; &#125; &#125; &#125;, force : &#123; // 数据map到圆的半径的最小值和最大值 minRadius : 10, maxRadius : 20, density : 1.0, attractiveness : 1.0, // 初始化的随机大小位置 initSize : 300, // 向心力因子，越大向心力越大 centripetal : 1, // 冷却因子 coolDown : 0.99, // 分类里如果有样式会覆盖节点默认样式 itemStyle: &#123; normal: &#123; // color: 各异, label: &#123; show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, nodeStyle : &#123; brushType : 'both', color : '#f08c2e', strokeColor : '#5182ab' &#125;, linkStyle : &#123; strokeColor : '#5182ab' &#125; &#125;, emphasis: &#123; // color: 各异, label: &#123; show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, nodeStyle : &#123;&#125;, linkStyle : &#123;&#125; &#125; &#125; &#125;, chord : &#123; radius : ['65%', '75%'], center : ['50%', '50%'], padding : 2, sort : 'none', // can be 'none', 'ascending', 'descending' sortSub : 'none', // can be 'none', 'ascending', 'descending' startAngle : 90, clockWise : false, showScale : false, showScaleText : false, itemStyle : &#123; normal : &#123; label : &#123; show : true // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, lineStyle : &#123; width : 0, color : '#000' &#125;, chordStyle : &#123; lineStyle : &#123; width : 1, color : '#666' &#125; &#125; &#125;, emphasis : &#123; lineStyle : &#123; width : 0, color : '#000' &#125;, chordStyle : &#123; lineStyle : &#123; width : 2, color : '#333' &#125; &#125; &#125; &#125; &#125;, island: &#123; r: 15, calculateStep: 0.1 // 滚轮可计算步长 0.1 = 10% &#125;, markPoint : &#123; symbol: 'pin', // 标注类型 symbolSize: 10, // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 标注旋转控制 itemStyle: &#123; normal: &#123; // color: 各异， // borderColor: 各异, // 标注边线颜色，优先于color borderWidth: 2, // 标注边线线宽，单位px，默认为1 label: &#123; show: true, position: 'inside' // 可选为'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125;, emphasis: &#123; // color: 各异 label: &#123; show: true // position: 'inside' // 'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125; &#125; &#125;, markLine : &#123; // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string symbol: ['circle', 'arrow'], // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 symbolSize: [2, 4], // 标线起始和结束的symbol旋转控制 //symbolRotate : null, itemStyle: &#123; normal: &#123; // color: 各异, // 标线主色，线色，symbol主色 // borderColor: 随color, // 标线symbol边框颜色，优先于color borderWidth: 2, // 标线symbol边框线宽，单位px，默认为2 label: &#123; show: false, // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom' position: 'inside', textStyle: &#123; // 默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, lineStyle: &#123; // color: 随borderColor, // 主色，线色，优先级高于borderColor和color // width: 随borderWidth, // 优先于borderWidth type: 'solid', shadowColor : 'rgba(0,0,0,0)', //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 &#125; &#125;, emphasis: &#123; // color: 各异 label: &#123; show: false // position: 'inside' // 'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, lineStyle : &#123;&#125; &#125; &#125; &#125;, textStyle: &#123; decoration: 'none', fontFamily: 'Arial, Verdana, sans-serif', fontFamily2: '微软雅黑', // IE8- 字体模糊并且不支持不同字体混排，额外指定一份 fontSize: 12, fontStyle: 'normal', fontWeight: 'normal' &#125;, // 默认标志图形类型列表 symbolList : [ 'circle', 'rectangle', 'triangle', 'diamond', 'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond' ], loadingText : 'Loading...', // 可计算特性配置，孤岛，提示颜色 calculable: false, // 默认关闭可计算特性 calculableColor: 'rgba(255,165,0,0.6)', // 拖拽提示边框颜色 calculableHolderColor: '#ccc', // 可计算占位提示颜色 nameConnector: ' &amp; ', valueConnector: ' : ', animation: true, animationThreshold: 2500, // 动画元素阀值，产生的图形原素超过2500不出动画 addDataAnimation: true, // 动态数据接口是否开启动画效果 animationDuration: 2000, animationEasing: 'ExponentialOut' //BounceOut&#125;","categories":[],"tags":[{"name":"Echarts","slug":"Echarts","permalink":"https://caicaing.github.io/tags/Echarts/"}]},{"title":"Spring Boot 拦截器","slug":"Spring-Boot-登录拦截器验证","date":"2019-04-12T07:22:03.000Z","updated":"2019-04-12T11:22:33.000Z","comments":true,"path":"2019/04/12/Spring-Boot-登录拦截器验证/","link":"","permalink":"https://caicaing.github.io/2019/04/12/Spring-Boot-登录拦截器验证/","excerpt":"java里的拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在AOP（Aspect-Oriented Programming）中拦截器用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。","text":"java里的拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在AOP（Aspect-Oriented Programming）中拦截器用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。 HandlerInterceptor 接口介绍:在HandlerInterceptor 中有三个方法: 123456789default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true;&#125;default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123;&#125;default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123;&#125; preHandle: 预处理方法,实现处理器的预处理(例如登录状态),handler参数为相应的处理器,返回值:true表示继续流程,false表示流程中断,我们需要通过reponse来产生响应. postHandle：后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。 afterCompletion：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。 配置拦截器:创建拦截器类:123456789101112131415161718192021222324252627282930313233package caicai.springbootinterceptor1.interceptor;import org.springframework.lang.Nullable;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author liu * @title: LoginInterceptor * @projectName spring-boot-interceptor1 * @description: TODO * @date 2019/4/1216:31 */public class LoginInterceptor implements HandlerInterceptor&#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"preHandle.............................\"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; System.out.println(\"postHandle.............................\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; System.out.println(\"afterCompletion.............................\"); &#125;&#125; 创建拦截器配置类:12345678910111213141516171819202122package caicai.springbootinterceptor1.config;import caicai.springbootinterceptor1.interceptor.LoginInterceptor;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * @author liu * @title: LoginInterceptorConfig * @projectName spring-boot-interceptor1 * @description: TODO * @date 2019/4/1216:33 */@Configurationpublic class LoginInterceptorConfig implements WebMvcConfigurer&#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/login\"); &#125;&#125; addPathPatterns(“/**”):表示拦截所有的url请求; excludePathPatterns(“/login”):表示排除login 完成了拦截器配置后,在启动springboot项目的时候,除了login以外,其他所有的请求都会经过拦截器处理,我们可以使用preHandle来完成一个登录验证的功能 登录验证实现:效果:1.有两个界面: 登录界面, 主界面 2:登录界面和主界面都可以通过相应请求跳转到,但是主界面只有登录之后才能查看,否则就跳回登录界面 项目目录: ### index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/login\"&gt; &lt;span&gt;用户名:&lt;/span&gt; &lt;input type=\"text\" name=\"username\"&gt; &lt;span&gt;密码:&lt;/span&gt; &lt;input type=\"text\" name=\"password\"&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; main.html12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这里是主页面&lt;/h1&gt;当前登录用户:&lt;span th:text=\"$&#123;session.username&#125;\"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 如果登录的话 ${session.username}会获取到存贮在session中的用户名 Logininterceptor.java1234567891011121314151617181920212223242526272829303132333435363738394041424344package caicai.springbootinterceptor1.interceptor;import org.springframework.lang.Nullable;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author liu * @title: LoginInterceptor * @projectName spring-boot-interceptor1 * @description: TODO * @date 2019/4/1216:31 */public class LoginInterceptor implements HandlerInterceptor&#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; /** 通过session中的用户名来判断是否登录,因为一旦登录了就会在session中存储用户名 **/ if(request.getSession().getAttribute(\"username\")!=null)&#123; System.out.println(\"登录了\"); return true; &#125;else&#123; System.out.println(\"未登录\"); response.sendRedirect(request.getContextPath()+\"/index\"); return false; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; System.out.println(\"postHandle.............................\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; System.out.println(\"afterCompletion.............................\"); &#125;&#125; LoginController12345678910111213141516171819202122232425262728293031323334353637383940414243444546package caicai.springbootinterceptor1.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;/** * @author liu * @title: LoginController * @projectName spring-boot-interceptor1 * @description: TODO * @date 2019/4/1216:22 */@Controllerpublic class LoginController &#123; /** 登录界面的url映射 **/ @RequestMapping(\"/index\") public String index()&#123; return \"index\"; &#125; /** 登录,此处直接用字符串是否是admin的方式来模拟数据库查询登录 若账号密码正确则跳转到main界面若账号密码错误则继续跳转到登录界面 **/ @RequestMapping(\"/login\") public String login(String username, String password, HttpServletRequest request)&#123; if (username.equals(\"admin\")&amp;&amp; password.equals(\"admin\"))&#123; request.getSession().setAttribute(\"username\",username); return \"main\"; &#125;else &#123; return \"login\"; &#125; &#125; /** 主界面的url映射 为了测试不登陆直接进主页面被拦截 **/ @RequestMapping(\"/main\") public String main()&#123; return \"main\"; &#125;&#125; LoginInterceptorConfig.java:配置文件,配置了拦截器和拦截路径 12345678910111213141516171819202122package caicai.springbootinterceptor1.config;import caicai.springbootinterceptor1.interceptor.LoginInterceptor;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * @author liu * @title: LoginInterceptorConfig * @projectName spring-boot-interceptor1 * @description: TODO * @date 2019/4/1216:33 */@Configurationpublic class LoginInterceptorConfig implements WebMvcConfigurer&#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/login\").excludePathPatterns(\"/index\"); &#125;&#125; 本实例只是粗略的完成了登录拦截的功能,对于一些细节没有完善,例如错误提示等.","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"}]},{"title":"MYSQL随机选择数据","slug":"MYSQL随机选择数据","date":"2019-04-10T08:26:25.000Z","updated":"2019-04-10T08:31:56.000Z","comments":true,"path":"2019/04/10/MYSQL随机选择数据/","link":"","permalink":"https://caicaing.github.io/2019/04/10/MYSQL随机选择数据/","excerpt":"最近在做一个在线考试系统,遇到需要随机选择20道选择题的需求.","text":"最近在做一个在线考试系统,遇到需要随机选择20道选择题的需求. 使用ORDER BY RAND()选择随机记录MySQL没有内置语句来从数据库表中选择随机记录。为了实现这个目的，可使用RAND函数。 以下查询是从数据库表中选择N个随机记录： 123456SELECT *FROM tblORDER BY RAND()LIMIT N; RAND（）函数为表中的每一行生成一个随机值。 ORDER BY子句按照RAND（）函数生成的随机数对表中的所有行进行排序。 这种技术非常适合小表。如果在大的表上执行速度是非常缓慢的，因为MySQL必须排序整个表，以挑选随机的行数据。查询的速度还取决于表中的行数。表具有的行越多，MySQL都要为每行生成随机数，所以所需的时间就越多。","categories":[],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://caicaing.github.io/tags/MYSQL/"}]},{"title":"Jpa 自定义查询语句","slug":"jpa-自定义查询语句","date":"2019-04-10T08:08:39.000Z","updated":"2019-04-10T08:25:30.000Z","comments":true,"path":"2019/04/10/jpa-自定义查询语句/","link":"","permalink":"https://caicaing.github.io/2019/04/10/jpa-自定义查询语句/","excerpt":"在使用Spring Data Jpa框架时，根据业务需求我们通常需要进行复杂的数据库查询，并返回我们自定义的实体类，而在该框架下，目前仅仅支持返回与数据库映射进行持久化的POJO实体。虽然在框架上我们可以使用@Query注解执行我们自定义的sql语句，但是其返回值为List&lt;Object[]&gt; 类型，即多个Object数组的List集合。","text":"在使用Spring Data Jpa框架时，根据业务需求我们通常需要进行复杂的数据库查询，并返回我们自定义的实体类，而在该框架下，目前仅仅支持返回与数据库映射进行持久化的POJO实体。虽然在框架上我们可以使用@Query注解执行我们自定义的sql语句，但是其返回值为List&lt;Object[]&gt; 类型，即多个Object数组的List集合。 @Query()注解通过使@query注解,可以自定义语句进行sql操作 下例为在数据库中查询10个随机的选择题的自定义查询方法: 1234public interface MultipleChoiceRepository extends JpaRepository&lt;MultipleChoice,Long&gt; &#123; @Query(value = \"select * from choice ORDER BY RAND() limit :num\",nativeQuery = true) public List&lt;MultipleChoice&gt; findByNmber(@Param(\"num\") Integer num);&#125; 开启mysql语句1@Query(value = \"\",nativeQuery = true) //nativeQuery= true开启mysql @Modefying()注解如果是删除或修改操作，需要加入此注解进行修饰. 以通知 SpringData， 这是一个 UPDATE 或 DELETE 操作 ；默认情况下，是只读，所以查询不需要 参数传递:@Param()注解使用@Param注解可以给查询语句中注入参数 1@Param(\"num\") Integer num 在sql语句中使用 :参数名 进行调用 使用?占位符123456public interface MultipleChoiceRepository extends JpaRepository&lt;MultipleChoice,Long&gt; &#123; @Query(value = \"select * from choice ORDER BY RAND() limit ?\",nativeQuery = true) public List&lt;MultipleChoice&gt; findByNmber(Integer num);&#125; sql语句中也可以使用?占位符的方式进行参数写入","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot Jpa","slug":"Spring-Boot-Jpa","date":"2019-03-31T13:58:08.000Z","updated":"2019-03-31T14:21:14.000Z","comments":true,"path":"2019/03/31/Spring-Boot-Jpa/","link":"","permalink":"https://caicaing.github.io/2019/03/31/Spring-Boot-Jpa/","excerpt":"全称Java Persistence API，通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。 ​ JPA的出现有两个原因： 其一，简化现有Java EE和Java SE应用的对象持久化的开发工作； 其二，Sun希望整合对ORM技术，实现持久化领域的统一。 ​ JPA提供的技术： 1）ORM映射元数据：JPA支持XML和JDK 5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中； 2）JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。 3）查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。","text":"全称Java Persistence API，通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。 ​ JPA的出现有两个原因： 其一，简化现有Java EE和Java SE应用的对象持久化的开发工作； 其二，Sun希望整合对ORM技术，实现持久化领域的统一。 ​ JPA提供的技术： 1）ORM映射元数据：JPA支持XML和JDK 5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中； 2）JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。 3）查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。 pom.xml中导入依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.caicai&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-jpa&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-jpa&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.caicai.springbootjpa.entity;import javax.persistence.*;/** * @author liu * @title: User * @projectName spring-boot-jpa * @description: TODO * @date 2019/3/3121:14 */@Entitypublic class User &#123; @GeneratedValue(strategy = GenerationType.AUTO)//设置自增长策略 @Id private Integer id; @Column(length = 20,nullable = false) //column可以设置属性 private String name; @Column(length = 20,nullable = true) private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public User() &#123; &#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125;&#125; 创建UserRepository1234567891011121314package com.caicai.springbootjpa.repository;import com.caicai.springbootjpa.entity.User;import org.springframework.data.jpa.repository.JpaRepository;/** * @author liu * @title: UserRepository * @projectName spring-boot-jpa * @description: TODO * @date 2019/3/3121:06 */public interface UserRepository extends JpaRepository&lt;User,Integer&gt;&#123;&#125; 配置数据源和自动建表:12345678910spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/jpa driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: ddl-auto: update show-sql: true 测试类:123456789101112131415161718192021222324package com.caicai.springbootjpa;import com.caicai.springbootjpa.entity.User;import com.caicai.springbootjpa.repository.UserRepository;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootJpaApplicationTests &#123; @Autowired UserRepository userRepository; @Test public void test() &#123; User user = new User(); user.setAge(10); user.setName(\"caicai\"); userRepository.save(user); &#125;&#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot 整合Mybatis(基于注解)","slug":"Spring-Boot-整合Mybatis-基于注解","date":"2019-03-31T12:24:56.000Z","updated":"2019-03-31T12:35:59.000Z","comments":true,"path":"2019/03/31/Spring-Boot-整合Mybatis-基于注解/","link":"","permalink":"https://caicaing.github.io/2019/03/31/Spring-Boot-整合Mybatis-基于注解/","excerpt":"基于注解的Spring Boot 整合Mybatis","text":"基于注解的Spring Boot 整合Mybatis 项目结构 pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.caicai&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-mybatis-annotation&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-mybatis-annotation&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; UserMapper.java12345678910111213141516171819package com.caicai.springbootmybatisannotation.mapper;import com.caicai.springbootmybatisannotation.pojo.User;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;/** * @author liu * @title: UserMapper * @projectName spring-boot-mybatis-annotation * @description: TODO * @date 2019/3/3120:16 */@Mapperpublic interface UserMapper &#123; @Insert(\"insert into users(name,age) values(#&#123;name&#125;,#&#123;age&#125;)\") public void addUser(User user);&#125; User.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.caicai.springbootmybatisannotation.pojo;/** * @author liu * @title: User * @projectName spring-boot-mybatis-annotation * @description: TODO * @date 2019/3/3120:16 */public class User &#123; private Integer id; private String name; private Integer age; public User() &#123; &#125; public User(Integer id, String name, Integer age) &#123; this.id = id; this.name = name; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; application.yml123456spring: datasource: password: 123456 username: root driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm SpringBootMybatisAnnotationApplicationTests.java123456789101112131415161718192021222324package com.caicai.springbootmybatisannotation;import com.caicai.springbootmybatisannotation.mapper.UserMapper;import com.caicai.springbootmybatisannotation.pojo.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootMybatisAnnotationApplicationTests &#123; @Autowired UserMapper userMapper; @Test public void addUser()&#123; User user = new User(); user.setAge(10); user.setName(\"caicai\"); userMapper.addUser(user); &#125;&#125; 对比xml文件配置12@Insert(\"insert into users(name,age) values(#&#123;name&#125;,#&#123;age&#125;)\")public void addUser(User user); @Insert注解的配置就相当于在UserMapper.xml中配置:","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://caicaing.github.io/tags/Mybatis/"}]},{"title":"org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)异常处理","slug":"org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found-异常处理","date":"2019-03-31T05:46:39.000Z","updated":"2019-03-31T05:53:27.000Z","comments":true,"path":"2019/03/31/org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found-异常处理/","link":"","permalink":"https://caicaing.github.io/2019/03/31/org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found-异常处理/","excerpt":"在SpringBoot整合Mybatis出现org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): 错误","text":"在SpringBoot整合Mybatis出现org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): 错误 报错信息:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.caicai.springbootspringmvcmybatis.mapper.UsersMapper.insertUser at org.apache.ibatis.binding.MapperMethod$SqlCommand.&lt;init&gt;(MapperMethod.java:232) ~[mybatis-3.5.0.jar:3.5.0] at org.apache.ibatis.binding.MapperMethod.&lt;init&gt;(MapperMethod.java:50) ~[mybatis-3.5.0.jar:3.5.0] at org.apache.ibatis.binding.MapperProxy.lambda$cachedMapperMethod$0(MapperProxy.java:62) ~[mybatis-3.5.0.jar:3.5.0] at java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1660) ~[na:1.8.0_201] at org.apache.ibatis.binding.MapperProxy.cachedMapperMethod(MapperProxy.java:62) ~[mybatis-3.5.0.jar:3.5.0] at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:57) ~[mybatis-3.5.0.jar:3.5.0] at com.sun.proxy.$Proxy56.insertUser(Unknown Source) ~[na:na] at com.caicai.springbootspringmvcmybatis.service.UserServiceImpl.addUser(UserServiceImpl.java:23) ~[classes/:na] at com.caicai.springbootspringmvcmybatis.service.UserServiceImpl$$FastClassBySpringCGLIB$$3b4656c9.invoke(&lt;generated&gt;) ~[classes/:na] at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:294) ~[spring-tx-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98) ~[spring-tx-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE] at com.caicai.springbootspringmvcmybatis.service.UserServiceImpl$$EnhancerBySpringCGLIB$$c9ef3195.addUser(&lt;generated&gt;) ~[classes/:na] at com.caicai.springbootspringmvcmybatis.controller.UserController.addUser(UserController.java:30) ~[classes/:na] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_201] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_201] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_201] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_201] at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:800) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:908) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200) ~[tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.16.jar:9.0.16] at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.16.jar:9.0.16] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_201] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_201] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.16.jar:9.0.16] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201] 解决经过研究,发现UsersMapper.xml文件在com.caicai.springbootspringmvcmybatis.mapper包里不会被编译,所以考虑在resources里创建一个mapper文件夹,并且在application.yml配置mybatis 123mybatis: type-aliases-package: com.caicai.springbootspringmvcmybatis.pojo mapper-locations: classpath:mapper/*.xml","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://caicaing.github.io/tags/Mybatis/"}]},{"title":"JDBC连接Mysql8.0驱动版本过低报错","slug":"JDBC连接Mysql8-0-11版本出现问题","date":"2019-03-29T13:36:17.000Z","updated":"2019-03-29T13:45:18.000Z","comments":true,"path":"2019/03/29/JDBC连接Mysql8-0-11版本出现问题/","link":"","permalink":"https://caicaing.github.io/2019/03/29/JDBC连接Mysql8-0-11版本出现问题/","excerpt":"JDBC连接Mysql8.0.11版本出现问题,不停循环报错 错误信息如下:","text":"JDBC连接Mysql8.0.11版本出现问题,不停循环报错 错误信息如下: 报错信息:123456789101112131415161718192021222324252627282930313233Fri Mar 29 21:39:01 CST 2019 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.ERROR [Druid-ConnectionPool-Create-2085079540] - create connection SQLException, url: jdbc:mysql://localhost:3306/phone, errorCode 0, state 08001com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server. at sun.reflect.GeneratedConstructorAccessor36.newInstance(Unknown Source) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at com.mysql.jdbc.Util.handleNewInstance(Util.java:404) at com.mysql.jdbc.Util.getInstance(Util.java:387) at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:917) at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:896) at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:885) at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:860) at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2332) at com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2085) at com.mysql.jdbc.ConnectionImpl.&lt;init&gt;(ConnectionImpl.java:795) at com.mysql.jdbc.JDBC4Connection.&lt;init&gt;(JDBC4Connection.java:44) at sun.reflect.GeneratedConstructorAccessor27.newInstance(Unknown Source) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at com.mysql.jdbc.Util.handleNewInstance(Util.java:404) at com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:400) at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:327) at com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1513) at com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1578) at com.alibaba.druid.pool.DruidDataSource$CreateConnectionThread.run(DruidDataSource.java:2451)Caused by: java.lang.NullPointerException at com.mysql.jdbc.ConnectionImpl.getServerCharset(ConnectionImpl.java:3005) at com.mysql.jdbc.MysqlIO.sendConnectionAttributes(MysqlIO.java:1916) at com.mysql.jdbc.MysqlIO.proceedHandshakeWithPluggableAuthentication(MysqlIO.java:1845) at com.mysql.jdbc.MysqlIO.doHandshake(MysqlIO.java:1215) at com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2255) at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2286) ... 12 more 解决方案:Mysql是8.0版本的 ,但是项目中用的jdbc驱动包5.1.31,将jdbc驱动包改为8.0.13后不再报错","categories":[],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://caicaing.github.io/tags/MYSQL/"}]},{"title":"Spring Boot 整合mybatis","slug":"Spring-Boot-整合mybatis","date":"2019-03-29T05:12:22.000Z","updated":"2019-03-31T12:25:19.000Z","comments":true,"path":"2019/03/29/Spring-Boot-整合mybatis/","link":"","permalink":"https://caicaing.github.io/2019/03/29/Spring-Boot-整合mybatis/","excerpt":"Spring Boot 整合mybatis","text":"Spring Boot 整合mybatis 创建项目 pom.xml中添加依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.caicai&lt;/groupId&gt; &lt;artifactId&gt;12-spring-boot-springmvc-mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;12-spring-boot-springmvc-mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建application.yml12345678910spring: datasource: driver-class-name: com.mysql.jdbc.Driver username: root password: 123456 url: jdbc:mysql://localhost:3306/ssm type: com.alibaba.druid.pool.DruidDataSourcemybatis: type-aliases-package: com.caicai.springbootspringmvcmybatis.pojo mapper-locations: classpath:mapper/*.xml 创建Users类1234567891011121314151617181920212223242526272829303132package com.caicai.springbootspringmvcmybatis.pojo;public class Users &#123; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 创建Controller123456789101112131415161718192021222324252627282930313233package com.caicai.springbootspringmvcmybatis.controller;import com.caicai.springbootspringmvcmybatis.pojo.Users;import com.caicai.springbootspringmvcmybatis.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * @author liu * @title: Controller * @projectName 12-spring-boot-springmvc-mybatis * @description: TODO * @date 2019/3/3113:01 */@Controller@RequestMapping(\"/users\")public class UserController &#123; @Autowired private UserService userService; @RequestMapping(\"/&#123;page&#125;\") public String showPage(@PathVariable String page)&#123; return page; &#125; @RequestMapping(\"/addUser\") @ResponseBody public String addUser(Users user)&#123; userService.addUser(user); return \"success\"; &#125;&#125; 创建 UserMapper接口和UsersMapper.xml(创建路径在resources/mapper下)123456789package com.caicai.springbootspringmvcmybatis.mapper;import com.caicai.springbootspringmvcmybatis.pojo.Users;public interface UsersMapper &#123; void insertUser(Users users);&#125; 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.caicai.springbootspringmvcmybatis.mapper.UsersMapper\"&gt; &lt;insert id=\"insertUser\" parameterType=\"users\"&gt; insert into users(name,age) values(#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt; 创建Service1234567891011121314package com.caicai.springbootspringmvcmybatis.service;import com.caicai.springbootspringmvcmybatis.pojo.Users;/** * @author liu * @title: UserService * @projectName 12-spring-boot-springmvc-mybatis * @description: TODO * @date 2019/3/3112:16 */public interface UserService &#123; void addUser(Users users);&#125; 12345678910111213141516171819202122232425package com.caicai.springbootspringmvcmybatis.service;import com.caicai.springbootspringmvcmybatis.mapper.UsersMapper;import com.caicai.springbootspringmvcmybatis.pojo.Users;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;/** * @author liu * @title: UserServiceImpl * @projectName 12-spring-boot-springmvc-mybatis * @description: TODO * @date 2019/3/3112:25 */@Service@Transactionalpublic class UserServiceImpl implements UserService&#123; @Autowired private UsersMapper usersMapper; @Override public void addUser(Users users) &#123; this.usersMapper.insertUser(users); &#125;&#125; 创建page.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=\"@&#123;/users/addUser&#125;\" method=\"post\"&gt;用户姓名&lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt;用户年龄&lt;input type=\"text\" name=\"age\"&gt;&lt;br&gt;&lt;input type=\"submit\" th:value=\"确定\"&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建启动类:123456789101112131415package com.caicai.springbootspringmvcmybatis;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan(\"com.caicai.springbootspringmvcmybatis.mapper\")public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://caicaing.github.io/tags/Mybatis/"}]},{"title":"thymeleaf的整合和使用","slug":"thymeleaf基本语法","date":"2019-03-29T00:03:43.000Z","updated":"2019-03-29T02:06:17.000Z","comments":true,"path":"2019/03/29/thymeleaf基本语法/","link":"","permalink":"https://caicaing.github.io/2019/03/29/thymeleaf基本语法/","excerpt":"Thymeleaf是用于Web和独立环境的现代服务器端Java模板引擎。Thymeleaf的主要目标是将优雅的自然模板带到您的开发工作流程中—HTML能够在浏览器中正确显示，并且可以作为静态原型，从而在开发团队中实现更强大的协作。Thymeleaf能够处理HTML，XML，JavaScript，CSS甚至纯文本。","text":"Thymeleaf是用于Web和独立环境的现代服务器端Java模板引擎。Thymeleaf的主要目标是将优雅的自然模板带到您的开发工作流程中—HTML能够在浏览器中正确显示，并且可以作为静态原型，从而在开发团队中实现更强大的协作。Thymeleaf能够处理HTML，XML，JavaScript，CSS甚至纯文本。 整合thymeleaf修改pom.xml文件,添加依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.caicai&lt;/groupId&gt; &lt;artifactId&gt;10-spring-boot-view-thymeleaf&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;10-spring-boot-view-thymeleaf&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 编写视图:在templates/ 下建立 userList2.html: 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;&lt;head&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\" align=\"center\" width=\"50%\"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"user:$&#123;list&#125;\"&gt; &lt;td th:text=\"$&#123;user.userid&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;user.username&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;user.userage&#125;\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 创建Controller1234567891011121314151617181920212223242526272829package com.caicai.springbootviewfreemarker.controller;import com.caicai.springbootviewfreemarker.pojo.Users;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.ArrayList;import java.util.List;/** * @author liu * @title: UserController * @projectName 08-spring-boot-view-jsp * @description: TODO * @date 2019/3/2820:06 */@Controllerpublic class UserController &#123; @RequestMapping(\"/showuser2\") public String index(Model model)&#123; List&lt;Users&gt; list = new ArrayList&lt;&gt;(); list.add(new Users(1,\"caicai\",21)); list.add(new Users(2,\"honghong\",32)); list.add(new Users(3,\"mingming\",43)); model.addAttribute(\"list\",list); return \"userList2\"; &#125;&#125; 创建Users类:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.caicai.springbootviewfreemarker.pojo;/** * @author liu * @title: Users * @projectName 08-spring-boot-view-jsp * @description: TODO * @date 2019/3/2820:06 */public class Users &#123; private Integer userid; private String username; private Integer userage; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getUserage() &#123; return userage; &#125; public void setUserage(Integer userage) &#123; this.userage = userage; &#125; public Users() &#123; &#125; public Integer getUserid() &#123; return userid; &#125; public void setUserid(Integer userid) &#123; this.userid = userid; &#125; public Users(Integer userid, String username, Integer userage) &#123; this.userid = userid; this.username = username; this.userage = userage; &#125;&#125; 创建启动类12345678910111213package com.caicai.springbootviewfreemarker;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; thymeleaf基本语法:变量输出与字符串操作th:text在页面中输出值 th:value可以将一个值放入到 input 标签的 value 中 判断字符串是否为空Thymeleaf 内置对象注意语法：1，调用内置对象一定要用#2，大部分的内置对象都以 s 结尾 strings、numbers、dates 123456789101112131415161718$&#123;#strings.isEmpty(key)&#125;判断字符串是否为空，如果为空返回 true，否则返回 false$&#123;#strings.contains(msg,&apos;T&apos;)&#125;判断字符串是否包含指定的子串，如果包含返回 true，否则返回 false$&#123;#strings.startsWith(msg,&apos;a&apos;)&#125;判断当前字符串是否以子串开头，如果是返回 true，否则返回 false$&#123;#strings.endsWith(msg,&apos;a&apos;)&#125;判断当前字符串是否以子串结尾，如果是返回 true，否则返回 false$&#123;#strings.length(msg)&#125;返回字符串的长度$&#123;#strings.indexOf(msg,&apos;h&apos;)&#125;查找子串的位置，并返回该子串的下标，如果没找到则返回-1$&#123;#strings.substring(msg,13)&#125;$&#123;#strings.substring(msg,13,15)&#125;截取子串，用户与 jdk String 类下 SubString 方法相同$&#123;#strings.toUpperCase(msg)&#125;$&#123;#strings.toLowerCase(msg)&#125;字符串转大小写。 日期格式化处理12345678910$&#123;#dates.format(key)&#125;格式化日期，默认的以浏览器默认语言为格式化标准$&#123;#dates.format(key,&apos;yyy/MM/dd&apos;)&#125;按照自定义的格式做日期转换$&#123;#dates.year(key)&#125;$&#123;#dates.month(key)&#125;$&#123;#dates.day(key)&#125;year：取年Month：取月Day：取日 条件判断th:if123456&lt;span th:if=\"$&#123;sex&#125; == '男'\"&gt; 性别男&lt;/span&gt;&lt;span th:if=\"$&#123;sex&#125; == '女'\"&gt; 性别女&lt;/span&gt; th:switch12345&lt;span th:switch=\"$&#123;id&#125;\"&gt; &lt;span th:case=\"1\"&gt;ID 为1&lt;/span&gt; &lt;span th:case=\"2\"&gt;ID 为2&lt;/span&gt; &lt;span th:case=\"2\"&gt;ID 为3&lt;/span&gt;&lt;/span&gt; 迭代遍历1234567891011121314&lt;table border=\"1\" align=\"center\" width=\"50%\"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"user:$&#123;list&#125;\"&gt; &lt;td th:text=\"$&#123;user.userid&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;user.username&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;user.userage&#125;\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 12345678910@RequestMapping(\"/index\")public String index(Model model)&#123; List&lt;Users&gt; list = new ArrayList&lt;&gt;(); list.add(new Users(1,\"caicai\",21)); list.add(new Users(2,\"honghong\",32)); list.add(new Users(3,\"mingming\",43)); model.addAttribute(\"list\",list); return \"index\";&#125; 状态变量属性1,index:当前迭代器的索引 从 0 开始2,count:当前迭代对象的计数 从 1 开始3,size:被迭代对象的长度4,even/odd:布尔值，当前循环是否是偶数/奇数 从 0 开始5,first:布尔值，当前循环的是否是第一条，如果是返回 true 否则返回 false6,last:布尔值，当前循环的是否是最后一条，如果是则返回 true 否则返回 false th:each 迭代Map1234567891011121314151617181920212223242526&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"maps : $&#123;map&#125;\"&gt; &lt;td th:text=\"$&#123;maps&#125;\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;th/&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"maps : $&#123;map&#125;\"&gt; &lt;td th:each=\"entry:$&#123;maps&#125;\" th:text=\"$&#123;entry.value.id&#125;\" &gt;&lt;/td&gt; &lt;td th:each=\"entry:$&#123;maps&#125;\" th:text=\"$&#123;entry.value.name&#125;\"&gt;&lt;/td&gt; &lt;td th:each=\"entry:$&#123;maps&#125;\" th:text=\"$&#123;entry.value.age&#125;\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 12345678910@RequestMapping(\"/index3\")public String index3(Model model)&#123; Map&lt;String, User&gt; map = new HashMap&lt;&gt;(); map.put(\"u1\", new User(1,\"张三\",20)); map.put(\"u2\", new User(2,\"李四\",22)); map.put(\"u3\", new User(3,\"王五\",24)); model.addAttribute(\"map\", map); return \"index3\" ;&#125; 域对象操作1234567@RequestMapping(\"/index4\")public String index4(HttpServletRequest httpServletRequest, Model model)&#123; httpServletRequest.setAttribute(\"req\",\"HttpServletRequest\"); httpServletRequest.getSession().setAttribute(\"sess\",\"HttpSession\"); httpServletRequest.getSession().getServletContext().setAttribute(\"app\",\"Application\"); return \"index4\" ;&#125; 12345&lt;body&gt;&lt;span th:text=\"$&#123;#httpServletRequest.getAttribute('req')&#125;\"&gt;&lt;/span&gt;&lt;br&gt;&lt;span th:text=\"$&#123;session.sess&#125;\"&gt;&lt;/span&gt;&lt;br&gt;&lt;span th:text=\"$&#123;application.app&#125;\"&gt;&lt;/span&gt;&lt;br&gt;&lt;/body&gt; URL表达式th:hrefth:src URL表达式语法基本语法：@{} URL类型绝对路径1&lt;a th:href=\"@&#123;http://www.baidu.com&#125;\"&gt;绝对路径&lt;/a&gt;&lt;br/&gt; 相对路径1)相对于当前项目的根相对于项目的上下文的相对路径 1&lt;a th:href=\"@&#123;/show&#125;\"&gt;相对路径&lt;/a&gt; 2) 相对于服务器路径的根 1&lt;a th:href=\"@&#123;~/project2/resourcename&#125;\"&gt;相对于服务器的根&lt;/a&gt; 在 url 中实现参数传递1&lt;a th:href=\"@&#123;/show(id=1,name=zhagnsan)&#125;\"&gt;相对路径-传参&lt;/a&gt; 在 url 中通过 restful 风格进行参数传递12&lt;a th:href=\"@&#123;/path/&#123;id&#125;/show(id=1,name=zhagnsan)&#125;\"&gt; 相 对 路 径 - 传 参-restful&lt;/a&gt;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://caicaing.github.io/tags/thymeleaf/"}]},{"title":"Spring Boot 整合Freemarker","slug":"Spring-Boot-整合Freemarker","date":"2019-03-28T11:44:26.000Z","updated":"2019-03-29T00:08:55.000Z","comments":true,"path":"2019/03/28/Spring-Boot-整合Freemarker/","link":"","permalink":"https://caicaing.github.io/2019/03/28/Spring-Boot-整合Freemarker/","excerpt":"FreeMarker 是一个模板引擎，一个基于模板生成文本输出的通用工具，使用纯 Java 编写，FreeMarker 被设计用来生成 HTML Web 页面，特别是基于 MVC 模式的应用程序，虽然 FreeMarker 具有一些编程的能力，但通常由 Java 程序准备要显示的数据，由FreeMarker 生成页面，通过模板显示准备的数据。符合MVC模式，采用哈希表存储，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据","text":"FreeMarker 是一个模板引擎，一个基于模板生成文本输出的通用工具，使用纯 Java 编写，FreeMarker 被设计用来生成 HTML Web 页面，特别是基于 MVC 模式的应用程序，虽然 FreeMarker 具有一些编程的能力，但通常由 Java 程序准备要显示的数据，由FreeMarker 生成页面，通过模板显示准备的数据。符合MVC模式，采用哈希表存储，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据 整合Freemarker创建maven项目,添加依赖12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写视图在templates/ 下建立 userList.ftl: 12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;显示用户数据&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=\"1\" align=\"center\" width=\"50%\"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;#list list as user&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.userid&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.username&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.userage&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 创建Controller123456789101112131415161718192021222324252627282930313233package com.caicai.springbootviewfreemarker.controller;import com.caicai.springbootviewfreemarker.pojo.Users;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.ArrayList;import java.util.List;/** * @author liu * @title: UserController * @projectName 08-spring-boot-view-jsp * @description: TODO * @date 2019/3/2820:06 */@Controllerpublic class UserController &#123; /** * 处理请求 产生数据 */ @RequestMapping(\"/showuser\") public String showUser(Model model)&#123; List&lt;Users&gt; list = new ArrayList&lt;&gt;(); list.add(new Users(1,\"caicai\",21)); list.add(new Users(2,\"honghong\",32)); list.add(new Users(3,\"mingming\",43)); model.addAttribute(\"list\",list); return \"userList\"; &#125;&#125; 创建Uesrs类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.caicai.springbootviewfreemarker.pojo;/** * @author liu * @title: Users * @projectName 08-spring-boot-view-jsp * @description: TODO * @date 2019/3/2820:06 */public class Users &#123; private Integer userid; private String username; private Integer userage; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getUserage() &#123; return userage; &#125; public void setUserage(Integer userage) &#123; this.userage = userage; &#125; public Users() &#123; &#125; public Integer getUserid() &#123; return userid; &#125; public void setUserid(Integer userid) &#123; this.userid = userid; &#125; public Users(Integer userid, String username, Integer userage) &#123; this.userid = userid; this.username = username; this.userage = userage; &#125;&#125; 创建启动类12345678910111213package com.caicai.springbootviewfreemarker;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot 整合jsp","slug":"Spring-Boot-整合jsp","date":"2019-03-28T05:13:02.000Z","updated":"2019-03-28T10:29:32.000Z","comments":true,"path":"2019/03/28/Spring-Boot-整合jsp/","link":"","permalink":"https://caicaing.github.io/2019/03/28/Spring-Boot-整合jsp/","excerpt":"Spring Boot 整合jsp","text":"Spring Boot 整合jsp 创建maven项目,添加pom依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.caicai&lt;/groupId&gt; &lt;artifactId&gt;08-spring-boot-view-jsp&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;08-spring-boot-view-jsp&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- tomcat支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jstl标签库 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建SpringBoot全局配置application.yml: 12345spring: mvc: view: prefix: /WEB-INF/jsp/ suffix: .jsp 创建Users类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.caicai.springbootviewjsp.pojo;/** * @author liu * @title: Users * @projectName 08-spring-boot-view-jsp * @description: TODO * @date 2019/3/2813:16 */public class Users &#123; private Integer userid; private String username; private Integer userage; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getUserage() &#123; return userage; &#125; public void setUserage(Integer userage) &#123; this.userage = userage; &#125; public Users() &#123; &#125; public Integer getUserid() &#123; return userid; &#125; public void setUserid(Integer userid) &#123; this.userid = userid; &#125; public Users(Integer userid, String username, Integer userage) &#123; this.userid = userid; this.username = username; this.userage = userage; &#125;&#125; 创建Controller123456789101112131415161718192021222324252627282930313233package com.caicai.springbootviewjsp.controller;import com.caicai.springbootviewjsp.pojo.Users;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.ArrayList;import java.util.List;/** * @author liu * @title: UserController * @projectName 08-spring-boot-view-jsp * @description: TODO * @date 2019/3/2813:15 */@Controllerpublic class UserController &#123; /** * 处理请求 产生数据 */ @RequestMapping(\"/showuser\") public String showUser(Model model)&#123; List&lt;Users&gt; list = new ArrayList&lt;&gt;(); list.add(new Users(1,\"caicai\",21)); list.add(new Users(2,\"honghong\",32)); list.add(new Users(3,\"mingming\",43)); model.addAttribute(\"list\",list); return \"userList\"; &#125;&#125; 创建jspuserList.jsp: 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" align=\"center\" width=\"50%\"&gt; &lt;tr&gt; &lt;th&gt;ID:&lt;/th&gt; &lt;th&gt;姓名:&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;list&#125;\" var=\"user\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.userid&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.username&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.userage&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 创建启动类:12345678910111213package com.caicai.springbootviewjsp;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 效果图:","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"}]},{"title":"Spring-Boot-文件上传","slug":"Spring-Boot-文件上传","date":"2019-03-27T10:57:12.000Z","updated":"2019-03-28T10:29:48.000Z","comments":true,"path":"2019/03/27/Spring-Boot-文件上传/","link":"","permalink":"https://caicaing.github.io/2019/03/27/Spring-Boot-文件上传/","excerpt":"Spring-Boot-文件上传","text":"Spring-Boot-文件上传 编写Controller12345678910111213141516171819202122232425262728293031package com.caicai.springbootstaticresources1.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;/** * @author liu * @title: FileController * @projectName 05-spring-boot-static-resources1 * @description: TODO * @date 2019/3/2719:04 */@RestControllerpublic class FileController &#123; @RequestMapping(value = \"/fileUploadController\") public String fileUpload(@RequestParam(\"filename\") MultipartFile file)&#123; System.out.println(file.getName()); try &#123; file.transferTo(new File(\"F:/\"+file.getName())); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return \"success\"; &#125;&#125; 编写上传界面为了方便在static文件夹下建立upload.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"fileUploadController\" method=\"post\" enctype=\"multipart/form-data\"&gt; 上传文件:&lt;input type=\"file\" name=\"filename\"&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 设置上传文件大小的默认值在resources下建立application.yml文件 123456spring: servlet: multipart: max-file-size: 10MB #设置单个上传文件的大小 max-request-size: 100MB #设置一次请求上传文件的总容量 enabled: true","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"}]},{"title":"Spring-Boot 整合Servlet和Filter","slug":"Spring-Boot-整合Servlet","date":"2019-03-27T10:09:56.000Z","updated":"2019-03-28T10:29:20.000Z","comments":true,"path":"2019/03/27/Spring-Boot-整合Servlet/","link":"","permalink":"https://caicaing.github.io/2019/03/27/Spring-Boot-整合Servlet/","excerpt":"Spring-Boot 整合Servlet和Filter","text":"Spring-Boot 整合Servlet和Filter 整合Servlet传统方式配置12345678910&lt;servlet&gt;&lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt;&lt;servlet-class&gt;com.caicai.springbootservlet.filter.FirstFilter&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/first&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 通过注解扫描注册Servlet使用@WebServlet注解并在启动类上使用@ServletComponentScan注解 1234567@WebServlet(name = \"FirstServlet\",urlPatterns = \"/first\")public class FirstServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"FirstServlet.....\"); &#125;&#125; 123456789@SpringBootApplication@ServletComponentScan //在SpringBoot启动时会扫描@WebServlet注解 并将该类实例化public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 通过方法完成Servlet组件的注册通过使用@Bean注解的形式注册组件 123456public class SecondServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"SecondServlet.....\"); &#125;&#125; 12345678910111213@SpringBootApplicationpublic class App2 &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; @Bean public ServletRegistrationBean getServletRegistrationBean() &#123; ServletRegistrationBean bean = new ServletRegistrationBean(new SecondServlet()); bean.addUrlMappings(\"/second\");//添加url路径 return bean; &#125;&#125; 整合Filter传统方式配置12345678&lt;filter&gt;&lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;&lt;filter-class&gt;com.caicai.springbootservlet.filter.FirstFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;&lt;url-pattern&gt;/filter1&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 通过注解扫描注册Servlet1234567891011121314151617181920212223242526272829303132333435package com.caicai.springbootservlet.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;/** * @author liu * @title: FirstFilter * @projectName 02-spring-boot-servlet * @description: TODO * @date 2019/3/2718:19 *///@WebFilter(filterName = \"\",urlPatterns =&#123;\"*.do\",\"*.jsp\"&#125;)@WebFilter(filterName = \"FirstFilter\",urlPatterns =\"/filter1\")public class FirstFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(\"init.......\"); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"进入filter.......\"); filterChain.doFilter(servletRequest,servletResponse); System.out.println(\"离开filter.......\"); &#125; @Override public void destroy() &#123; System.out.println(\"destroy.......\"); &#125;&#125; 启动类: 1234567891011121314package com.caicai.springbootservlet;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletComponentScan;@SpringBootApplication@ServletComponentScan //在SpringBoot启动时会扫描@WebServlet注解 并将该类实例化public class App3 &#123; public static void main(String[] args) &#123; SpringApplication.run(App3.class, args); &#125;&#125; 通过方法完成Filter的注册12345678910111213141516171819202122232425262728293031323334package com.caicai.springbootservlet.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;/** * @author liu * @title: SecondFilter * @projectName 02-spring-boot-servlet * @description: TODO * @date 2019/3/2718:19 */public class SecondFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(\"init.......\"); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"进入filter2.......\"); filterChain.doFilter(servletRequest,servletResponse); System.out.println(\"离开filter2.......\"); &#125; @Override public void destroy() &#123; System.out.println(\"destroy.......\"); &#125;&#125; 1234567891011121314151617181920212223package com.caicai.springbootservlet;import com.caicai.springbootservlet.filter.SecondFilter;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;@SpringBootApplicationpublic class App4 &#123; public static void main(String[] args) &#123; SpringApplication.run(App4.class, args); &#125; @Bean public FilterRegistrationBean filterRegistrationBean()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(new SecondFilter()) ; bean.addUrlPatterns(\"/filter2\"); return bean; &#125;&#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"},{"name":"Servlet","slug":"Servlet","permalink":"https://caicaing.github.io/tags/Servlet/"}]},{"title":"String，StringBuilder，StringBuffer三者的区别","slug":"string相关","date":"2019-03-26T09:04:13.000Z","updated":"2019-03-28T10:35:09.000Z","comments":true,"path":"2019/03/26/string相关/","link":"","permalink":"https://caicaing.github.io/2019/03/26/string相关/","excerpt":"最近突然被问起String，StringBuilder，StringBuffer三者的区别,发现自己确实对这方面的知识不是很了解.所以学习了一下做个笔记.","text":"最近突然被问起String，StringBuilder，StringBuffer三者的区别,发现自己确实对这方面的知识不是很了解.所以学习了一下做个笔记. String String 类是一个常量，String类本身和其中存储字符的数组都是用final关键字修饰的,所以不能被继承 12/** The value is used for character storage. */private final char value[]; String str=”hello world”和String str=new String(“hello world”)的区别123456789101112public class Main &#123; public static void main(String[] args) &#123; String string1 = \"hello word\"; String string2 = new String(\"hello world\"); String string3 = \"hello word\"; String string4 = new String(\"hello world\"); System.out.println(string1 == string2); System.out.println(string1 == string3); System.out.println(string2 == string4); &#125;&#125; 上面代码的输出结果为: false true false 我们发现 同样都都是”helllo world” string1 和 string3 相等.是因为string1 和 string3 都是赋值为一个字面常量”hello world”,在JVM运行时候,会在常量池里寻找是否已经存在相同的常量,如果存在便直接将引用指向已有常量,否则就创建一个常量,并且将引用指向他,对于string2 和string4来说,两者都是采取了new 来创建的,是两个不同的对象,所以不相等. StringBuilder在第二点中,我们看到String是一个final类,打开StringBuilder,我们发现StringBuilder类是AbstractStringBuilder的子类,在AbstractStringBuilder类中,我们看到与String不同,StringBuilder存储字符的数组是可变的 1234/** * The value is used for character storage. */ char[] value; StringBuilder和String 区别对于实际应用来说 假设有如下代码 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; String string = \"\"; for (int i = 0; i &lt; 1000; i++) &#123; string += \"A\"; &#125; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; 1000; i++) &#123; stringBuilder.append(\"A\"); &#125; &#125;&#125; 上述代码进行了一个1000次的循环,每次在字符串string后面追加一个字符A,无论使用的是String,还是StringBuilder,最后的结果都为长度为1000的字符全为A的字符串.而不同的是,如果使用StringBuilder,append操作是在原有的对象基础上进行的,而使用String每次循环都会新建一个StringBuilder对象,进行append操作,通过toString方法返回String对象,如果这些对象没有被回收会浪费大量资源, StringBuilder和StringBuffer区别对比StringBuilder和StringBuffer源码,我们发现在StringBuffer中很多方法都加上了synchronized关键字,所以StringBuffer是线程安全的,不过相应的,在提升了安全的同时对资源的消耗也会增大 12345678910111213141516171819/** * StringBuffer append方法 */@Overridepublic synchronized StringBuffer append (String str)&#123; toStringCache = null; super.append(str); return this;&#125;/** * StringBuilder append方法 */@Overridepublic StringBuilder append (String str)&#123; super.append(str); return this;&#125; 结论三个类应当根据不同的情况来进行选择使用： 当字符串相加操作或者改动较少的情况下，建议使用 String str=”hello”这种形式 当字符串相加操作较多的情况下，建议使用StringBuilder 如果采用了多线程，则使用StringBuffer。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://caicaing.github.io/tags/java/"},{"name":"String","slug":"String","permalink":"https://caicaing.github.io/tags/String/"}]},{"title":"swagger2","slug":"swagger2","date":"2019-03-18T23:39:19.000Z","updated":"2019-10-07T09:15:01.018Z","comments":true,"path":"2019/03/19/swagger2/","link":"","permalink":"https://caicaing.github.io/2019/03/19/swagger2/","excerpt":"Swagger 是一款RESTFUL接口的、基于YAML、JSON语言的文档在线自动生成、代码自动生成的工具。","text":"Swagger 是一款RESTFUL接口的、基于YAML、JSON语言的文档在线自动生成、代码自动生成的工具。 关于SwaggerSwagger能成为最受欢迎的REST APIs文档生成工具之一，有以下几个原因： Swagger 可以生成一个具有互动性的API控制台，开发者可以用来快速学习和尝试API。 Swagger 可以生成客户端SDK代码用于各种不同的平台上的实现。 Swagger 文件可以在许多不同的平台上从代码注释中自动生成。 Swagger 有一个强大的社区，里面有许多强悍的贡献者。 Swagger 文档提供了一个方法，使我们可以用指定的 JSON 或者 YAML 摘要来描述你的 API，包括了比如 names、order 等 API 信息。 你可以通过一个文本编辑器来编辑 Swagger 文件，或者你也可以从你的代码注释中自动生成。各种工具都可以使用 Swagger 文件来生成互动的 API 文档。 注意：用 Swagger 文件生成互动的 API 文档是最精简的，它展示了资源、参数、请求、响应。但是它不会提供你的API如何工作的其他任何一个细节。 Spring Boot集成使用Swagger创建Spring Boot Web工程并且引入Swagger依赖所需Swagger依赖可以在Maven仓库 中找查询 12345678910111213&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 创建User实体类12345678910111213141516171819202122232425262728293031323334353637package com.example.demo.domain;/** * @author liu * @title: User * @projectName demo * @description: TODO * @date 2019/3/1821:52 */public class User &#123; private Long id; private String username; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", username='\" + username + '\\'' + '&#125;'; &#125;&#125; 在启动类目录创建Swagger2配置类1234567891011121314151617181920212223242526272829303132package com.example.demo;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.example.demo.controller\"))//扫描controller下的包 .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"Spring Boot中使用Swagger2构建RESTful APIs\") .description(\"swagger2 构建APIS\") .version(\"1.0\") .build(); &#125;&#125; 创建UserController类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.example.demo.controller;import com.example.demo.domain.User;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @author liu * @title: HelloController * @projectName demo * @description: TODO * @date 2019/3/1821:48 */@RestController@Api(tags = \"用户模块\")@RequestMapping(value = \"/user\")public class UserController &#123; /** * 此处为了方便直接用一个Map来模拟数据库进行操作 */ static Map&lt;Long, User&gt; userMap; static &#123; userMap = new HashMap&lt;&gt;(); User user = new User(); user.setId((long) 10000); user.setUsername(\"admin\"); userMap.put((long) 10000,user); &#125; @ApiOperation(value = \"获取用户列表\") @RequestMapping(value = \"list\", method = RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; return new ArrayList&lt;User&gt;(userMap.values()); &#125; @ApiOperation(value = \"创建用户\") @ApiImplicitParams(&#123;@ApiImplicitParam(paramType = \"query\", name = \"id\", dataType = \"Long\", required = true, value = \"用户id\", defaultValue = \"10001\"), @ApiImplicitParam(paramType = \"query\", name = \"username\", dataType = \"String\", required = true, value = \"用户名字\", defaultValue = \"菜菜\") &#125;) @RequestMapping(value = \"\", method = RequestMethod.POST) public String postUser(User user) &#123; userMap.put(user.getId(),user); return \"添加成功\"; &#125; @ApiOperation(value = \"获取用户\") @ApiImplicitParam(paramType = \"query\", required = true, name = \"id\", dataType = \"Long\", value = \"用户id\") @RequestMapping(value = \"\", method = RequestMethod.GET) public User getUser(@RequestParam(\"id\") Long id) &#123; System.out.println(id); return userMap.get(id); &#125; @ApiOperation(value = \"更新用户\") @ApiImplicitParams(&#123;@ApiImplicitParam(paramType = \"query\", name = \"id\", dataType = \"Long\", required = true, value = \"用户id\", defaultValue = \"10001\"), @ApiImplicitParam(paramType = \"query\", name = \"username\", dataType = \"String\", required = true, value = \"用户名字\", defaultValue = \"菜菜\") &#125;) @RequestMapping(value = \"\", method = RequestMethod.PUT) public String putUser(User user) &#123; userMap.put(user.getId(),user); return \"更新成功\"; &#125; @ApiOperation(value = \"删除用户\") @ApiImplicitParam(paramType = \"query\", required = true, name = \"id\", dataType = \"Long\", value = \"用户id\") @RequestMapping(value = \"\", method = RequestMethod.DELETE) public String deleteUser(@RequestParam(\"id\") Long id) &#123; userMap.remove(id); return \"删除成功\"; &#125;&#125; 测试:主界面: 查询用户列表: 创建用户: 获取用户: 删除用户: 使用过程中遇到的问题(1)java.lang.NumberFormatException: For input string: “” 在使用@ApiModelProperty注解在字段上时，如果字段的类型为Long或是int类型，那么程序启动后，访问swagger-ui.html的页面，程序会报错 java.lang.NumberFormatException: For input string: “”在swagger的官方文档中介绍是一个bug；可以忽略这个错误，如果看着不爽，可以调整日志的级别 application.yml: 123logging: level: io.swagger.models.parameters.AbstractSerializableParameter: error (2)@Api()注解中使用tags = “”参数才能改变api名字 例如@Api(tags = “用户模块”) (3)requestparam 和pathvariable区别 : @PathVariable:从路径路去获取变量,也就是把路径名当作变量 例如: 1http://localhost:8080/user?id=5 @RequestParam:从请求里面获取参数,例如: 1http://localhost:8080/user?5","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"},{"name":"swagger","slug":"swagger","permalink":"https://caicaing.github.io/tags/swagger/"}]},{"title":"mysql的时区错误问题： The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one","slug":"mysql的时区错误问题：-The-server-time-zone-value-OÐ¹u±e×¼E±¼a-is-unrecognized-or-represents-more-than-one","date":"2019-03-18T07:38:01.000Z","updated":"2019-03-28T10:24:34.000Z","comments":true,"path":"2019/03/18/mysql的时区错误问题：-The-server-time-zone-value-OÐ¹u±e×¼E±¼a-is-unrecognized-or-represents-more-than-one/","link":"","permalink":"https://caicaing.github.io/2019/03/18/mysql的时区错误问题：-The-server-time-zone-value-OÐ¹u±e×¼E±¼a-is-unrecognized-or-represents-more-than-one/","excerpt":"链接数据库时候出现cexception is org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException:","text":"链接数据库时候出现cexception is org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: spring boot 链接数据库的时候报错1234567891011cexception is org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Connections could not be acquired from the underlying database!### The error may exist in com/wj/mapper/UserLoginMapper.xml### The error may involve com.wj.mapper.UserLoginMapper.selectByName### The error occurred while executing a query### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Connections could not be acquired from the underlying database! org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:982) org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872) javax.servlet.http.HttpServlet.service(HttpServlet.java:650) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) javax.servlet.http.HttpServlet.service(HttpServlet.java:731) 1234567891011121314151617181920java.sql.SQLException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:127) com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:95) com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:87) com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:61) com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:71) com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:76) com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:862) com.mysql.cj.jdbc.ConnectionImpl.&lt;init&gt;(ConnectionImpl.java:444) com.mysql.cj.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:230) com.mysql.cj.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:226) com.mchange.v2.c3p0.DriverManagerDataSource.getConnection(DriverManagerDataSource.java:175) com.mchange.v2.c3p0.WrapperConnectionPoolDataSource.getPooledConnection(WrapperConnectionPoolDataSource.java:220) com.mchange.v2.c3p0.WrapperConnectionPoolDataSource.getPooledConnection(WrapperConnectionPoolDataSource.java:206) com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool$1PooledConnectionResourcePoolManager.acquireResource(C3P0PooledConnectionPool.java:203) com.mchange.v2.resourcepool.BasicResourcePool.doAcquire(BasicResourcePool.java:1138) com.mchange.v2.resourcepool.BasicResourcePool.doAcquireAndDecrementPendingAcquiresWithinLockOnSuccess(BasicResourcePool.java:1125) com.mchange.v2.resourcepool.BasicResourcePool.access$700(BasicResourcePool.java:44) com.mchange.v2.resourcepool.BasicResourcePool$ScatteredAcquireTask.run(BasicResourcePool.java:1870) com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread.run(ThreadPoolAsynchronousRunner.java:696) 解决方案:据查询是因为电脑的时区和mysql的时区不一样导致的用 打开mysql 12show variables like '%time_zone%'; //查询mysql的时区set global time_zone='+8:00'; //设置时区","categories":[],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://caicaing.github.io/tags/MYSQL/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://caicaing.github.io/tags/Spring-Boot/"}]},{"title":"navicat 连接 mysql   Client does not support authentication protocol requested by server","slug":"navicat-连接-mysql-Client-does-not-support-authentication-protocol-requested-by-server","date":"2019-03-18T07:35:38.000Z","updated":"2019-03-28T10:30:03.000Z","comments":true,"path":"2019/03/18/navicat-连接-mysql-Client-does-not-support-authentication-protocol-requested-by-server/","link":"","permalink":"https://caicaing.github.io/2019/03/18/navicat-连接-mysql-Client-does-not-support-authentication-protocol-requested-by-server/","excerpt":"Client does not support authentication protocol requested by server; consider upgrading MySQL client","text":"Client does not support authentication protocol requested by server; consider upgrading MySQL client 报错信息:1Client does not support authentication protocol requested by server; consider upgrading MySQL client 解决方案:打开mysql的MySQL Command Line Client 输入:123USE mysql;ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;FLUSH PRIVILEGES; localhost:本机地址123456:要设置的密码","categories":[],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://caicaing.github.io/tags/MYSQL/"}]},{"title":"hexo 常用命令","slug":"hexo-常用命令","date":"2019-03-18T06:59:30.000Z","updated":"2019-03-28T10:26:07.000Z","comments":true,"path":"2019/03/18/hexo-常用命令/","link":"","permalink":"https://caicaing.github.io/2019/03/18/hexo-常用命令/","excerpt":"hexo 的一些常用命令","text":"hexo 的一些常用命令 hexo123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署 两个命令的作用是相同的hexo generate --deployhexo deploy --generate 12hexo deploy -g``hexo server -g 草稿1hexo publish [layout] &lt;title&gt; 模版hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub 123hexo new [layout] &lt;title&gt;``hexo new photo &quot;My Gallery&quot;``hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 12345678title: 使用Hexo搭建个人博客layout: postdate: 2019-03-18 14:59:30comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）1hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要1以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作12hexo new page &lt;title&gt;``hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上123hexo n` #写文章`hexo g` #生成`hexo d` #部署 #可与`hexo g`合并为 `hexo d -g 报错1.找不到git部署1ERROR Deployer not found: git 解决方法 1npm install hexo-deployer-git --save 3.部署类型设置githexo 3.0 部署类型不再是github，_config.yml 中修改 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master 4. xcodebuildxcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance 1npm install bcrypt 5. RSS不显示安装RSS插件1npm install hexo-generator-feed --save 开启RSS功能编辑hexo/_config.yml，添加如下代码： 1rss: /atom.xml #rss地址 默认即可","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://caicaing.github.io/tags/hexo/"}]}]}