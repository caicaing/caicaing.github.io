[{"title":"docker安装mysql","url":"/2019/07/15/docker安装mysql/","content":"\n\n\n使用使用docker 安装mysql,并且进行远程访问连接\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 实验环境\n\n+ centos7.3\n+ docker\n+ mysql-8.0.16.0\n\n## 实验步骤\n\n### 升级yum\n\n```shell\nyum update -y\n```\n\n### 安装docker\n\n```shell\nyum install docker -y\n```\n\n### 启动docker\n\n```shell\nsystemctl start docker  # 启动\nsystemctl enable docker # 设置开机启动\n```\n\n### 查找mysql镜像\n\n```shell\ndocker search mysql\n```\n\n### 拉取mysql镜像\n\n```shell\ndocker pull mysql #默认为下载最新版\n```\n\n### 查看mysql镜像\n\n```shell\ndocker images\n```\n\n### 启动mysql\n\n```shell\n docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql\n```\n\n（参数 -p 设置端口，--name 取名 ，-e MYSQL_ROOT_PASSWORD=123456 设置 账号为 root ，密码为 123456  -d 表示作为一个守护进程在后台运行 ）\n\n### 查看运行中的容器\n\n```shell\ndocker ps  \n```\n\n![2](docker安装mysql/2.jpg)\n\n## 远程连接mysql及错误解决\n\n在上文中,我们已经创建了一个mysql容器,在连接过程中使用navicat报错错误信息如下:\n\n![1](docker安装mysql/1.jpg)\n\n为了对mysql进行操作首先要进入docker中的mysql\n\n```shell\ndocker exec -it mysql bash\n```\n\n登录mysql\n\n```shell\nmysql -u root -p\n```\n\n执行sql语句\n\n```shell\nALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '你的密码';\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码';\n```\n\n执行后再次连接,连接成功\n\n\n\n\n\n\n\n","tags":["docker","mysql"]},{"title":"SpringBoot+ajax跨域请求","url":"/2019/07/11/SpringBoot-ajax跨域请求/","content":"\n\n\n在使用ajax请求SpringBoot + SpringSecurity后端时遇到的一些坑。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 不集成SpringSecurity的情况下进行跨域访问\n\n### 错误信息\n\n在使用ajax请求后端的时候在浏览器控制台会输出如下信息：\n\n```java\nAccess to XMLHttpRequest at 'http://localhost:8080/test' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n```\n\n从源'本地路径'访问 '目标路径(请求链接)'文本传输请求已被CORS策略阻塞:对预置请求的响应未通过访问控制检查:请求的资源上不存在'Access- control - allow - origin '报头。\n\n### 错误原因\n\n本地路径和目标路径不是同一个域名下引起的跨域问题\n\n### 解决方案\n\n在对应的Controller类前上@CrossOrigin注解\n\n例如：\n\n```java\npackage com.example.demo.controller;\n\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @program: demo\n * @description:\n * @author: liu\n * @create: 2019-07-11 18:14\n **/\n@RestController\n@CrossOrigin\npublic class TestController {\n  \n    @PostMapping(\"/testPost\")\n    public String testPost() {\n        System.out.println(\"testPost成功\");\n        return \"testPost跨域请求成功\";\n    }\n  \n    @GetMapping(\"/testGet\")\n    public String testGet() {\n        System.out.println(\"testGet成功\");\n        return \"testGet跨域请求成功\";\n    }\n}\n\n```\n\n\n\n## 集成SpringSecurity的情况下进行跨域访问\n\n### 错误信息\n\n集成SpringSecurity后get请求正常，但是对于post请求仍然会显示错误信息\n\n```java\njquery.min.js:4 POST http://localhost:8080/testPost 403\nlist_student.html:1 Access to XMLHttpRequest at 'http://localhost:8080/testPost' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n```\n\n### 解决方案\n\n添加WebSecurityConfiguration配置文件可关闭csrf\n\n```java\npackage com.example.demo;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled = true)\n@Order(-1)\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n//        http.requestMatchers().antMatchers(HttpMethod.OPTIONS, \"/oauth/**\",\"/login/**\",\"/logout/**\")\n//            .and()\n//            .authorizeRequests()\n//            .antMatchers().permitAll()\n//            .and()\n//            .formLogin().permitAll(); //新增login form 支持用户登录及授权\n\n        http.requestMatchers().antMatchers(HttpMethod.OPTIONS, \"/oauth/**\")\n                .and()\n                .cors()\n                .and()\n                .csrf().disable();\n    }\n}\n```\n\n\n\n\n\n\n\n","tags":["SpringBoot","ajax"]},{"title":"SpringBoot整合Activiti7使用","url":"/2019/07/10/SpringBoot整合Activiti7使用/","content":"\n <Excerpt in index | 首页摘要>\n\n最近做的一个项目中需要实现员工请假的功能，计划使用activiti来实现请假流程，所以去学习了一下相关的知识。并且完成了一个简单的请假实例。\n\n<!-- more -->\n\n<The rest of contents | 余下全文>\n\n\n\n# Activiti相关\n\n## Activiti介绍\n\nActiviti是基于Apache许可的开源BPM平台，创始人Tom Baeyens原是JBPM架构师，可以理解为与JBPM出自同一祖师爷。它提供了Eclipse插件，开发可以通过插件直接绘制业务流程图。基于Spring，ibatis等框架，并在此之上构建了非常清晰的开发框架。是由Alfresco软件发布的业务流程管理（BPM）框架，它是覆盖了业务流程管理、工作流、服务协作等领域的一个开源的、灵活的、易扩展的可执行流程语言框架。 本文基于Activiti7的Activiti Core，基于Spring Boot做简单学习总结。\n\n\n\n## Acticiti核心类介绍\n\n### ProcessEngine\n\n流程引擎的抽象，可以通过此类获取需要的所有服务。\n\n### Service类\n\n  通过ProcessEngine获取，Activiti将不同生命周期的服务封装在不同Service中，包括定义、部署、运行。通过服务类可获取相关生命周期中的服务信息。\n\n#### taskService\n\n流程运行过程中，每个任务节点的相关操作接口，如complete,delete,delegate等。\n\n#### RepositoryService\n\n流程定义和部署相关的存储服务\n\n#### RuntimeService\n\n流程运行时相关的服务，如根据流程好启动流程实例startProcessInstanceByKey。\n\n#### HistoryService\n\n历史记录相关服务接口。\n\n\n\n# 项目搭建\n\n## 创建SpringBoot项目并且添加maven依赖\n\npom.xml:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n   <modelVersion>4.0.0</modelVersion>\n   <parent>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-parent</artifactId>\n      <version>2.1.6.RELEASE</version>\n      <relativePath/> <!-- lookup parent from repository -->\n   </parent>\n   <groupId>com.example</groupId>\n   <artifactId>demo</artifactId>\n   <version>0.0.1-SNAPSHOT</version>\n   <name>demo</name>\n   <description>Demo project for Spring Boot</description>\n\n   <properties>\n      <java.version>1.8</java.version>\n   </properties>\n\n   <dependencies>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter</artifactId>\n      </dependency>\n\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-devtools</artifactId>\n         <scope>runtime</scope>\n         <optional>true</optional>\n      </dependency>\n      <dependency>\n         <groupId>mysql</groupId>\n         <artifactId>mysql-connector-java</artifactId>\n         <scope>runtime</scope>\n      </dependency>\n      <dependency>\n         <groupId>org.projectlombok</groupId>\n         <artifactId>lombok</artifactId>\n         <optional>true</optional>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-test</artifactId>\n         <scope>test</scope>\n      </dependency>\n      <dependency>\n         <groupId>org.activiti</groupId>\n         <artifactId>activiti-spring-boot-starter</artifactId>\n         <version>7.0.0.Beta2</version>\n      </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-jdbc</artifactId>\n        </dependency>\n\n   </dependencies>\n\n   <build>\n      <plugins>\n         <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n         </plugin>\n      </plugins>\n   </build>\n\n</project>\n\n```\n\n## 添加配置文件\n\napplication.yml：\n\n```xml\nspring:\n  datasource:\n    username: root\n    password: 123456\n    url: jdbc:mysql://localhost:3306/test2?nullCatalogMeansCurrent=true\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  devtools:\n      restart:\n        enabled: true  #设置开启热部署\n  activiti:\n    database-schema-update: true\n    history-level: full\n    db-history-used: true\n\n\ndebug: true\n\n```\n\n\n\n## 创建流程图\n\n在创建流程图之前首先需要安装idea支持bpm文件的插件\n\n![2](SpringBoot整合Activiti7使用/2.jpg)\n\n安装成功后在resources目录下创建processes文件夹并新建holiday.bpmn文件并且创建流程\n\n![](SpringBoot整合Activiti7使用/3.jpg)\n\n\n\n对应xml文件代码如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<definitions xmlns=\"http://www.omg.org/spec/BPMN/20100524/MODEL\" xmlns:activiti=\"http://activiti.org/bpmn\" xmlns:bpmndi=\"http://www.omg.org/spec/BPMN/20100524/DI\" xmlns:omgdc=\"http://www.omg.org/spec/DD/20100524/DC\" xmlns:omgdi=\"http://www.omg.org/spec/DD/20100524/DI\" xmlns:tns=\"http://www.activiti.org/test\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" expressionLanguage=\"http://www.w3.org/1999/XPath\" id=\"m1562573992349\" name=\"\" targetNamespace=\"http://www.activiti.org/test\" typeLanguage=\"http://www.w3.org/2001/XMLSchema\">\n  <process id=\"myProcess_1\" isClosed=\"false\" isExecutable=\"true\" processType=\"None\">\n    <startEvent id=\"_2\" name=\"StartEvent\"/>\n    <userTask activiti:assignee=\"${userId}\" activiti:exclusive=\"false\" id=\"_3\" name=\"填写申请单\"/>\n    <userTask activiti:assignee=\"department\" activiti:exclusive=\"true\" id=\"_4\" name=\"审核\"/>\n    <endEvent id=\"_6\" name=\"EndEvent\"/>\n    <sequenceFlow id=\"_7\" sourceRef=\"_2\" targetRef=\"_3\"/>\n    <sequenceFlow id=\"_8\" sourceRef=\"_3\" targetRef=\"_4\"/>\n    <sequenceFlow id=\"_11\" sourceRef=\"_4\" targetRef=\"_6\"/>\n  </process>\n  <bpmndi:BPMNDiagram documentation=\"background=#3C3F41;count=1;horizontalcount=1;orientation=0;width=842.4;height=1195.2;imageableWidth=832.4;imageableHeight=1185.2;imageableX=5.0;imageableY=5.0\" id=\"Diagram-_1\" name=\"New Diagram\">\n    <bpmndi:BPMNPlane bpmnElement=\"myProcess_1\">\n      <bpmndi:BPMNShape bpmnElement=\"_2\" id=\"Shape-_2\">\n        <omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"225.0\" y=\"175.0\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNShape>\n      <bpmndi:BPMNShape bpmnElement=\"_3\" id=\"Shape-_3\">\n        <omgdc:Bounds height=\"55.0\" width=\"85.0\" x=\"435.0\" y=\"175.0\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"55.0\" width=\"85.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNShape>\n      <bpmndi:BPMNShape bpmnElement=\"_4\" id=\"Shape-_4\">\n        <omgdc:Bounds height=\"55.0\" width=\"85.0\" x=\"655.0\" y=\"175.0\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"55.0\" width=\"85.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNShape>\n      <bpmndi:BPMNShape bpmnElement=\"_6\" id=\"Shape-_6\">\n        <omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"875.0\" y=\"185.0\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNShape>\n      <bpmndi:BPMNEdge bpmnElement=\"_7\" id=\"BPMNEdge__7\" sourceElement=\"_2\" targetElement=\"_3\">\n        <omgdi:waypoint x=\"257.0\" y=\"191.0\"/>\n        <omgdi:waypoint x=\"435.0\" y=\"202.5\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"0.0\" width=\"0.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNEdge>\n      <bpmndi:BPMNEdge bpmnElement=\"_8\" id=\"BPMNEdge__8\" sourceElement=\"_3\" targetElement=\"_4\">\n        <omgdi:waypoint x=\"520.0\" y=\"202.5\"/>\n        <omgdi:waypoint x=\"655.0\" y=\"202.5\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"0.0\" width=\"0.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNEdge>\n      <bpmndi:BPMNEdge bpmnElement=\"_11\" id=\"BPMNEdge__11\" sourceElement=\"_4\" targetElement=\"_6\">\n        <omgdi:waypoint x=\"740.0\" y=\"202.5\"/>\n        <omgdi:waypoint x=\"875.0\" y=\"201.0\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"0.0\" width=\"0.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNEdge>\n    </bpmndi:BPMNPlane>\n  </bpmndi:BPMNDiagram>\n</definitions>\n\n```\n\n## 运行Application\n\n启动后查看数据库发现springboot 自动读取了processes下的holiday.bpmn文件并且部署任务流程到activiti。数据库中生成了25张工作表。\n\n![](SpringBoot整合Activiti7使用/1.jpg)\n\n并且在ACT_GE_BYTEARRAY表中也存在部署的信息\n\n![4](SpringBoot整合Activiti7使用/4.jpg)\n\n\n\n# 编写实例\n\n## 开启请假流程\n\n```java\n\t@Test\n\tpublic void start() {\n\t\tString instanceKey = \"myProcess_1\";\n\t\tlogger.info(\"开启请假流程...\");\n\t\tMap<String, Object> map = new HashMap<String, Object>();\n\t\t//在holiday.bpmn中,填写请假单的任务办理人为动态传入的userId,此处模拟一个id\n\t\tmap.put(\"userId\", \"10001\");\n\t\tProcessInstance instance = runtimeService.startProcessInstanceByKey(instanceKey, map);\n\t\tlogger.info(\"启动流程实例成功:{}\", instance);\n\t\tlogger.info(\"流程实例ID:{}\", instance.getId());\n\t\tlogger.info(\"流程定义ID:{}\", instance.getProcessDefinitionId());\n\n\t}\n```\n\n运行结果：\n\n![5](SpringBoot整合Activiti7使用/5.jpg)\n\n运行后成功开启了一个请假实例并且获取到id为：adc6a5f0-a2c3-11e9-bb83-00e04c83a7ff。\n\n\n\n## 填写请假单\n\n通过实例id可以查询到实例所对应的任务，模拟用户请假的内容存入map中添加为流程变量。\n\n```java\n\t@Test\n\tpublic void employeeApply() {\n\t\tString instanceId = \"adc6a5f0-a2c3-11e9-bb83-00e04c83a7ff\"; // 任务ID\n\t\tString leaveDays = \"10\"; // 请假天数\n\t\tString leaveReason = \"回老家结婚\"; // 请假原因\n\t\tTask task = taskService.createTaskQuery().processInstanceId(instanceId).singleResult();\n\t\tif (task == null) {\n\t\t\tlogger.info(\"任务ID:{}查询到任务为空！\", instanceId);\n\t\t}\n\t\tMap<String, Object> map = new HashMap<String, Object>();\n\t\tmap.put(\"days\", leaveDays);\n\t\tmap.put(\"date\", new Date());\n\t\tmap.put(\"reason\", leaveReason);\n\t\ttaskService.complete(task.getId(), map);\n\t\tlogger.info(\"执行【员工申请】环节，流程推动到【上级审核】环节\");\n\t}\n```\n\n运行结果如下：\n\n![6](SpringBoot整合Activiti7使用/6.jpg)\n\n## 流程变量查看\n\n上级审核的时候需要查看到员工所提交的请假相关信息，可以通过taskService.getVariable的形式来获取。\n\n```java\n\t@Test\n\tpublic void showTaskVariable (){\n\t\tString instanceId = \"adc6a5f0-a2c3-11e9-bb83-00e04c83a7ff\"; // 任务ID\n\n\t\tTask task = taskService.createTaskQuery().processInstanceId(instanceId).singleResult();\n\t\tString days = (String) taskService.getVariable(task.getId(), \"days\");\n\t\tDate date = (Date) taskService.getVariable(task.getId(), \"date\");\n\t\tString reason = (String) taskService.getVariable(task.getId(), \"reason\");\n\t\tString userId = (String) taskService.getVariable(task.getId(), \"userId\");\n\t\tSystem.out.println(\"请假天数:  \" + days);\n\t\tSystem.out.println(\"请假理由:  \" + reason);\n\t\tSystem.out.println(\"请假人id:  \" + userId);\n\t\tSystem.out.println(\"请假日期:  \" + date.toString());\n\t}\n```\n\n运行结果：\n\n![7](SpringBoot整合Activiti7使用/7.jpg)\n\n## 上级审批\n\n上级审批并且添加意见\n\n```java\n\t@Test\n\tpublic void departmentAudit() {\n\t\tString instanceId = \"adc6a5f0-a2c3-11e9-bb83-00e04c83a7ff\"; // 任务ID\n\t\tString departmentalOpinion = \"早去早回\";\n\t\tTask task = taskService.createTaskQuery().processInstanceId(instanceId).singleResult();\n\t\tMap<String, Object> map = new HashMap<String, Object>();\n\t\tmap.put(\"departmentalOpinion\", departmentalOpinion);\n\t\ttaskService.complete(task.getId(), map);\n\t\tlogger.info(\"添加审批意见,请假流程结束\");\n\t}\n\n```\n\n运行结果：\n\n![8](SpringBoot整合Activiti7使用/8.jpg)\n\n\n\n# 总结\n\n使用Activiti可以方便对流程进行控制。本文只是对简单的请假流程做了实例，没有涉及到多任务或多分支等情景。对于此类情况以后再做补充。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["SpringBoot","Activiti7"]},{"title":"Thumbnailator图片处理","url":"/2019/06/18/Thumbnailator图片处理/","content":"\n\n\nThumbnailator 是一个优秀的图片处理的Google开源Java类库。处理效果远比Java API的好。从API提供现有的图像文件和图像对象的类中简化了处理过程，两三行代码就能够从现有图片生成处理后的图片，且允许微调图片的生成方式，同时保持了需要写入的最低限度的代码量。还支持对一个目录的所有图片进行批量处理操作。\n\n支持的处理操作：图片缩放，区域裁剪，水印，旋转，保持比例。\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 导入依赖\n\n```xml\n<!-- https://mvnrepository.com/artifact/net.coobird/thumbnailator -->\n<dependency>\n    <groupId>net.coobird</groupId>\n    <artifactId>thumbnailator</artifactId>\n    <version>0.4.8</version>\n</dependency>\n\n```\n\n## 函数示例\n\n```java\n从图像文件创建缩略图\nThumbnails.of(new File(\"original.jpg\"))\n        .size(160, 160)\n        .toFile(new File(\"thumbnail.jpg\"));\n在此示例中，图像来自original.jpg调整大小，然后保存到thumbnail.jpg。\n\n或者，Thumbnailator将接受文件名作为String。File不需要使用对象指定图像文件：\n\nThumbnails.of(\"original.jpg\")\n        .size(160, 160)\n        .toFile(\"thumbnail.jpg\");\n在编写快速原型代码或从脚本语言中使用Thumbnailator时，此表单非常有用。\n\n使用旋转和水印创建缩略图\nThumbnails.of(new File(\"original.jpg\"))\n        .size(160, 160)\n        .rotate(90)\n        .watermark(Positions.BOTTOM_RIGHT, ImageIO.read(new File(\"watermark.png\")), 0.5f)\n        .outputQuality(0.8)\n        .toFile(new File(\"image-with-watermark.jpg\"));\n在此示例中，original.jpg调整图像大小，然后顺时针旋转90度，然后在右下角放置一个半透明水印，然后image-with-watermark.jpg以80％压缩质量设置保存。\n\n创建缩略图并写入 OutputStream\nOutputStream os = ...;\n\t\t\nThumbnails.of(\"large-picture.jpg\")\n        .size(200, 200)\n        .outputFormat(\"png\")\n        .toOutputStream(os);\n在此示例中，将文件中的图像large-picture.jpg调整为最大尺寸200 x 200（保持原始图像的纵横比），并将其写入指定OutputStream的PNG图像。\n\n创建固定大小的缩略图\nBufferedImage originalImage = ImageIO.read(new File(\"original.png\"));\n\nBufferedImage thumbnail = Thumbnails.of(originalImage)\n        .size(200, 200)\n        .asBufferedImage();\n上面的代码采用图像originalImage并创建一个200像素乘200像素的缩略图，并使用并存储结果thumbnail。\n\n按给定因子缩放图像\nBufferedImage originalImage = ImageIO.read(new File(\"original.png\"));\n\nBufferedImage thumbnail = Thumbnails.of(originalImage)\n        .scale(0.25)\n        .asBufferedImage();\n上面的代码将图像originalImage带入并创建一个缩略图，该缩略图是原始图像的25％，并使用默认缩放技术来制作存储在其中的缩略图thumbnail。\n\n创建缩略图时旋转图像\nBufferedImage originalImage = ImageIO.read(new File(\"original.jpg\"));\n\nBufferedImage thumbnail = Thumbnails.of(originalImage)\n        .size(200, 200)\n        .rotate(90)\n        .asBufferedImage();\n上面的代码采用原始图像并创建一个顺时针旋转90度的缩略图。\n\n使用水印创建缩略图\nBufferedImage originalImage = ImageIO.read(new File(\"original.jpg\"));\nBufferedImage watermarkImage = ImageIO.read(new File(\"watermark.png\"));\n\nBufferedImage thumbnail = Thumbnails.of(originalImage)\n        .size(200, 200)\n        .watermark(Positions.BOTTOM_RIGHT, watermarkImage, 0.5f)\n        .asBufferedImage();\n如图所示，可以通过调用该watermark方法将水印添加到缩略图。\n\n可以从Positions枚举中选择定位。\n\n缩略图的不透明度（或相反地，透明度）可以通过改变最后一个参数来调整，其中0.0f缩略图是完全透明的，并且1.0f水印是完全不透明的。\n\n将缩略图写入特定目录\nFile destinationDir = new File(\"path/to/output\");\n\nThumbnails.of(\"apple.jpg\", \"banana.jpg\", \"cherry.jpg\")\n        .size(200, 200)\n        .toFiles(destinationDir, Rename.PREFIX_DOT_THUMBNAIL);\n此示例将获取源图像，并将缩略图作为文件写入destinationDir（path/to/output目录），同时thumbnail.在文件名前添加重命名。\n\n因此，缩略图将被写为以下文件：\n\npath/to/output/thumbnail.apple.jpg\npath/to/output/thumbnail.banana.jpg\npath/to/output/thumbnail.cherry.jpg\n写入指定目录时，也可以保留原始文件名：\n\nFile destinationDir = new File(\"path/to/output\");\n\nThumbnails.of(\"apple.jpg\", \"banana.jpg\", \"cherry.jpg\")\n        .size(200, 200)\n        .toFiles(destinationDir, Rename.NO_CHANGE);\n在上面的代码中，缩略图将写入：\n\npath/to/output/apple.jpg\npath/to/output/banana.jpg\npath/to/output/cherry.jpg\n```\n\n","tags":["Thumbnailator"]},{"title":"lucene全文检索操作实例","url":"/2019/06/03/lucene操作实例/","content":"\n\n\nLucene是apache下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 全文检索\n\n将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之**索引**。\n\n例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。\n\n**这种先建立索引，再对索引进行搜索的过程就叫全文检索****(Full-text Search)****。**\n\n虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。对于数据量大、数据结构不固定的数据可采用全文检索方式搜索，比如百度、Google等搜索引擎、论坛站内搜索、电商网站站内搜索等。\n\nTip:lucene对java环境的最低要求为JAVA1.8\n\n## 创建索引\n\n第一步：创建一个java工程，并导入jar包。\n\n工程所需jar包:\n\n![](lucene操作实例\\2019-06-03_232645.jpg)\n\n第二步：创建一个indexwriter对象。\n\n1）指定索引库的存放位置Directory对象\n\n2）指定一个IndexWriterConfig对象。\n\n第二步：创建document对象。\n\n第三步：创建field对象，将field添加到document对象中。\n\n第四步：使用indexwriter对象将document对象写入索引库，此过程进行索引创建。并将索引和document对象写入索引库。\n\n第五步：关闭IndexWriter对象。\n\n\n\n代码如下:\n\n```java\n @Test\n    public void createIndex() throws Exception {\n        //创建一个Director对象,指定索引库保存的位置\n        Directory directory = FSDirectory.open(new File(\"c:\\\\temp\\\\index\").toPath());\n        //基于directory对象创建一个IndexWriter对象\n        IndexWriter indexWriter = new IndexWriter(directory, new IndexWriterConfig());\n        //读取磁盘上的文件\n        File dir = new File(\"C:\\\\Users\\\\liu\\\\Desktop\\\\searchsource\");\n        //原始文档的路径\n        File[] files = dir.listFiles();\n        for (File f : files) {\n            String name = f.getName();\n            String filePath = f.getPath();\n            String fileContent = FileUtils.readFileToString(f, \"utf-8\");\n            long fileSize = FileUtils.sizeOf(f);\n            //创建Field\n            //第一个参数：域的名称\n            //第二个参数：域的内容\n            //第三个参数：是否存储\n            Field fieldName = new TextField(\"name\", name, Field.Store.YES);\n            //文件路径域（不分析、不索引、只存储）\n            Field fieldPath = new TextField(\"path\", filePath, Field.Store.YES);\n            //文件内容域\n            Field fieldContent = new TextField(\"content\", fileContent, Field.Store.YES);\n            //文件大小域\n            Field fieldSize = new TextField(\"size\", fileSize + \"\", Field.Store.YES);\n            //创建文档对象\n            Document document = new Document();\n            document.add(fieldName);\n            document.add(fieldPath);\n            document.add(fieldContent);\n            document.add(fieldSize);\n            //把文档对象写入索引库\n            indexWriter.addDocument(document);\n\n        }\n        //关闭indexwriter\n        indexWriter.close();\n    }\n```\n\n\n\ncreateIndex方法运行后会在c:\\\\\\temp\\\\\\index文件夹下生成索引文件,如下图:\n\n![](lucene操作实例\\2019-06-03_231250.jpg)\n\n生成的索引文件为二进制文件,可以使用luke打开索引\n\n## 查看索引\n\nluck开始界面如下,在indexPath中选择索引存储位置文件夹即可\n\n![](lucene操作实例\\2019-06-03_231604.jpg)\n\n\n\n![](D:\\OneDrive - business\\myblog\\source\\_posts\\lucene操作实例\\2019-06-03_232113.jpg)\n\n## 查询索引\n\n第一步：创建一个Directory对象，也就是索引库存放的位置。\n\n第二步：创建一个indexReader对象，需要指定Directory对象。\n\n第三步：创建一个indexsearcher对象，需要指定IndexReader对象\n\n第四步：创建一个TermQuery对象，指定查询的域和查询的关键词。\n\n第五步：执行查询。\n\n第六步：返回查询结果。遍历查询结果并输出。\n\n第七步：关闭IndexReader对象\n\n代码如下:\n\n```java\n    @Test\n    public void searchIndex() throws Exception {\n        //指定索引库存放的路径\n        Directory directory = FSDirectory.open(new File(\"c:\\\\temp\\\\index\").toPath());\n        //创建indexReader对象\n        IndexReader indexReader = DirectoryReader.open(directory);\n        //创建indexsearcher对象\n        IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n        //创建查询\n        Query query = new TermQuery(new Term(\"content\", \"spring\"));\n\n        //执行查询\n        //第一个参数是查询对象，第二个参数是查询结果返回的最大值\n        TopDocs topDocs = indexSearcher.search(query, 10);\n        //查询结果的总条数\n        System.out.println(\"查询总记录数:\" + topDocs.totalHits);\n        //遍历查询结果\n        //topDocs.scoreDocs存储了document对象的id\n\n        ScoreDoc[] scoreDocs = topDocs.scoreDocs;\n\n        for (ScoreDoc doc : scoreDocs) {\n            //scoreDoc.doc属性就是document对象的id\n            //根据document的id找到document对象\n\n            int docId = doc.doc;\n            Document document = indexSearcher.doc(docId);\n            System.out.println(document.get(\"name\"));\n            System.out.println(document.get(\"path\"));\n            System.out.println(document.get(\"size\"));\n            System.out.println(document.get(\"content\"));\n            System.out.println(\"--------------------------\");\n        }\n        //关闭indexreader对象\n        indexReader.close();\n\n    }\n```\n\n部分查询结果如下图:\n\n![](lucene操作实例\\2019-06-03_232508.jpg)","tags":["lucene"]},{"title":"centos7.3搭建gogs","url":"/2019/05/31/centos7-3搭建gogs/","content":"\n\n\nGogs 是一款类似GitHub的开源文件/代码管理系统（基于Git），Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。使用 Go 语言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 所有平台，包括 Linux、Mac OS X、Windows 以及 ARM 平台。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 安装docker\n\n### 升级centos内核到最新版本\n\n在安装响应包之前先将centos的系统版本和内核升级,防止出现docker启动gogs时候报错\n\n```shell\nyum -y update\n```\n\n### 安装docker\n\n```shell\n# 通过yum源安装docker\nyum -y install docker\n# 启动docker\nsystemctl start docker\n# 设置开机自启\nsudo systemctl enable docker\n```\n\n### 下载gogs镜像\n\n```shell\ndocker pull gogs/gogs\n```\n\n### 创建gogs存储目录\n\n```shell\nmkdir -p /var/gogs\n```\n\n### 运行镜像,产生容器\n\n```shell\ndocker run --name=gogs -p 10022:22 -p 10080:3000 -v /var/gogs:/data gogs/gogs\n```\n\n\n\n## 运行并配置配置gogs\n\n\n\n![](centos7-3搭建gogs\\3203841-709cd56c61b12bd7.png)\n\n配置完成后点击立即安装开始安装\n\n## 创建仓库\n\n注册登录后,在控制面版中可以看到我的仓库,点击 '+' 可以创建新的仓库:\n\n创建仓库的时候可以选择使用选定的文件和模板初始化仓库,如果不勾选初始化则创建一个空的仓库.\n\n![](centos7-3搭建gogs\\2019-05-31_142708.jpg)\n\n\n\n\n\n## 克隆仓库\n\n打开想要克隆的仓库,复制http url连接,在想要克隆的目录下使用git clone url 即可\n\n\n\n![](centos7-3搭建gogs\\2019-05-31_152224.jpg)\n\n\n\n## 提交本地仓库\n\n如下图所示,在克隆下来的仓库中添加了一张图片,现在要想整个本地仓库再上传到gogs中\n\n![](centos7-3搭建gogs\\2019-05-31_152749.jpg)\n\n使用如下命令:\n\n```shell\n#添加所有文件\ngit add -A \n#提交到本地仓库\ngit commit -m \"first commit\"\n#提交到gogs仓库\ngit push\n```\n\n","tags":["gogs"]},{"title":"git常用命令","url":"/2019/05/25/git常用命令/","content":"\ngit常用命令\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n\n**git init**\n\n​     在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹.\n\n \n\n**git clone**\n\n​     获取一个url对应的远程Git repo, 创建一个local copy.\n\n​     一般的格式是git clone [url].\n\n​     clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定.\n\n \n\n**git status**\n\n​     查询repo的状态.\n\n​     git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言.\n\n \n\n**git log**\n\n​     show commit history of a branch.\n\n​     git log --oneline --number: 每条log只显示一行,显示number条.\n\n​     git log --oneline --graph:可以图形化地表示出分支合并历史.\n\n​     git log branchname可以显示特定分支的log.\n\n​     git log --oneline branch1 ^branch2,可以查看在分支1,却不在分支2中的提交.^表示排除这个分支(Window下可能要给^branch2加上引号).\n\n​     git log --decorate会显示出tag信息.\n\n​     git log --author=[author name] 可以指定作者的提交历史.\n\n​     git log --since --before --until --after 根据提交时间筛选log.\n\n​     --no-merges可以将merge的commits排除在外.\n\n​     git log --grep 根据commit信息过滤log: git log --grep=keywords\n\n​     默认情况下, git log --grep --author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上--all-match的option.\n\n​     git log -S: filter by introduced diff.\n\n​     比如: git log -SmethodName (注意S和后面的词之间没有等号分隔).\n\n​     git log -p: show patch introduced at each commit.\n\n​     每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看.\n\n​     另一种方法是git show [SHA].\n\n​     git log --stat: show diffstat of changes introduced at each commit.\n\n​     同样是用来看改动的相对信息的,--stat比-p的输出更简单一些.\n\n​    \n\n**git add**\n\n​     在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动.\n\n​     git add .\n\n​     会递归地添加当前工作目录中的所有文件.\n\n \n\n**git diff**\n\n​     不加参数的git diff:\n\n​     show diff of unstaged changes.\n\n​     此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容.\n\n \n\n​     若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用:\n\n​     git diff --cached 命令.\n\n​     show diff of staged changes.\n\n​     (Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的).\n\n \n\n​     git diff HEAD\n\n​     show diff of all staged or unstated changes.\n\n​     也即比较woking directory和上次提交之间所有的改动.\n\n \n\n​     如果想看自从某个版本之后都改动了什么,可以用:\n\n​     git diff [version tag]\n\n​     跟log命令一样,diff也可以加上--stat参数来简化输出.\n\n \n\n​     git diff [branchA] [branchB]可以用来比较两个分支.\n\n​     它实际上会返回一个由A到B的patch,不是我们想要的结果.\n\n​     一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令:\n\n​     git diff [branchA]…[branchB]给出的.\n\n​     实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果.\n\n \n\n \n\n**git commit**\n\n​     提交已经被add进来的改动.\n\n​     git commit -m “the commit message\"\n\n​     git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下.\n\n​     git commit --amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消.\n\n \n\n**git reset**\n\n​     undo changes and commits.\n\n​     这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本.\n\n​     git reset HEAD: unstage files from index and reset pointer to HEAD\n\n​     这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD - - filename, 这个- - 也可以不加.\n\n​     git reset --soft\n\n​     move HEAD to specific commit reference, index and staging are untouched.\n\n​     git reset --hard\n\n​     unstage files AND undo any changes in the working directory since last commit.\n\n​     使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态.\n\n​     这里的HEAD可以被写成任何一次提交的SHA-1.\n\n​     不带soft和hard参数的git reset,实际上带的是默认参数mixed.\n\n \n\n​     总结:\n\n​     git reset --mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容.\n\n​     git reset --soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容.\n\n​     git reset --hard id.是将git的HEAD变了,文件也变了.\n\n​     按改动范围排序如下:\n\n​     soft (commit) < mixed (commit + add) < hard (commit + add + local working)\n\n \n\n**git revert**\n\n​     反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了.\n\n​     git revert HEAD: 撤销最近的一个提交.\n\n​     git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交.\n\n​    \n\n**git rm**\n\n​     git rm file: 从staging区移除文件,同时也移除出工作目录.\n\n​     git rm --cached: 从staging区移除文件,但留在工作目录中.\n\n​     git rm --cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树.\n\n \n\n**git clean**\n\n​     git clean是从工作目录中移除没有track的文件.\n\n​     通常的参数是git clean -df:\n\n​     -d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行.\n\n \n\n**git mv**\n\n​     git rm - - cached orig; mv orig new; git add new\n\n \n\n**git stash**\n\n​     把当前的改动压入一个栈.\n\n​     git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处.\n\n​     git stash list会显示这个栈的list.\n\n​     git stash apply:取出stash中的上一个项目(stash@{0}),并且应用于当前的工作目录.\n\n​     也可以指定别的项目,比如git stash apply stash@{1}.\n\n​     如果你在应用stash中项目的同时想要删除它,可以用git stash pop\n\n \n\n​     删除stash中的项目:\n\n​     git stash drop: 删除上一个,也可指定参数删除指定的一个项目.\n\n​     git stash clear: 删除所有项目.\n\n \n\n**git branch**\n\n​     git branch可以用来列出分支,创建分支和删除分支.\n\n​     git branch -v可以看见每一个分支的最后一次提交.\n\n​     git branch: 列出本地所有分支,当前分支会被星号标示出.\n\n​     git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的). \n\n​     git branch -d (branchname): 删除一个分支.\n\n​     删除remote的分支:\n\n​     git push (remote-name) :(branch-name): delete a remote branch.\n\n​     这个是因为完整的命令形式是:\n\n​     git push remote-name local-branch:remote-branch\n\n​     而这里local-branch的部分为空,就意味着删除了remote-branch\n\n \n\n**git checkout**\n\n　　git checkout (branchname)\n\n \n\n切换到一个分支.\n\n​     git checkout -b (branchname): 创建并切换到新的分支.\n\n​     这个命令是将git branch newbranch和git checkout newbranch合在一起的结果.\n\n​     checkout还有另一个作用:替换本地改动:\n\n​     git checkout --<filename>\n\n​     此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响.\n\n​     注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的.\n\n \n\n**git merge**\n\n​     把一个分支merge进当前的分支.\n\n​     git merge [alias]/[branch]\n\n​     把远程分支merge到当前分支.\n\n \n\n​     如果出现冲突,需要手动修改,可以用git mergetool.\n\n​     解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved.\n\n \n\n**git tag**\n\n​     tag a point in history as import.\n\n​     会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag.\n\n​     比如: git tag v1.0\n\n​     git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag.\n\n​     当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息.\n\n​     \n\n​     我们可以利用commit SHA来给一个过去的提交打tag:\n\n​     git tag -a v0.9 XXXX\n\n \n\n​     push的时候是不包含tag的,如果想包含,可以在push时加上--tags参数.\n\n​     fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上--tags选项.\n\n \n\n**git remote**\n\n​     list, add and delete remote repository aliases.\n\n​     因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list.\n\n​     git remote: 列出remote aliases.\n\n​     如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin.\n\n​     git remote -v:可以看见每一个别名对应的实际url.\n\n​     git remote add [alias] [url]: 添加一个新的remote repo.\n\n​     git remote rm [alias]: 删除一个存在的remote alias.\n\n​     git remote rename [old-alias] [new-alias]: 重命名.\n\n​     git remote set-url [alias] [url]:更新url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址.\n\n \n\n**git fetch**\n\n​     download new branches and data from a remote repository.\n\n​     可以git fetch [alias]取某一个远程repo,也可以git fetch --all取到全部repo\n\n​     fetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们. \n\n \n\n**git pull**\n\n​     fetch from a remote repo and try to merge into the current branch.\n\n​     pull == fetch + merge FETCH_HEAD\n\n​     git pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit.    \n\n​     如果使用--rebase参数,它会执行git rebase来取代原来的git merge.\n\n  \n\n \n\n**git rebase**\n\n​     --rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上.\n\n​     rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要:\n\n​     git rebase --continue就会继续打余下的补丁.\n\n​     git rebase --abort将会终止rebase,当前分支将会回到rebase之前的状态.\n\n \n\n**git push**\n\n​     push your new branches and data to a remote repository.\n\n​     git push [alias] [branch]\n\n​     将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支.\n\n​     如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来.\n\n \n\n**git reflog**\n\n​     git reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化.\n\n​     当git reflog不指定引用的时候,默认列出HEAD的reflog.\n\n​     HEAD@{0}代表HEAD当前的值,HEAD@{3}代表HEAD在3次变化之前的值.\n\n​     git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中.\n\n![](git常用命令\\20181008143725727.png)","tags":["git"]},{"title":"Java Builder Pattern","url":"/2019/05/15/Java-Builder-Pattern/","content":"\n\n\n静态工厂和构造函数有一个共同的限制:它们不能很好地扩展到大量可选参数，所以考虑通过构造器来构造一个类的实例。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n# Telescoping constructor pattern\n\n通常我们在创建一个类的实例时候都是用它的构造函数来创建。例如：\n\n```java\n// Telescoping constructor pattern - does not scale well!\npublic class NutritionFacts {\n    private final int servingSize; // (mL) required\n    private final int servings; // (per container) required\n    private final int calories; // (per serving) optional\n    private final int fat; // (g/serving) optional\n    private final int sodium; // (mg/serving) optional\n    private final int carbohydrate; // (g/serving) optional\n\n    public NutritionFacts(int servingSize, int servings) {\n        this(servingSize, servings, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings,\n                          int calories) {\n        this(servingSize, servings, calories, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings,\n                          int calories, int fat) {\n        this(servingSize, servings, calories, fat, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings,\n                          int calories, int fat, int sodium) {\n        this(servingSize, servings, calories, fat, sodium, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings,\n                          int calories, int fat, int sodium, int carbohydrate) {\n        this.servingSize = servingSize;\n        this.servings = servings;\n        this.calories = calories;\n        this.fat = fat;\n        this.sodium = sodium;\n        this.carbohydrate = carbohydrate;\n    }\n}\n```\n\n\n\n```java\nNutritionFacts cocaCola =\nnew NutritionFacts(240, 8, 100, 0, 35, 27);\n```\n\n但是这种方式存在很多不便之处：\n\n+ 即使只需要设定一部分参数也要为不需要设置的参数设置默认值\n+ 当参数过多的时候，尤其是存在许多同类型的参数的时候，很容易产生参数设置的混淆，这种混淆编译是不会发现的，在程序运行的时候才会产生错误\n+ 代码不易读懂，用户使用函数时候需要参照api\n\n\n\n# JavaBeans Pattern\n\n另外一种可选的方式是javabean的形式，其主要理念是通过空构造函数来创建一个实例，然后通过set方法对参数进行赋值。例如：\n\n```java\n// JavaBeans Pattern - allows inconsistency, mandates mutability\npublic class NutritionFacts {\n    // Parameters initialized to default values (if any)\n    private int servingSize = -1; // Required; no default value\n    private int servings = -1; // Required; no default value\n    private int calories = 0;\n    private int fat = 0;\n    private int sodium = 0;\n    private int carbohydrate = 0;\n\n    public NutritionFacts() {\n    }\n\n    // Setters\n    public void setServingSize(int val) {\n        servingSize = val;\n    }\n\n    public void setServings(int val) {\n        servings = val;\n    }\n\n    public void setCalories(int val) {\n        calories = val;\n    }\n\n    public void setFat(int val) {\n        fat = val;\n    }\n\n    public void setSodium(int val) {\n        sodium = val;\n    }\n\n    public void setCarbohydrate(int val) {\n        carbohydrate = val;\n    }\n}\n```\n\n这种模式没有Telescoping constructor pattern的任何缺点。\n\n创建实例很容易，虽然有点冗长，并且很容易读取生成的代码:\n\n```java\nNutritionFacts cocaCola = new NutritionFacts();\ncocaCola.setServingSize(240);\ncocaCola.setServings(8);\ncocaCola.setCalories(100);\ncocaCola.setSodium(35);\ncocaCola.setCarbohydrate(27);\n```\n\n但是，javabean模式本身有严重的缺点。因为构造是在多个调用之间分割的，所以JavaBean在构造过程中可能处于不一致的状态。\n\n# Builder pattern \n\n客户机不直接生成所需的对象，而是使用所有必需的参数调用构造函数(或静态工厂)并获得一个构建器对象。然后客户端调用builder对象上类似setter的方法来设置每个可选参数。最后，客户端调用一个无参数的构建方法来生成对象，该对象通常是不可变的。\n\n```java\n/**\n * @Author liu\n * @Description //TODO\n * @Date 9:08 2019/5/15\n * @Param\n * @return\n **/\npublic class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private final int carbohydrate;\n\n    public static class Builder {\n        // Required parameters\n        private final int servingSize;\n        private final int servings;\n        // Optional parameters - initialized to default values\n        private int calories = 0;\n        private int fat = 0;\n        private int sodium = 0;\n        private int carbohydrate = 0;\n\n        public Builder(int servingSize, int servings) {\n            this.servingSize = servingSize;\n            this.servings = servings;\n        }\n\n        public Builder calories(int val) {\n            calories = val;\n            return this;\n        }\n\n        public Builder fat(int val) {\n            fat = val;\n            return this;\n        }\n\n        public Builder sodium(int val) {\n            sodium = val;\n            return this;\n        }\n\n        public Builder carbohydrate(int val) {\n            carbohydrate = val;\n            return this;\n        }\n\n        public NutritionFacts build() {\n            return new NutritionFacts(this);\n        }\n    }\n\n    private NutritionFacts(Builder builder) {\n        servingSize = builder.servingSize;\n        servings = builder.servings;\n        calories = builder.calories;\n        fat = builder.fat;\n        sodium = builder.sodium;\n        carbohydrate = builder.carbohydrate;\n    }\n\n    public static void main(String[] args) {\n        NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)\n                .calories(100).sodium(35).carbohydrate(27).build();\n    }\n}\n```\n\nBuilder pattern也有缺点。为了创建对象，必须首先创建它的构建器。虽然在实践中创建这个构建器的成本不太可能显著，但在性能关键的情况下，它可能会成为一个问题。此外，Builder pattern的代码较为冗长，在设计构造函数或静态工厂有多个参数的类时，尤其是当许多参数是可选的或具有相同类型时，Builder模式是一个很好的选择，因为它更易读、更安全。","tags":["JAVA"]},{"title":"java异常、线程","url":"/2019/05/12/java异常、线程/","content":"\n异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：\n\n- **异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。\n\n在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 1.1 异常概念\n\n异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：\n\n- **异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。\n\n在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。\n\n> 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.\n\n## 1.2 异常体系\n\n异常机制其实是帮助我们**找到**程序中的问题，异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`。\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png)\n\n**Throwable体系：**\n\n- **Error**:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。\n- **Exception**:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。\n\n**Throwable中的常用方法：**\n\n- `public void printStackTrace()`:打印异常的详细信息。\n\n  *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*\n\n- `public String getMessage()`:获取发生异常的原因。\n\n  *提示给用户的时候,就提示错误原因。*\n\n- `public String toString()`:获取异常的类型和异常描述信息(不用)。\n\n***出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。***\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9F%A5%E7%9C%8B.bmp)\n\n## 1.3 异常分类\n\n我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。\n\n**异常(Exception)的分类**:根据在编译时期还是运行时期去检查异常?\n\n- **编译时期异常**:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)\n- **运行时期异常**:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)\n\n​    ![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png)\n\n## 1.4     异常的产生过程解析\n\n先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。\n\n 工具类\n\n```java\npublic class ArrayTools {\n    // 对给定的数组通过给定的角标获取元素。\n    public static int getElement(int[] arr, int index) {\n        int element = arr[index];\n        return element;\n    }\n}\n```\n\n 测试类\n\n```java\npublic class ExceptionDemo {\n    public static void main(String[] args) {\n        int[] arr = { 34, 12, 67 };\n        intnum = ArrayTools.getElement(arr, 4)\n        System.out.println(\"num=\" + num);\n        System.out.println(\"over\");\n    }\n}\n```\n\n上述程序执行过程图解：\n\n ![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png)\n\n# 第二章 异常的处理\n\nJava异常处理的五个关键字：**try、catch、finally、throw、throws**\n\n## 2.1 \t抛出异常throw\n\n在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。\n\n在java中，提供了一个**throw**关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？\n\n1. 创建一个异常对象。封装一些提示信息(信息可以自己编写)。\n\n2. 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。\n\n   throw**用在方法内**，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。\n\n**使用格式：**\n\n```\nthrow new 异常类名(参数);\n```\n\n 例如：\n\n```java\nthrow new NullPointerException(\"要访问的arr数组不存在\");\n\nthrow new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\");\n```\n\n学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。\n\n```java\npublic class ThrowDemo {\n    public static void main(String[] args) {\n        //创建一个数组 \n        int[] arr = {2,4,52,2};\n        //根据索引找对应的元素 \n        int index = 4;\n        int element = getElement(arr, index);\n\n        System.out.println(element);\n        System.out.println(\"over\");\n    }\n    /*\n     * 根据 索引找到数组中对应的元素\n     */\n    public static int getElement(int[] arr,int index){ \n       \t//判断  索引是否越界\n        if(index<0 || index>arr.length-1){\n             /*\n             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。\n             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 \n              */\n             throw new ArrayIndexOutOfBoundsException(\"哥们，角标越界了~~~\");\n        }\n        int element = arr[index];\n        return element;\n    }\n}\n```\n\n> 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。\n>\n> 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。\n\n## 2.2 Objects非空判断\n\n还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。\n\n- `public static <T> T requireNonNull(T obj)`:查看指定引用对象不是null。\n\n查看源码发现这里对为null的进行了抛出异常操作：\n\n```java\npublic static <T> T requireNonNull(T obj) {\n    if (obj == null)\n      \tthrow new NullPointerException();\n    return obj;\n}\n```\n\n## 2.3  声明异常throws\n\n**声明异常**：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。\n\n关键字**throws**运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).\n\n**声明异常格式：**\n\n```\n修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }\t\n```\n\n声明异常的代码演示：\n\n```java\npublic class ThrowsDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        read(\"a.txt\");\n    }\n\n    // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n```\n\nthrows用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。\n\n```java\npublic class ThrowsDemo2 {\n    public static void main(String[] args) throws IOException {\n        read(\"a.txt\");\n    }\n\n    public static void read(String path)throws FileNotFoundException, IOException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n        if (!path.equals(\"b.txt\")) {\n            throw new IOException();\n        }\n    }\n}\n```\n\n## 2.4  捕获异常try…catch\n\n如果异常出现的话,会立刻终止程序,所以我们得处理异常:\n\n1. 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。\n2. 在方法中使用try-catch的语句块来处理异常。\n\n**try-catch**的方式就是捕获异常。\n\n- **捕获异常**：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。\n\n捕获异常语法如下：\n\n```java\ntry{\n     编写可能会出现异常的代码\n}catch(异常类型  e){\n     处理异常的代码\n     //记录日志/打印异常信息/继续抛出异常\n}\n```\n\n**try：**该代码块中编写可能产生异常的代码。\n\n**catch：**用来进行某种异常的捕获，实现对捕获到的异常进行处理。\n\n> 注意:try和catch都不能单独使用,必须连用。\n\n演示如下：\n\n```java\npublic class TryCatchDemo {\n    public static void main(String[] args) {\n        try {// 当产生异常时，必须有处理方式。要么捕获，要么声明。\n            read(\"b.txt\");\n        } catch (FileNotFoundException e) {// 括号中需要定义什么呢？\n          \t//try中抛出的是什么异常，在括号中就定义什么异常类型\n            System.out.println(e);\n        }\n        System.out.println(\"over\");\n    }\n    /*\n     *\n     * 我们 当前的这个方法中 有异常  有编译期异常\n     */\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n```\n\n如何获取异常信息：\n\nThrowable类中定义了一些查看方法:\n\n- `public String getMessage()`:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。\n\n- `public String toString()`:获取异常的类型和异常描述信息(不用)。\n- `public void printStackTrace()`:打印异常的跟踪栈信息并输出到控制台。\n\n​            *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*\n\n## 2.4 finally 代码块\n\n**finally**：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。\n\n什么时候的代码必须最终执行？\n\n当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。\n\nfinally的语法:\n\n try...catch....finally:自身需要处理异常,最终还得关闭资源。\n\n> 注意:finally不能单独使用。\n\n比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。\n\nfinally代码参考如下：\n\n```java\npublic class TryCatchDemo4 {\n    public static void main(String[] args) {\n        try {\n            read(\"a.txt\");\n        } catch (FileNotFoundException e) {\n            //抓取到的是编译期异常  抛出去的是运行期 \n            throw new RuntimeException(e);\n        } finally {\n            System.out.println(\"不管程序怎样，这里都将会被执行。\");\n        }\n        System.out.println(\"over\");\n    }\n    /*\n     *\n     * 我们 当前的这个方法中 有异常  有编译期异常\n     */\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n```\n\n> 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E6%AD%BB%E4%BA%86%E9%83%BD%E8%A6%81try.bmp)\n\n## 2.5   异常注意事项\n\n- 多个异常使用捕获又该如何处理呢？\n\n  1. 多个异常分别处理。\n  2. 多个异常一次捕获，多次处理。\n  3. 多个异常一次捕获一次处理。\n\n  一般我们是使用一次捕获多次处理方式，格式如下：\n\n  ```java\n  try{\n       编写可能会出现异常的代码\n  }catch(异常类型A  e){  当try中出现A类型异常,就用该catch来捕获.\n       处理异常的代码\n       //记录日志/打印异常信息/继续抛出异常\n  }catch(异常类型B  e){  当try中出现B类型异常,就用该catch来捕获.\n       处理异常的代码\n       //记录日志/打印异常信息/继续抛出异常\n  }\n  ```\n\n  > 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。\n\n- 运行时异常被抛出可以不处理。即不捕获也不声明抛出。\n\n- 如果finally有return语句,永远返回finally中的结果,避免该情况. \n\n- 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。\n\n- 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出\n\n# 第三章 自定义异常\n\n## 3.1 概述\n\n**为什么需要自定义异常类:**\n\n我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。\n\n在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？\n\n**什么是自定义异常类:**\n\n在开发中根据自己业务的异常情况来定义异常类.\n\n自定义一个业务逻辑异常: **RegisterException**。一个注册异常类。\n\n**异常类如何定义:**\n\n1. 自定义一个编译期异常: 自定义类 并继承于`java.lang.Exception`。\n2. 自定义一个运行时期的异常类:自定义类 并继承于`java.lang.RuntimeException`。\n\n## 3.2 自定义异常的练习\n\n要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。\n\n首先定义一个登陆异常类RegisterException：\n\n```java\n// 业务逻辑异常\npublic class RegisterException extends Exception {\n    /**\n     * 空参构造\n     */\n    public RegisterException() {\n    }\n\n    /**\n     *\n     * @param message 表示异常提示\n     */\n    public RegisterException(String message) {\n        super(message);\n    }\n}\n```\n\n模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。\n\n```java\npublic class Demo {\n    // 模拟数据库中已存在账号\n    private static String[] names = {\"bill\",\"hill\",\"jill\"};\n   \n    public static void main(String[] args) {     \n        //调用方法\n        try{\n              // 可能出现异常的代码\n            checkUsername(\"nill\");\n            System.out.println(\"注册成功\");//如果没有异常就是注册成功\n        }catch(RegisterException e){\n            //处理异常\n            e.printStackTrace();\n        }\n    }\n\n    //判断当前注册账号是否存在\n    //因为是编译期异常，又想调用者去处理 所以声明该异常\n    public static boolean checkUsername(String uname) throws LoginException{\n        for (String name : names) {\n            if(name.equals(uname)){//如果名字在这里面 就抛出登陆异常\n                throw new RegisterException(\"亲\"+name+\"已经被注册了！\");\n            }\n        }\n        return true;\n    }\n}\n```\n\n# 第四章 多线程\n\n我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？\n\n要解决上述问题,咱们得使用多进程或者多线程来解决.\n\n## 4.1 并发与并行\n\n- **并发**：指两个或多个事件在**同一个时间段内**发生。\n- **并行**：指两个或多个事件在**同一时刻**发生（同时发生）。\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91.bmp)\n\n在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。\n\n而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。\n\n> 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。\n\n## 4.2 线程与进程\n\n- **进程**：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。\n\n- **线程**：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 \n\n  简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 \n\n我们可以再电脑底部任务栏，右键----->打开任务管理器,可以查看当前任务的进程：\n\n**进程**\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5.png)\n\n**线程**\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png)\n\n**线程调度:**\n\n- 分时调度\n\n  所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。\n\n- 抢占式调度\n\n  优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。\n\n  - 设置线程的优先级\n\n  ![设置线程优先级](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.bmp)\n\n  - 抢占式调度详解\n\n    大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。\n\n    实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。\n    其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。\n\n    ![抢占式调度](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.bmp)\n\n## 4.3 创建线程类\n\nJava使用`java.lang.Thread`类代表**线程**，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来**创建**并**启动多线程**的步骤如下：\n\n1. 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。\n2. 创建Thread子类的实例，即创建了线程对象\n3. 调用线程对象的start()方法来启动该线程\n\n代码如下：\n\n测试类：\n\n```java\npublic class Demo01 {\n\tpublic static void main(String[] args) {\n\t\t//创建自定义线程对象\n\t\tMyThread mt = new MyThread(\"新的线程！\");\n\t\t//开启新线程\n\t\tmt.start();\n\t\t//在主方法中执行for循环\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tSystem.out.println(\"main线程！\"+i);\n\t\t}\n\t}\n}\n```\n\n自定义线程类：\n\n```java\npublic class MyThread extends Thread {\n\t//定义指定线程名称的构造方法\n\tpublic MyThread(String name) {\n\t\t//调用父类的String参数的构造方法，指定线程的名称\n\t\tsuper(name);\n\t}\n\t/**\n\t * 重写run方法，完成该线程执行的逻辑\n\t */\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tSystem.out.println(getName()+\"：正在执行！\"+i);\n\t\t}\n\t}\n}\n```","tags":["java"]},{"title":"java集合工具对自定义类进行排序","url":"/2019/05/11/java集合工具对自定义类进行排序/","content":"\n想要被排序的类需要实现Comparable接口并且重写compareTo方法。 this - 传进来的参数为升序。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n```java\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) throws ParseException {\n\n        List<User> list = new ArrayList<User>();\n        list.add(new User(65, \"小张\"));\n        list.add(new User(77, \"小强\"));\n        list.add(new User(39, \"小明\"));\n        list.add(new User(99, \"小红\"));\n        Collections.sort(list);\n        System.out.println(list);\n    }\n\n}\n\nclass User implements Comparable<User> {\n    private int score;\n    private String name;\n\n    public User(int score, String name) {\n\n        this.score = score;\n        this.name = name;\n    }\n\n    public int getScore() {\n        return score;\n    }\n\n    public void setScore(int score) {\n        this.score = score;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"score=\" + score +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n\n    @Override\n    public int compareTo(User o) {\n        return this.getScore() - o.getScore();\n    }\n}\n```\n\n","tags":["JAVA"]},{"title":"java常用类api","url":"/2019/05/10/java常用类api/","content":"\njava常用类api\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n#  Object类\n\n## 1.1 概述\n\n`java.lang.Object`类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。\n\n如果一个类没有特别指定父类，\t那么默认则继承自Object类。例如：\n\n```java\npublic class MyClass /*extends Object*/ {\n  \t// ...\n}\n```\n\n根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：\n\n- `public String toString()`：返回该对象的字符串表示。\n- `public boolean equals(Object obj)`：指示其他某个对象是否与此对象“相等”。\n\n## 1.2 toString方法\n\n### 方法摘要\n\n- `public String toString()`：返回该对象的字符串表示。\n\ntoString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。\n\n由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。\n\n### 覆盖重写\n\n如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：\n\n```java\npublic class Person {  \n    private String name;\n    private int age;\n\n    @Override\n    public String toString() {\n        return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}';\n    }\n\n    // 省略构造器与Getter Setter\n}\n```\n\n在IntelliJ IDEA中，可以点击`Code`菜单中的`Generate...`，也可以使用快捷键`alt+insert`，点击`toString()`选项。选择需要包含的成员变量并确定。如下图所示：\n\n> 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。\n\n## 1.3 equals方法\n\n### 方法摘要\n\n- `public boolean equals(Object obj)`：指示其他某个对象是否与此对象“相等”。\n\n调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。\n\n### 默认地址比较\n\n如果没有覆盖重写equals方法，那么Object类中默认进行`==`运算符的对象地址比较，只要不是同一个对象，结果必然为false。\n\n### 对象内容比较\n\n如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：\n\n```java\nimport java.util.Objects;\n\npublic class Person {\t\n\tprivate String name;\n\tprivate int age;\n\t\n    @Override\n    public boolean equals(Object o) {\n        // 如果对象地址一样，则认为相同\n        if (this == o)\n            return true;\n        // 如果参数为空，或者类型信息不一样，则认为不同\n        if (o == null || getClass() != o.getClass())\n            return false;\n        // 转换为当前类型\n        Person person = (Person) o;\n        // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果\n        return age == person.age && Objects.equals(name, person.name);\n    }\n}\n```\n\n这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用`Code`菜单中的`Generate…`选项，也可以使用快捷键`alt+insert`，并选择`equals() and hashCode()`进行自动代码生成。如下图所示：\n\n\n\n## 1.4 Objects类\n\n在刚才IDEA自动重写equals代码中，使用到了`java.util.Objects`类，那么这个类是什么呢？\n\n在**JDK7**添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。\n\n在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：\n\n- `public static boolean equals(Object a, Object b)`:判断两个对象是否相等。\n\n我们可以查看一下源码，学习一下：\n\n```java\npublic static boolean equals(Object a, Object b) {  \n    return (a == b) || (a != null && a.equals(b));  \n}\n```\n\n# 日期时间类\n\n## 2.1 Date类\n\n### 概述\n\n` java.util.Date`类 表示特定的瞬间，精确到毫秒。\n\n继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。\n\n- `public Date()`：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。\n- `public Date(long date)`：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。\n\n> tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。\n\n简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：\n\n```java\nimport java.util.Date;\n\npublic class Demo01Date {\n    public static void main(String[] args) {\n        // 创建日期对象，把当前的时间\n        System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018\n        // 创建日期对象，把当前的毫秒值转成日期对象\n        System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970\n    }\n}\n```\n\n> tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。\n\n### 常用方法\n\nDate类中的多数方法已经过时，常用的方法有：\n\n- `public long getTime()` 把日期对象转换成对应的时间毫秒值。\n\n## 2.2 DateFormat类\n\n`java.text.DateFormat` 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。\n\n- **格式化**：按照指定的格式，从Date对象转换为String对象。\n- **解析**：按照指定的格式，从String对象转换为Date对象。\n\n### 构造方法\n\n由于DateFormat为抽象类，不能直接使用，所以需要常用的子类`java.text.SimpleDateFormat`。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：\n\n- `public SimpleDateFormat(String pattern)`：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。\n\n参数pattern是一个字符串，代表日期时间的自定义格式。\n\n### 格式规则\n\n常用的格式规则为：\n\n| 标识字母（区分大小写） | 含义 |\n| ---------------------- | ---- |\n| y                      | 年   |\n| M                      | 月   |\n| d                      | 日   |\n| H                      | 时   |\n| m                      | 分   |\n| s                      | 秒   |\n\n> 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。\n\n创建SimpleDateFormat对象的代码如：\n\n```java\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\n\npublic class Demo02SimpleDateFormat {\n    public static void main(String[] args) {\n        // 对应的日期格式如：2018-01-16 15:06:38\n        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    }    \n}\n```\n\n### 常用方法\n\nDateFormat类的常用方法有：\n\n- `public String format(Date date)`：将Date对象格式化为字符串。\n- `public Date parse(String source)`：将字符串解析为Date对象。\n\n#### format方法\n\n使用format方法的代码为：\n\n```java\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n/*\n 把Date对象转换成String\n*/\npublic class Demo03DateFormatMethod {\n    public static void main(String[] args) {\n        Date date = new Date();\n        // 创建日期格式化对象,在获取格式化对象时可以指定风格\n        DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\");\n        String str = df.format(date);\n        System.out.println(str); // 2008年1月23日\n    }\n}\n```\n\n#### parse方法\n\n使用parse方法的代码为：\n\n```java\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n/*\n 把String转换成Date对象\n*/\npublic class Demo04DateFormatMethod {\n    public static void main(String[] args) throws ParseException {\n        DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\");\n        String str = \"2018年12月11日\";\n        Date date = df.parse(str);\n        System.out.println(date); // Tue Dec 11 00:00:00 CST 2018\n    }\n}\n```\n\n\n\n## 2.4 Calendar类\n\n### 概念\n\n日历我们都见过\n\n`java.util.Calendar`是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。\n\n### 获取方式\n\nCalendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：\n\nCalendar静态方法\n\n- `public static Calendar getInstance()`：使用默认时区和语言环境获得一个日历\n\n例如：\n\n```java\nimport java.util.Calendar;\n\npublic class Demo06CalendarInit {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n    }    \n}\n```\n\n### 常用方法\n\n根据Calendar类的API文档，常用方法有：\n\n- `public int get(int field)`：返回给定日历字段的值。\n- `public void set(int field, int value)`：将给定的日历字段设置为给定值。\n- `public abstract void add(int field, int amount)`：根据日历的规则，为给定的日历字段添加或减去指定的时间量。\n- `public Date getTime()`：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。\n\nCalendar类中提供很多成员常量，代表给定的日历字段：\n\n| 字段值       | 含义                                  |\n| ------------ | ------------------------------------- |\n| YEAR         | 年                                    |\n| MONTH        | 月（从0开始，可以+1使用）             |\n| DAY_OF_MONTH | 月中的天（几号）                      |\n| HOUR         | 时（12小时制）                        |\n| HOUR_OF_DAY  | 时（24小时制）                        |\n| MINUTE       | 分                                    |\n| SECOND       | 秒                                    |\n| DAY_OF_WEEK  | 周中的天（周几，周日为1，可以-1使用） |\n\n#### get/set方法\n\nget方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：\n\n```java\nimport java.util.Calendar;\n\npublic class CalendarUtil {\n    public static void main(String[] args) {\n        // 创建Calendar对象\n        Calendar cal = Calendar.getInstance();\n        // 设置年 \n        int year = cal.get(Calendar.YEAR);\n        // 设置月\n        int month = cal.get(Calendar.MONTH) + 1;\n        // 设置日\n        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\");\n    }    \n}\n```\n\n```java\nimport java.util.Calendar;\n\npublic class Demo07CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.YEAR, 2020);\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日\n    }\n}\n```\n\n#### add方法\n\nadd方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：\n\n```java\nimport java.util.Calendar;\n\npublic class Demo08CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日\n        // 使用add方法\n        cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天\n        cal.add(Calendar.YEAR, -3); // 减3年\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; \n    }\n}\n```\n\n#### getTime方法\n\nCalendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。\n\n```java\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class Demo09CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        Date date = cal.getTime();\n        System.out.println(date); // Tue Jan 16 16:03:09 CST 2018\n    }\n}\n```\n\n> 小贴士：\n>\n> ​     西方星期的开始为周日，中国为周一。\n>\n> ​     在Calendar类中，月份的表示是以0-11代表1-12月。\n>\n> ​     日期是有大小关系的，时间靠后，时间越大。\n\n#  System类\n\n`java.lang.System`类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：\n\n- `public static long currentTimeMillis()`：返回以毫秒为单位的当前时间。\n- `public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`：将数组中指定的数据拷贝到另一个数组中。\n\n## 3.1 currentTimeMillis方法\n\n实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值\n\n```java\nimport java.util.Date;\n\npublic class SystemDemo {\n    public static void main(String[] args) {\n       \t//获取当前时间毫秒值\n        System.out.println(System.currentTimeMillis()); // 1516090531144\n    }\n}\n```\n\n### 练习\n\n验证for循环打印数字1-9999所需要使用的时间（毫秒）\n\n```java\npublic class SystemTest1 {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 10000; i++) {\n            System.out.println(i);\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"共耗时毫秒：\" + (end - start));\n    }\n}\n```\n\n## 3.2 arraycopy方法\n\n- `public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`：将数组中指定的数据拷贝到另一个数组中。\n\n数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：\n\n| 参数序号 | 参数名称 | 参数类型 | 参数含义             |\n| -------- | -------- | -------- | -------------------- |\n| 1        | src      | Object   | 源数组               |\n| 2        | srcPos   | int      | 源数组索引起始位置   |\n| 3        | dest     | Object   | 目标数组             |\n| 4        | destPos  | int      | 目标数组索引起始位置 |\n| 5        | length   | int      | 复制元素个数         |\n\n### 练习\n\n将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]\n\n```java\nimport java.util.Arrays;\n\npublic class Demo11SystemArrayCopy {\n    public static void main(String[] args) {\n        int[] src = new int[]{1,2,3,4,5};\n        int[] dest = new int[]{6,7,8,9,10};\n        System.arraycopy( src, 0, dest, 0, 3);\n        /*代码运行后：两个数组中的元素发生了变化\n         src数组元素[1,2,3,4,5]\n         dest数组元素[1,2,3,9,10]\n        */\n    }\n}\n```\n\n# StringBuilder类\n\n## 4.1 字符串拼接问题\n\n由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：\n\n```java\npublic class StringDemo {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        s += \"World\";\n        System.out.println(s);\n    }\n}\n```\n\n在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。\n\n根据这句话分析我们的代码，其实总共产生了三个字符串，即`\"Hello\"`、`\"World\"`和`\"HelloWorld\"`。引用变量s首先指向`Hello`对象，最终指向拼接出来的新字符串对象，即`HelloWord` 。\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/03.%E5%B8%B8%E7%94%A8API%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/12.%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91/12.%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/img/String%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98.bmp)\n\n由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用`java.lang.StringBuilder`类。\n\n## 4.2 StringBuilder概述\n\n查阅`java.lang.StringBuilder`的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。\n\n原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。\n\n它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)\n\n![06-StringBuilder的原理](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/03.%E5%B8%B8%E7%94%A8API%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/12.%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91/12.%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/img/06-StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.png)\n\n## 4.3 构造方法\n\n根据StringBuilder的API文档，常用构造方法有2个：\n\n- `public StringBuilder()`：构造一个空的StringBuilder容器。\n- `public StringBuilder(String str)`：构造一个StringBuilder容器，并将字符串添加进去。\n\n```java\npublic class StringBuilderDemo {\n    public static void main(String[] args) {\n        StringBuilder sb1 = new StringBuilder();\n        System.out.println(sb1); // (空白)\n        // 使用带参构造\n        StringBuilder sb2 = new StringBuilder(\"itcast\");\n        System.out.println(sb2); // itcast\n    }\n}\n```\n\n## 4.4 常用方法\n\nStringBuilder常用的方法有2个：\n\n- `public StringBuilder append(...)`：添加任意类型数据的字符串形式，并返回当前对象自身。\n- `public String toString()`：将当前StringBuilder对象转换为String对象。\n\n### append方法\n\nappend方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：\n\n```java\npublic class Demo02StringBuilder {\n\tpublic static void main(String[] args) {\n\t\t//创建对象\n\t\tStringBuilder builder = new StringBuilder();\n\t\t//public StringBuilder append(任意类型)\n\t\tStringBuilder builder2 = builder.append(\"hello\");\n\t\t//对比一下\n\t\tSystem.out.println(\"builder:\"+builder);\n\t\tSystem.out.println(\"builder2:\"+builder2);\n\t\tSystem.out.println(builder == builder2); //true\n\t    // 可以添加 任何类型\n\t\tbuilder.append(\"hello\");\n\t\tbuilder.append(\"world\");\n\t\tbuilder.append(true);\n\t\tbuilder.append(100);\n\t\t// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。\n        // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下\n\t\t//链式编程\n\t\tbuilder.append(\"hello\").append(\"world\").append(true).append(100);\n\t\tSystem.out.println(\"builder:\"+builder);\n\t}\n}\n```\n\n> 备注：StringBuilder已经覆盖重写了Object当中的toString方法。\n\n### toString方法\n\n通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：\n\n```java\npublic class Demo16StringBuilder {\n    public static void main(String[] args) {\n        // 链式创建\n        StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\");\n        // 调用方法\n        String str = sb.toString();\n        System.out.println(str); // HelloWorldJava\n    }\n}\n```\n\n# 包装类\n\n## 5.1 概述\n\nJava提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：\n\n| 基本类型 | 对应的包装类（位于java.lang包中） |\n| -------- | --------------------------------- |\n| byte     | Byte                              |\n| short    | Short                             |\n| int      | **Integer**                       |\n| long     | Long                              |\n| float    | Float                             |\n| double   | Double                            |\n| char     | **Character**                     |\n| boolean  | Boolean                           |\n\n## 5.2 装箱与拆箱\n\n基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：\n\n- **装箱**：从基本类型转换为对应的包装类对象。\n- **拆箱**：从包装类对象转换为对应的基本类型。\n\n用Integer与 int为例：（看懂代码即可）\n\n基本数值---->包装对象\n\n```java\nInteger i = new Integer(4);//使用构造函数函数\nInteger iii = Integer.valueOf(4);//使用包装类中的valueOf方法\n```\n\n包装对象---->基本数值\n\n```java\nint num = i.intValue();\n```\n\n## 5.3自动装箱与自动拆箱\n\n由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：\n\n```java\nInteger i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);\ni = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;\n//加法运算完成后，再次装箱，把基本数值转成对象。\n```\n\n## 5.3 基本类型与字符串之间的转换\n\n### 基本类型转换为String\n\n   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： \n\n```\n基本类型直接与””相连接即可；如：34+\"\"\n```\n\nString转换成对应的基本类型 \n\n除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：\n\n- `public static byte parseByte(String s)`：将字符串参数转换为对应的byte基本类型。\n- `public static short parseShort(String s)`：将字符串参数转换为对应的short基本类型。\n- `public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。\n- `public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。\n- `public static float parseFloat(String s)`：将字符串参数转换为对应的float基本类型。\n- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。\n- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的boolean基本类型。\n\n代码使用（仅以Integer类的静态方法parseXxx为例）如：\n\n```java\npublic class Demo18WrapperParse {\n    public static void main(String[] args) {\n        int num = Integer.parseInt(\"100\");\n    }\n}\n```\n\n> 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。\n\n","tags":["java"]},{"title":"Spring Bootd单/多文件上传","url":"/2019/05/06/Spring-Boot单文件上传/","content":"\nSpring Bootd单/多文件上传\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 单/多文件上传\n\nupload.html：\n\n```html\n<!DOCTYPE HTML>\n<html>\n<head>\n    <title>文件上传</title>\n</head>\n\n<body>\n<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">\n    上传文件1：<input type=\"file\" name=\"file\"><br/>\n    <input type=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n\n\nUploadController:\n\n```java\npackage com.example.demo.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.multipart.MultipartFile;\nimport org.springframework.web.multipart.MultipartHttpServletRequest;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\n\n@Controller\npublic class UploadController {\n    @GetMapping(\"/upload\")\n    public String upload() {\n        return \"upload\";\n    }\n\n    @GetMapping(\"/multiUpload\")\n    public String multiUpload() {\n        return \"multiUpload\";\n    }\n\n\n    @PostMapping(\"/multiUpload\")\n    @ResponseBody\n    public String multiUpload(HttpServletRequest request) {\n        List<MultipartFile> files = ((MultipartHttpServletRequest) request).getFiles(\"file\");\n        String filePath = \"D:/path/\";\n        for (int i = 0; i < files.size(); i++) {\n            MultipartFile file = files.get(i);\n            if (file.isEmpty()) {\n                return \"上传第\" + (i++) + \"个文件失败\";\n            }\n            String fileName = file.getOriginalFilename();\n\n            File dest = new File(filePath + fileName);\n            try {\n                file.transferTo(dest);\n            } catch (IOException e) {\n                return \"上传第\" + (i++) + \"个文件失败\";\n            }\n        }\n\n        return \"上传成功\";\n\n    }\n\n\n    @PostMapping(\"/upload\")\n    @ResponseBody\n    public String upload(@RequestParam(\"file\") MultipartFile file) {\n        if (file.isEmpty()) {\n            return \"上传失败，请选择文件\";\n        }\n\n        String fileName = file.getOriginalFilename();\n        String filePath = \"D:/path/\";\n        File dest = new File(filePath + fileName);\n        try {\n            file.transferTo(dest);\n            return \"上传成功\";\n        } catch (IOException e) {\n        }\n        return \"上传失败！\";\n    }\n}\n\n\n```\n\n\n\nmultiUpload.html\n\n```html\n<!DOCTYPE HTML>\n<html>\n<head>\n    <title>文件上传</title>\n</head>\n\n<body>\n<form action=\"/multiUpload\" enctype=\"multipart/form-data\" method=\"post\">\n    上传文件：<input type=\"file\" name=\"file\"><br/>\n    上传文件：<input type=\"file\" name=\"file\"><br/>\n    上传文件：<input type=\"file\" name=\"file\"><br/>\n    上传文件：<input type=\"file\" name=\"file\"><br/>\n    <input type=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n\n\n\n\n\n\n## 设置上传文件大小的两种方式\n\n### springboot 1.5.X系列处理方式\n\n#### 创建tomcat配置类\n\n```java\n @Bean  \n    public MultipartConfigElement multipartConfigElement() {  \n        MultipartConfigFactory factory = new MultipartConfigFactory();  \n        //文件最大  \n        factory.setMaxFileSize(\"10240KB\"); //KB,MB  \n        /// 设置总上传数据总大小  \n        factory.setMaxRequestSize(\"102400KB\");  \n        return factory.createMultipartConfig();  \n    }  \n```\n\n**注意**\nspring.http.multipart.maxFileSize=10Mb\nspring.http.multipart.maxRequestSize=10Mb\n已经过期 >>>>\n\n#### **在application.properties中添加如下配置信息**\n\napplication.properties\n\n```xml\n spring.servlet.multipart.max-file-size=20MB\n spring.servlet.multipart.max-request-size=20MB\n```\n\nmaxFileSize 是单个文件大小\nmaxRequestSize是设置总上传的数据大小\n\n\n\n### Springboot 2.X系列配置\n\n#### 创建tomcat配置类\n\n```java\n\n@Configuration\npublic class TomcatConfig {\n\n\n    @Bean\n    public MultipartConfigElement multipartConfigElement() {\n        MultipartConfigFactory factory = new MultipartConfigFactory();\n        //文件最大10M,DataUnit提供5中类型B,KB,MB,GB,TB\n        factory.setMaxFileSize(DataSize.of(100, DataUnit.MEGABYTES));\n        /// 设置总上传数据总大小10M\n        factory.setMaxRequestSize(DataSize.of(100, DataUnit.MEGABYTES));\n        return factory.createMultipartConfig();\n    }\n}\n```\n\n#### 配置文件配置\n\napplication.properties\n\n```xml\n   spring.servlet.multipart.max-file-size=20MB\n   spring.servlet.multipart.max-request-size=20MB\n```\n\n\n\n","tags":["Sprint Boot"]},{"title":"JAVAWEB文件上传","url":"/2019/05/06/form表单文件上传/","content":"\n对于文件上传，浏览器在上传的过程中是将文件以流的形式提交到服务器端的，如果直接使用Servlet获取上传文件的输入流然后再解析里面的请求参数是比较麻烦，所以一般选择采用apache的开源工具common-fileupload这个文件上传组件。这个common-fileupload上传组件的jar包可以去apache官网上面下载，也可以在struts的lib文件夹下面找到，struts上传的功能就是基于这个实现的。common-fileupload是依赖于common-io这个包的，所以还需要下载这个包。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\nUploadHandleServlet的代码如下：\n\n```java\npackage me.gacl.web.controller;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.UUID;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadBase;\nimport org.apache.commons.fileupload.ProgressListener;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n* @ClassName: UploadHandleServlet\n*\n*/ \npublic class UploadHandleServlet extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n                //得到上传文件的保存目录，将上传的文件存放于WEB-INF目录下，不允许外界直接访问，保证上传文件的安全\n                String savePath = this.getServletContext().getRealPath(\"/WEB-INF/upload\");\n                //上传时生成的临时文件保存目录\n                String tempPath = this.getServletContext().getRealPath(\"/WEB-INF/temp\");\n                File tmpFile = new File(tempPath);\n                if (!tmpFile.exists()) {\n                    //创建临时目录\n                    tmpFile.mkdir();\n                }\n                \n                //消息提示\n                String message = \"\";\n                try{\n                    //使用Apache文件上传组件处理文件上传步骤：\n                    //1、创建一个DiskFileItemFactory工厂\n                    DiskFileItemFactory factory = new DiskFileItemFactory();\n                    //设置工厂的缓冲区的大小，当上传的文件大小超过缓冲区的大小时，就会生成一个临时文件存放到指定的临时目录当中。\n                    factory.setSizeThreshold(1024*100);//设置缓冲区的大小为100KB，如果不指定，那么缓冲区的大小默认是10KB\n                    //设置上传时生成的临时文件的保存目录\n                    factory.setRepository(tmpFile);\n                    //2、创建一个文件上传解析器\n                    ServletFileUpload upload = new ServletFileUpload(factory);\n                    //监听文件上传进度\n                    upload.setProgressListener(new ProgressListener(){\n                        public void update(long pBytesRead, long pContentLength, int arg2) {\n                            System.out.println(\"文件大小为：\" + pContentLength + \",当前已处理：\" + pBytesRead);\n                            /**\n                             * 文件大小为：14608,当前已处理：4096\n                                文件大小为：14608,当前已处理：7367\n                                文件大小为：14608,当前已处理：11419\n                                文件大小为：14608,当前已处理：14608\n                             */\n                        }\n                    });\n                     //解决上传文件名的中文乱码\n                    upload.setHeaderEncoding(\"UTF-8\"); \n                    //3、判断提交上来的数据是否是上传表单的数据\n                    if(!ServletFileUpload.isMultipartContent(request)){\n                        //按照传统方式获取数据\n                        return;\n                    }\n                    \n                    //设置上传单个文件的大小的最大值，目前是设置为1024*1024字节，也就是1MB\n                    upload.setFileSizeMax(1024*1024);\n                    //设置上传文件总量的最大值，最大值=同时上传的多个文件的大小的最大值的和，目前设置为10MB\n                    upload.setSizeMax(1024*1024*10);\n                    //4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List<FileItem>集合，每一个FileItem对应一个Form表单的输入项\n                    List<FileItem> list = upload.parseRequest(request);\n                    for(FileItem item : list){\n                        //如果fileitem中封装的是普通输入项的数据\n                        if(item.isFormField()){\n                            String name = item.getFieldName();\n                            //解决普通输入项的数据的中文乱码问题\n                            String value = item.getString(\"UTF-8\");\n                            //value = new String(value.getBytes(\"iso8859-1\"),\"UTF-8\");\n                            System.out.println(name + \"=\" + value);\n                        }else{//如果fileitem中封装的是上传文件\n                            //得到上传的文件名称，\n                            String filename = item.getName();\n                            System.out.println(filename);\n                            if(filename==null || filename.trim().equals(\"\")){\n                                continue;\n                            }\n                            //注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如：  c:\\a\\b\\1.txt，而有些只是单纯的文件名，如：1.txt\n                            //处理获取到的上传文件的文件名的路径部分，只保留文件名部分\n                            filename = filename.substring(filename.lastIndexOf(\"\\\\\")+1);\n                            //得到上传文件的扩展名\n                            String fileExtName = filename.substring(filename.lastIndexOf(\".\")+1);\n                            //如果需要限制上传的文件类型，那么可以通过文件的扩展名来判断上传的文件类型是否合法\n                            System.out.println(\"上传的文件的扩展名是：\"+fileExtName);\n                            //获取item中的上传文件的输入流\n                            InputStream in = item.getInputStream();\n                            //得到文件保存的名称\n                            String saveFilename = makeFileName(filename);\n                            //得到文件的保存目录\n                            String realSavePath = makePath(saveFilename, savePath);\n                            //创建一个文件输出流\n                            FileOutputStream out = new FileOutputStream(realSavePath + \"\\\\\" + saveFilename);\n                            //创建一个缓冲区\n                            byte buffer[] = new byte[1024];\n                            //判断输入流中的数据是否已经读完的标识\n                            int len = 0;\n                            //循环将输入流读入到缓冲区当中，(len=in.read(buffer))>0就表示in里面还有数据\n                            while((len=in.read(buffer))>0){\n                                //使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath + \"\\\\\" + filename)当中\n                                out.write(buffer, 0, len);\n                            }\n                            //关闭输入流\n                            in.close();\n                            //关闭输出流\n                            out.close();\n                            //删除处理文件上传时生成的临时文件\n                            //item.delete();\n                            message = \"文件上传成功！\";\n                        }\n                    }\n                }catch (FileUploadBase.FileSizeLimitExceededException e) {\n                    e.printStackTrace();\n                    request.setAttribute(\"message\", \"单个文件超出最大值！！！\");\n                    request.getRequestDispatcher(\"/message.jsp\").forward(request, response);\n                    return;\n                }catch (FileUploadBase.SizeLimitExceededException e) {\n                    e.printStackTrace();\n                    request.setAttribute(\"message\", \"上传文件的总的大小超出限制的最大值！！！\");\n                    request.getRequestDispatcher(\"/message.jsp\").forward(request, response);\n                    return;\n                }catch (Exception e) {\n                    message= \"文件上传失败！\";\n                    e.printStackTrace();\n                }\n                request.setAttribute(\"message\",message);\n                request.getRequestDispatcher(\"/message.jsp\").forward(request, response);\n    }\n    \n    /**\n    * @Method: makeFileName\n    */ \n    private String makeFileName(String filename){  //2.jpg\n        //为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名\n        return UUID.randomUUID().toString() + \"_\" + filename;\n    }\n    \n    /**\n     * 为防止一个目录下面出现太多文件，要使用hash算法打散存储\n    */ \n    private String makePath(String filename,String savePath){\n        //得到文件名的hashCode的值，得到的就是filename这个字符串对象在内存中的地址\n        int hashcode = filename.hashCode();\n        int dir1 = hashcode&0xf;  //0--15\n        int dir2 = (hashcode&0xf0)>>4;  //0-15\n        //构造新的保存目录\n        String dir = savePath + \"\\\\\" + dir1 + \"\\\\\" + dir2;  //upload\\2\\3  upload\\3\\5\n        //File既可以代表文件也可以代表目录\n        File file = new File(dir);\n        //如果目录不存在\n        if(!file.exists()){\n            //创建目录\n            file.mkdirs();\n        }\n        return dir;\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        doGet(request, response);\n    }\n}\n```\n\n\n\nupload.jsp页面的代码如下：\n\n```html\n<%@ page language=\"java\" pageEncoding=\"UTF-8\"%>\n<!DOCTYPE HTML>\n<html>\n  <head>\n    <title>文件上传</title>\n  </head>\n  \n  <body>\n    <form action=\"${pageContext.request.contextPath}/servlet/UploadHandleServlet\" enctype=\"multipart/form-data\" method=\"post\">\n        上传用户：<input type=\"text\" name=\"username\"><br/>\n        上传文件1：<input type=\"file\" name=\"file1\"><br/>\n        上传文件2：<input type=\"file\" name=\"file2\"><br/>\n        <input type=\"submit\" value=\"提交\">\n    </form>\n  </body>\n</html>\n```\n\n\n\n","tags":["JAVA"]},{"title":"vue学习笔记(二)","url":"/2019/04/19/vue学习笔记-二/","content":"\nVue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与[现代化的工具链](https://cn.vuejs.org/v2/guide/single-file-components.html)以及各种[支持类库](https://github.com/vuejs/awesome-vue#libraries--plugins)结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## Class与Style绑定\n\n### 绑定HTML Class\n\n#### 对象语法\n\n可以传给v-bind:class一个对象,动态的切换class:\n\n```html\n<div class=\"static\" id = \"div1\"  v-bind:class=\"{'active': isActive, 'text-danger' : hasError}\">\n\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#div1',\n\t\t\t\tdata:{\n\t\t\t\t\tisActive : true,\n\t\t\t\t\thasError : true\n\t\t\t\t}\n\t\t\t})\n```\n\n当对应的属性的值为true的时候,div的class里就会增加相应的格式,上述例子的class为:\n\n```html\nstatic active text-danger\n```\n\n\n\n绑定的数据对象不必内联定义在模板里：\n\n```html\n<div id=\"div2\" v-bind:class=\"classObject\"></div>\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#div2',\n\t\t\t\tdata:{\n\t\t\t\tclassObject:{\n\t\t\t\t\tavtive:true,\n\t\t\t\t\t'text-danger':true\n\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t})\n```\n\n 也可以使 div   class=\"avtive text-danger\"\n\n我们也可以在这里绑定一个返回对象的计算属性:\n\n```java\n<div id=\"div3\" v-bind:class=\"classObject3\"></div>\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#div3',\n\t\t\t\tdata:{\n\t\t\t\t\tisActive:true,\n\t\t\t\t\terror: null\n\t\t\t\t},\n\t\t\t\tcomputed:{\n\t\t\t\t\tclassObject3:function(){\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tactive:this.isActive&&!this.error,'text-danger':this.error&&this.error.type ==='fatal'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t)\n```\n\n\n\n#### 数组语法:\n\n我们可以把一个数组传给v-bind:class,以应用一个class列表:\n\n```html\n<div id = \"div4\" v-bind:class=\"[activeClass, errorClass]\">div4</div>\n\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#div4',\n\t\t\t\tdata:{\n\t\t\t\t\tactiveClass: 'active',\n\t\t\t\t\terrorClass: 'text-danger'\n\t\t\t\t}\n\t\t\t})\n```\n\n\n\n也可以用三元表达式来按条件切换class\n\n```html\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n```\n\n\n\n#### 用在组件上\n\n当在一个自定义组件上使用 `class` 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。\n\n例如，如果你声明了这个组件：\n\n```\nVue.component('my-component', {\n  template: '<p class=\"foo bar\">Hi</p>'\n})\n```\n\n然后在使用它的时候添加一些 class：\n\n```\n<my-component class=\"baz boo\"></my-component>\n```\n\nHTML 将被渲染为:\n\n```html\n<p class=\"foo bar baz boo\">Hi</p>\n```\n\nhtml对于带数据绑定 class 也同样适用：\n\n```html\n<my-component v-bind:class=\"{ active: isActive }\"></my-component>\n```\n\n当 `isActive` 为 truthy[[1\\]](https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1) 时，HTML 将被渲染成为：\n\n```html\n<p class=\"foo bar active\">Hi</p>\n```\n\n\n\n### 绑定内联样式\n\n#### 对象语法\n\n```html\n\t\t<div id=\"div5\" v-bind:style=\"{color: activeColor, fontSize:fontSize + 'px'}\"> div5</div>\n\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel: '#div5',\n\t\t\t\tdata: {\n\t\t\t\t\tactiveColor: 'red',\n\t\t\t\t\tfontSize: 30\n\t\t\t\t}\n\n\t\t\t})\n\n```\n\n\n\n直接绑定到一个样式对象会让模板更清晰：\n\n```html\n\t\t<div id=\"div6\" v-bind:style=\"styleObject\"> div6</div>\n\n\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel: '#div6',\n\t\t\t\tdata: {\n\t\t\t\t\tstyleObject:{\n\t\t\t\t\t\tcolor: 'red',\n\t\t\t\t\t\tfontSize: '30px'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\n```\n\n\n\n#### 数组语法\n\nv-bind:style的数组语法可以将多个样式对象应用到同一个元素上:\n\n#### 数组语法\n\n`v-bind:style` 的数组语法可以将多个样式对象应用到同一个元素上：\n\n```html\n<div v-bind:style=\"[baseStyles, overridingStyles]\"></div>\n\n```\n\n#### 自动添加前缀\n\n当 `v-bind:style` 使用需要添加浏览器引擎前缀的 CSS 属性时，如 `transform`，Vue.js 会自动侦测并添加相应的前缀。\n\n\n\n## 条件渲染\n\n#### v-if\n\n```html\n\t\t<div id=\"example\">\n\t\t\t<p v-if=\"greeting\">\n\t\t\t\tDirective1\n\t\t\t</p>\n\t\t\t<p v-else=\"greeting\">\n\t\t\t\tDirective2\n\t\t\t</p>\n\t\t</div>\n\n```\n\n\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel: '#example',\n\t\t\t\tdata: {\n\t\t\t\t\tgreeting: true\n\t\t\t\t}\n\t\t\t});\n\n```\n\nv-else必须要和v-if匹配使用，v-else不能单独使用。\n只有v-if的值为false时，v-else模块才会显示出来。\n\n因为 `v-if` 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 `<template>` 元素当做不可见的包裹元素，并在上面使用 `v-if`。最终的渲染结果将不包含 `<template>` 元素。\n\n#### 在template 元素上使用v-if 条件渲染分组\n\n```html\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n\n```\n\n\n\n#### v-else-if\n\n`v-else-if`，顾名思义，充当 `v-if` 的“else-if 块”，可以连续使用：\n\n```html\n<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else-if=\"type === 'C'\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n\n```\n\n\n\n#### 用key管理可复用的元素\n\nVue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：\n\n```html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\">\n</template>\n\n```\n\n\n\n添加一个具有唯一值的 `key` 属性,每次切换时，输入框都将被重新渲染。\n\n```html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\" key=\"username-input\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\" key=\"email-input\">\n</template>\n\n```\n\n#### v-show\n\n`v-show` 只是简单地切换元素的 CSS 属性 `display`。\n\n```html\n<h1 v-show=\"ok\">Hello!</h1>\n\n```\n\n v-if 和v-show区别\n\n`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\n\n\n\n\n\n\n\n\n\n","tags":["vue.js"]},{"title":"vue学习笔记(一)","url":"/2019/04/18/vue学习笔记-一/","content":"\nVue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与[现代化的工具链](https://cn.vuejs.org/v2/guide/single-file-components.html)以及各种[支持类库](https://github.com/vuejs/awesome-vue#libraries--plugins)结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 引入vue\n\n可以通过如下方式引入vue\n\n<!-- 开发环境版本，包含了有帮助的命令行警告 -->\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n\n或者\n\n<!-- 生产环境版本，优化了尺寸和速度 -->\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue\"></script>\n\n或者去\n\n[vue git仓库]: https://github.com/vuejs/vue\n\n下载vue.js文件本地引入\n\n\n\n## vue的使用:\n\n### 创建vue实例:\n\n```js\n\t\tvar vm = new Vue({\n\t\t\tel: '#app',\n\t\t\tdata: {\n\t\t\t\tmessage: 'hello Vue.js'\n\t\t\t}\n\t\t})\n```\n对应的html的id为app的div:\n\n```html\n        <div id=\"app\">\n            <p>{{message}}</p>  \n        </div>\n```\n当运行时,message会被替换为data中的 message的值 'hello Vue.js' ,值得注意的是使用双大括号会把值解析为纯文本,所以即使Vue的定义为:\n\n```javascript\n\tvar vm = new Vue({\n\t\tel: '#app',\n\t\tdata: {\n\t\t\tmessage: '<h1>标题</h1>'\n\t\t}\n\t})\n```\nmessage的值也会被解析为<h1>标题</h1> 文本,而不会被解析为html的格式\n\n### 数据与方法:\n\n当一个 Vue 实例被创建时，它将 `data` 对象中的所有的属性加入到 Vue 的**响应式系统**中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。\n\n\t\t<div id=\"app1\">\n\t\t\t{{data}}\n\t\t</div>\n\n\n```html\n\t<script>\n\t\tvar data = \"1\"\n\t\tvar vm = new Vue({\n\t\t\tel: '#app1',\n\t\t\tdata: data\n\t\t})\n\t</script>\n```\n在上述代码中,我们在js控制台中无论改变data的值或者vm.data的值,两者都会一起改变.值得注意的是只有当实例被创建时 `data` 中存在的属性才是**响应式**的。也就是说如果你添加一个新的属性，比如： vm.b = 'hi'那么对 `b` 的改动将不会触发任何视图的更新。\n\n除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 `$`，以便与用户定义的属性区分开来。例如：\n\n```js\nvar data = { a: 1 }\nvar vm = new Vue({\n  el: '#example',\n  data: data\n})\n\nvm.$data === data // => true\nvm.$el === document.getElementById('example') // => true\n\n// $watch 是一个实例方法\nvm.$watch('a', function (newValue, oldValue) {\n  // 这个回调将在 `vm.a` 改变后调用\n})\n```\n\n### 生命周期钩子:\n\n例如create 可以用来在一个实例被创建之后执行代码,：\n\n```js\nnew Vue({\n  data: {\n    a: 1\n  },\n  created: function () {\n    // `this` 指向 vm 实例\n    console.log('a is: ' + this.a)\n  }\n})\n```\n\n\n\n| 钩子          |                                                              |\n| ------------- | ------------------------------------------------------------ |\n| beforeCreate  | 创建实例之前执行                                             |\n| created       | 实例创建完成后执行                                           |\n| beforeMount   | 将编译完成的HTML挂载到对应虚拟dom时触发的钩子,此时页面并没有内容 |\n| mounted       | 将编译完成的HTML挂载到页面完成后执行的钩子,此时钩子函数中一般会做一些ajax请求获取数据进行数据初始化,mounted在整个实例中只执行一次 |\n| beforeUpdate  | 实时监控数据变化并随之更新DOM                                |\n| updated       | 更新之后的钩子                                               |\n| beforeDestroy | 实例销毁之前执行的钩子                                       |\n| destroyed     | 实例销毁完成执行的钩子                                       |\n\n### 使用JavaScript表达式:\n\n对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。\n\n```js\n{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div v-bind:id=\"'list-' + id\"></div>\n```\n\n这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含**单个表达式**，所以下面的例子都**不会**生效。\n\n```html\n<!-- 这是语句，不是表达式 -->\n{{ var a = 1 }}\n\n<!-- 流控制也不会生效，请使用三元表达式 -->\n{{ if (ok) { return message } }}\n\n```\n\n### 指令:\n\n指令 (Directives) 是带有 `v-` 前缀的特殊特性。指令特性的值预期是**单个 JavaScript 表达式** (`v-for` 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。\n\n```html\n\t\t<div id=\"app2\">\n\t\t\t<span v-bind:title=\"message\">\n\t\t\t\t鼠标悬停几秒钟查看此处动态绑定的提示信息;\n\t\t\t</span>\n\n\t\t</div>\t\t\n\n\t\t<div id=\"app3\">\n\t\t\t<p v-if=\"seen\">现在你看到我了</p>\n\t\t</div>\n\n\t\t<div id=\"app4\">\n\t\t\t<ol>\n\t\t\t\t<li v-for=\"todo in todos\">\n\t\t\t\t\t{{todo.text}}\n\t\t\t\t</li>\n\t\t\t</ol>\n\t\t</div>\n\n\t\t<div id=\"app5\">\n\t\t\t<p>\n\t\t\t\t{{message}}\n\t\t\t</p>\n\t\t\t<button v-on:click=\"reverseMessage\"> 逆转消息</button>\n\t\t</div>\n\n```\n\n\n\n```js\n\t\tvar app2 = new Vue({\n\t\t\tel: '#app2',\n\t\t\tdata: {\n\t\t\t\tmessage: '页面加载于' + new Date().toLocaleDateString()\n\t\t\t}\n\t\t})\t\n        \n\t\tvar app3 = new Vue({\n\t\t\tel: '#app3',\n\t\t\tdata: {\n\t\t\t\tseen: true\n\t\t\t}\n\t\t})\n\n\n\t\tvar app4 = new Vue({\n\t\t\tel: '#app4',\n\t\t\tdata: {\n\t\t\t\ttodos: [{\n\t\t\t\t\t\ttext: '学习javascript'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttext: '学习vue'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttext: '整个牛项目'\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t})\n\n\n\t\tvar app5 = new Vue({\n\t\t\tel: '#app5',\n\t\t\tdata: {\n\t\t\t\tmessage: 'Hello Vue.js'\n\t\t\t},\n\t\t\tmethods: {\n\t\t\t\treverseMessage: function() {\n\t\t\t\t\tthis.message = this.message.split('').reverse().join('')\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n```\n\n\n\n在app2,app3,app4.app5中分别实现了绑定鼠标事件,if判断,for循环,函数功能\n\n### 动态参数:\n\n```html\n\t\t<a id = \"a1\" v-bind:[url]=\"url\"> ... </a>\t<br>\n\t\t<a id = \"a2\" v-on:[name]=\"doSomething\"> ... </a>\n\n```\n\n\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#a1',\n\t\t\t\tdata:{\n\t\t\t\t\turl:'href'\n\t\t\t\t}\n\t\t\t})\t\t\t\t\n\n\t\t\tnew Vue({\n\t\t\t\tel:'#a2',\n\t\t\t\tdata:{\n\t\t\t\t\tname:'dblclick'\n\t\t\t\t},\n\t\t\t\tmethods:{\n\t\t\t\t\tdoSomething : function (){\n\t\t\t\t\t\talert(\"函数执行\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t\n\t\t\t\n```\n\n从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：\n\na1 中 v-bind:[url] ,中括号内的url会被替换为Vue中定义的url值:href\n\na2中v-on:[name],中括号内的name会被替换为Vue中定义的name值:dblclick\n\n","tags":["vue.js"]},{"title":"org.springframework.expression.spel.SpelEvaluationException: EL1008E:","url":"/2019/04/15/org-springframework-expression-spel-SpelEvaluationException-EL1008E/","content":"\n今天发生了一个很诡异的事情,在进行thymeleaf进行前端视图显示的时候总是出现SpelEvaluationException异常.刚开始以为自己的属性名字填错了,经过反复确认发现没填错.后来考虑是不是get方法的问题.去类里一看,果真是get方法出了问题.\n\n\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n正确的get方法是\n\n```java\n    public Long getDid() {\n        return did;\n    }\n```\n\n然而我的get方法是从原来改的,当时为了省劲就直接把名字改了改,直接输入了did,导致在使用${dept.did}时找不到did属性\n\n```java\n    public Long getdid() {\n        return did;\n    }\n```\n\n\n\n\n\n## 错误信息:\n\n```java\n\n\norg.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field 'did' cannot be found on object of type 'com.caicai.aidangjian.entity.Department' - maybe not public or not valid?\n\tat org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:217) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:51) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:406) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:90) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:109) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:328) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:263) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:144) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.OpenElementTag.beHandled(OpenElementTag.java:205) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.Model.process(Model.java:290) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.IteratedGatheringModelProcessable.processIterationModel(IteratedGatheringModelProcessable.java:367) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.IteratedGatheringModelProcessable.process(IteratedGatheringModelProcessable.java:221) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.ProcessorTemplateHandler.handleCloseElement(ProcessorTemplateHandler.java:1640) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleCloseElementEnd(TemplateHandlerAdapterMarkupHandler.java:388) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleCloseElementEnd(InlinedOutputExpressionMarkupHandler.java:322) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleCloseElementEnd(OutputExpressionInlinePreProcessorHandler.java:220) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleCloseElementEnd(InlinedOutputExpressionMarkupHandler.java:164) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.attoparser.HtmlElement.handleCloseElementEnd(HtmlElement.java:169) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.HtmlMarkupHandler.handleCloseElementEnd(HtmlMarkupHandler.java:412) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.MarkupEventProcessorHandler.handleCloseElementEnd(MarkupEventProcessorHandler.java:473) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.ParsingElementMarkupUtil.parseCloseElement(ParsingElementMarkupUtil.java:201) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:725) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1370) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1116) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1055) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_201]\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_201]\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_201]\n```\n\n\n\n## \n\n\n\n","tags":["Spring Boot"]},{"title":"JPA Space is not allowed after parameter prefix ':'","url":"/2019/04/14/JPA-Space-is-not-allowed-after-parameter-prefix/","content":"\n查询时候想根据分数排序并且添加对应的名词序号,所以mysql语句中出现了(@i:=@i+1),在navicat下可以正常的运行.但是在使用@Query时出现'JPA Space is not allowed after parameter prefix '':'''错误;\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n@Query注解如下:\n\n```java\n    @Query(value = \"select (@i:=@i+1)pm from record s,(select @i:=0)t  order by score desc;\",nativeQuery = true)\n\n```\n\n\n\n去查资料,解决方案是把:转义 变成//:\n\n\n\n```java\n@Query(value = \"select (@i\\\\:=@i+1)pm from record s,(select @i\\\\:=0)t  order by score desc;\",nativeQuery = true)\n```","tags":["Spring Boot","JPA"]},{"title":"Echarts 初体验","url":"/2019/04/13/Echarts-初体验/","content":"\nECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的矢量图形库 [ZRender](https://github.com/ecomfe/zrender)，提供直观，交互丰富，可高度个性化定制的数据可视化图表。\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 引入Echarts.js文件\n\n> Echarts.js文件可以到\n>\n> [echarts官网](<https://echarts.baidu.com/>)下载\n>\n> ```html\n> <script src=\"echarts.min.js\"></script>\n> ```\n>\n> \n\n## 准备一个存放图表的容器\n\n```html\n<div id=\"box\" style=\"width: 600px;height:400px;\"></div>\n```\n\n\n\n## 设置参数 初始化图表\n\n```html\n\t<script>\n    var myChart = echarts.init(document.getElementById(\"box\"));\n\tvar option = {\n\t\ttitle : {\n\t\t\ttext: '未来一周气温变化',\n\t\t\tsubtext: '纯属虚构'\n\t\t},\n\t\ttooltip : {\n\t\t\ttrigger: 'axis'\n\t\t},\n\t\tlegend: {\n\t\t\tdata:['最高气温','最低气温']\n\t\t},\n\t\ttoolbox: {\n\t\t\tshow : true,\n\t\t\tfeature : {\n\t\t\t\tmark : {show: true},\n\t\t\t\tdataView : {show: true, readOnly: false},\n\t\t\t\tmagicType : {show: true, type: ['line', 'bar']},\n\t\t\t\trestore : {show: true},\n\t\t\t\tsaveAsImage : {show: true}\n\t\t\t}\n\t\t},\n\t\tcalculable : true,\n\t\txAxis : [\n\t\t\t{\n\t\t\t\ttype : 'category',\n\t\t\t\tboundaryGap : false,\n\t\t\t\tdata : ['周一','周二','周三','周四','周五','周六','周日']\n\t\t\t}\n\t\t],\n\t\tyAxis : [\n\t\t\t{\n\t\t\t\ttype : 'value',\n\t\t\t\taxisLabel : {\n\t\t\t\t\tformatter: '{value} °C'\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\tseries : [\n\t\t\t{\n\t\t\t\tname:'最高气温',\n\t\t\t\ttype:'line',\n\t\t\t\tdata:[11, 11, 15, 13, 12, 13, 10],\n\t\t\t\tmarkPoint : {\n\t\t\t\t\tdata : [\n\t\t\t\t\t\t{type : 'max', name: '最大值'},\n\t\t\t\t\t\t{type : 'min', name: '最小值'}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tmarkLine : {\n\t\t\t\t\tdata : [\n\t\t\t\t\t\t{type : 'average', name: '平均值'}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:'最低气温',\n\t\t\t\ttype:'line',\n\t\t\t\tdata:[1, -2, 2, 5, 3, 2, 0],\n\t\t\t\tmarkPoint : {\n\t\t\t\t\tdata : [\n\t\t\t\t\t\t{name : '周最低', value : -2, xAxis: 1, yAxis: -1.5}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tmarkLine : {\n\t\t\t\t\tdata : [\n\t\t\t\t\t\t{type : 'average', name : '平均值'}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t};\n    myChart.setOption(option);\n</script>\n```\n\n## 效果图\n\n![](/Echarts-初体验/1.png)\n\n​\t\t\t\n\n\n\n![](Echarts-初体验\\2.png)\n\n## 各个配置参数的说明\n\n```java\ntheme = {\n    // 全图默认背景\n    // backgroundColor: 'rgba(0,0,0,0)',\n\n    // 默认色板\n    color: ['#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed',\n            '#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0',\n            '#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700',\n            '#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'],\n\n    // 图表标题\n    title: {\n        x: 'left',                 // 水平安放位置，默认为左对齐，可选为：\n                                   // 'center' ¦ 'left' ¦ 'right'\n                                   // ¦ {number}（x坐标，单位px）\n        y: 'top',                  // 垂直安放位置，默认为全图顶端，可选为：\n                                   // 'top' ¦ 'bottom' ¦ 'center'\n                                   // ¦ {number}（y坐标，单位px）\n        //textAlign: null          // 水平对齐方式，默认根据x设置自动调整\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',       // 标题边框颜色\n        borderWidth: 0,            // 标题边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 标题内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        itemGap: 10,               // 主副标题纵向间隔，单位px，默认为10，\n        textStyle: {\n            fontSize: 18,\n            fontWeight: 'bolder',\n            color: '#333'          // 主标题文字颜色\n        },\n        subtextStyle: {\n            color: '#aaa'          // 副标题文字颜色\n        }\n    },\n\n    // 图例\n    legend: {\n        orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：\n                                   // 'horizontal' ¦ 'vertical'\n        x: 'center',               // 水平安放位置，默认为全图居中，可选为：\n                                   // 'center' ¦ 'left' ¦ 'right'\n                                   // ¦ {number}（x坐标，单位px）\n        y: 'top',                  // 垂直安放位置，默认为全图顶端，可选为：\n                                   // 'top' ¦ 'bottom' ¦ 'center'\n                                   // ¦ {number}（y坐标，单位px）\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',       // 图例边框颜色\n        borderWidth: 0,            // 图例边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 图例内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，\n                                   // 横向布局时为水平间隔，纵向布局时为纵向间隔\n        itemWidth: 20,             // 图例图形宽度\n        itemHeight: 14,            // 图例图形高度\n        textStyle: {\n            color: '#333'          // 图例文字颜色\n        }\n    },\n\n    // 值域\n    dataRange: {\n        orient: 'vertical',        // 布局方式，默认为垂直布局，可选为：\n                                   // 'horizontal' ¦ 'vertical'\n        x: 'left',                 // 水平安放位置，默认为全图左对齐，可选为：\n                                   // 'center' ¦ 'left' ¦ 'right'\n                                   // ¦ {number}（x坐标，单位px）\n        y: 'bottom',               // 垂直安放位置，默认为全图底部，可选为：\n                                   // 'top' ¦ 'bottom' ¦ 'center'\n                                   // ¦ {number}（y坐标，单位px）\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',       // 值域边框颜色\n        borderWidth: 0,            // 值域边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 值域内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，\n                                   // 横向布局时为水平间隔，纵向布局时为纵向间隔\n        itemWidth: 20,             // 值域图形宽度，线性渐变水平布局宽度为该值 * 10\n        itemHeight: 14,            // 值域图形高度，线性渐变垂直布局高度为该值 * 10\n        splitNumber: 5,            // 分割段数，默认为5，为0时为线性渐变\n        color:['#1e90ff','#f0ffff'],//颜色 \n        //text:['高','低'],         // 文本，默认为数值文本\n        textStyle: {\n            color: '#333'          // 值域文字颜色\n        }\n    },\n\n    toolbox: {\n        orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：\n                                   // 'horizontal' ¦ 'vertical'\n        x: 'right',                // 水平安放位置，默认为全图右对齐，可选为：\n                                   // 'center' ¦ 'left' ¦ 'right'\n                                   // ¦ {number}（x坐标，单位px）\n        y: 'top',                  // 垂直安放位置，默认为全图顶端，可选为：\n                                   // 'top' ¦ 'bottom' ¦ 'center'\n                                   // ¦ {number}（y坐标，单位px）\n        color : ['#1e90ff','#22bb22','#4b0082','#d2691e'],\n        backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色\n        borderColor: '#ccc',       // 工具箱边框颜色\n        borderWidth: 0,            // 工具箱边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 工具箱内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，\n                                   // 横向布局时为水平间隔，纵向布局时为纵向间隔\n        itemSize: 16,              // 工具箱图形宽度\n        featureImageIcon : {},     // 自定义图片icon\n        featureTitle : {\n            mark : '辅助线开关',\n            markUndo : '删除辅助线',\n            markClear : '清空辅助线',\n            dataZoom : '区域缩放',\n            dataZoomReset : '区域缩放后退',\n            dataView : '数据视图',\n            lineChart : '折线图切换',\n            barChart : '柱形图切换',\n            restore : '还原',\n            saveAsImage : '保存为图片'\n        }\n    },\n\n    // 提示框\n    tooltip: {\n        trigger: 'item',           // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'\n        showDelay: 20,             // 显示延迟，添加显示延迟可以避免频繁切换，单位ms\n        hideDelay: 100,            // 隐藏延迟，单位ms\n        transitionDuration : 0.4,  // 动画变换时间，单位s\n        backgroundColor: 'rgba(0,0,0,0.7)',     // 提示背景颜色，默认为透明度为0.7的黑色\n        borderColor: '#333',       // 提示边框颜色\n        borderRadius: 4,           // 提示边框圆角，单位px，默认为4\n        borderWidth: 0,            // 提示边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 提示内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        axisPointer : {            // 坐标轴指示器，坐标轴触发有效\n            type : 'line',         // 默认为直线，可选为：'line' | 'shadow'\n            lineStyle : {          // 直线指示器样式设置\n                color: '#48b',\n                width: 2,\n                type: 'solid'\n            },\n            shadowStyle : {                       // 阴影指示器样式设置\n                width: 'auto',                   // 阴影大小\n                color: 'rgba(150,150,150,0.3)'  // 阴影颜色\n            }\n        },\n        textStyle: {\n            color: '#fff'\n        }\n    },\n\n    // 区域缩放控制器\n    dataZoom: {\n        orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：\n                                   // 'horizontal' ¦ 'vertical'\n        // x: {number},            // 水平安放位置，默认为根据grid参数适配，可选为：\n                                   // {number}（x坐标，单位px）\n        // y: {number},            // 垂直安放位置，默认为根据grid参数适配，可选为：\n                                   // {number}（y坐标，单位px）\n        // width: {number},        // 指定宽度，横向布局时默认为根据grid参数适配\n        // height: {number},       // 指定高度，纵向布局时默认为根据grid参数适配\n        backgroundColor: 'rgba(0,0,0,0)',       // 背景颜色\n        dataBackgroundColor: '#eee',            // 数据背景颜色\n        fillerColor: 'rgba(144,197,237,0.2)',   // 填充颜色\n        handleColor: 'rgba(70,130,180,0.8)'     // 手柄颜色\n    },\n\n    // 网格\n    grid: {\n        x: 80,\n        y: 60,\n        x2: 80,\n        y2: 60,\n        // width: {totalWidth} - x - x2,\n        // height: {totalHeight} - y - y2,\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderWidth: 1,\n        borderColor: '#ccc'\n    },\n\n    // 类目轴\n    categoryAxis: {\n        position: 'bottom',    // 位置\n        nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'\n        boundaryGap: true,     // 类目起始和结束两端空白策略\n        axisLine: {            // 坐标轴线\n            show: true,        // 默认显示，属性show控制显示与否\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#48b',\n                width: 2,\n                type: 'solid'\n            }\n        },\n        axisTick: {            // 坐标轴小标记\n            show: true,       // 属性show控制显示与否，默认不显示\n            interval: 'auto',\n            // onGap: null,\n            inside : false,    // 控制小标记是否在grid里 \n            length :5,         // 属性length控制线长\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#333',\n                width: 1\n            }\n        },\n        axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel\n            show: true,\n            interval: 'auto',\n            rotate: 0,\n            margin: 8,\n            // formatter: null,\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                color: '#333'\n            }\n        },\n        splitLine: {           // 分隔线\n            show: true,        // 默认显示，属性show控制显示与否\n            // onGap: null,\n            lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        splitArea: {           // 分隔区域\n            show: false,       // 默认不显示，属性show控制显示与否\n            // onGap: null,\n            areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    },\n\n    // 数值型坐标轴默认参数\n    valueAxis: {\n        position: 'left',      // 位置\n        nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'\n        nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式\n        boundaryGap: [0, 0],   // 数值起始和结束两端空白策略\n        splitNumber: 5,        // 分割段数，默认为5\n        axisLine: {            // 坐标轴线\n            show: true,        // 默认显示，属性show控制显示与否\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#48b',\n                width: 2,\n                type: 'solid'\n            }\n        },\n        axisTick: {            // 坐标轴小标记\n            show: false,       // 属性show控制显示与否，默认不显示\n            inside : false,    // 控制小标记是否在grid里 \n            length :5,         // 属性length控制线长\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#333',\n                width: 1\n            }\n        },\n        axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel\n            show: true,\n            rotate: 0,\n            margin: 8,\n            // formatter: null,\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                color: '#333'\n            }\n        },\n        splitLine: {           // 分隔线\n            show: true,        // 默认显示，属性show控制显示与否\n            lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        splitArea: {           // 分隔区域\n            show: false,       // 默认不显示，属性show控制显示与否\n            areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    },\n\n    polar : {\n        center : ['50%', '50%'],    // 默认全局居中\n        radius : '75%',\n        startAngle : 90,\n        splitNumber : 5,\n        name : {\n            show: true,\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                color: '#333'\n            }\n        },\n        axisLine: {            // 坐标轴线\n            show: true,        // 默认显示，属性show控制显示与否\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#ccc',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel\n            show: false,\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                color: '#333'\n            }\n        },\n        splitArea : {\n            show : true,\n            areaStyle : {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        },\n        splitLine : {\n            show : true,\n            lineStyle : {\n                width : 1,\n                color : '#ccc'\n            }\n        }\n    },\n\n    // 柱形图默认参数\n    bar: {\n        barMinHeight: 0,          // 最小高度改为0\n        // barWidth: null,        // 默认自适应\n        barGap: '30%',            // 柱间距离，默认为柱形宽度的30%，可设固定值\n        barCategoryGap : '20%',   // 类目间柱形距离，默认为类目间距的20%，可设固定值\n        itemStyle: {\n            normal: {\n                // color: '各异',\n                barBorderColor: '#fff',       // 柱条边线\n                barBorderRadius: 0,           // 柱条边线圆角，单位px，默认为0\n                barBorderWidth: 1,            // 柱条边线线宽，单位px，默认为1\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            },\n            emphasis: {\n                // color: '各异',\n                barBorderColor: 'rgba(0,0,0,0)',   // 柱条边线\n                barBorderRadius: 0,                // 柱条边线圆角，单位px，默认为0\n                barBorderWidth: 1,                 // 柱条边线线宽，单位px，默认为1\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            }\n        }\n    },\n\n    // 折线图默认参数\n    line: {\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                lineStyle: {\n                    width: 2,\n                    type: 'solid',\n                    shadowColor : 'rgba(0,0,0,0)', //默认透明\n                    shadowBlur: 5,\n                    shadowOffsetX: 3,\n                    shadowOffsetY: 3\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            }\n        },\n        //smooth : false,\n        //symbol: null,         // 拐点图形类型\n        symbolSize: 2,          // 拐点图形大小\n        //symbolRotate : null,  // 拐点图形旋转控制\n        showAllSymbol: false    // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\n    },\n\n    // K线图默认参数\n    k: {\n        // barWidth : null          // 默认自适应\n        // barMaxWidth : null       // 默认自适应 \n        itemStyle: {\n            normal: {\n                color: '#fff',          // 阳线填充颜色\n                color0: '#00aa11',      // 阴线填充颜色\n                lineStyle: {\n                    width: 1,\n                    color: '#ff3200',   // 阳线边框颜色\n                    color0: '#00aa11'   // 阴线边框颜色\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                // color0: 各异\n            }\n        }\n    },\n\n    // 散点图默认参数\n    scatter: {\n        //symbol: null,      // 图形类型\n        symbolSize: 4,       // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\n        //symbolRotate : null,  // 图形旋转控制\n        large: false,        // 大规模散点图\n        largeThreshold: 2000,// 大规模阀值，large为true且数据量>largeThreshold才启用大规模模式\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            },\n            emphasis: {\n                // color: '各异'\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            }\n        }\n    },\n\n    // 雷达图默认参数\n    radar : {\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                label: {\n                    show: false\n                },\n                lineStyle: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                label: {\n                    show: false\n                }\n            }\n        },\n        //symbol: null,         // 拐点图形类型\n        symbolSize: 2           // 可计算特性参数，空数据拖拽提示图形大小\n        //symbolRotate : null,  // 图形旋转控制\n    },\n\n    // 饼图默认参数\n    pie: {\n        center : ['50%', '50%'],    // 默认全局居中\n        radius : [0, '75%'],\n        clockWise : false,          // 默认逆时针\n        startAngle: 90,\n        minAngle: 0,                // 最小角度改为0\n        selectedOffset: 10,         // 选中是扇区偏移量\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                borderColor: '#fff',\n                borderWidth: 1,\n                label: {\n                    show: true,\n                    position: 'outer'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                labelLine: {\n                    show: true,\n                    length: 20,\n                    lineStyle: {\n                        // color: 各异,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                borderColor: 'rgba(0,0,0,0)',\n                borderWidth: 1,\n                label: {\n                    show: false\n                    // position: 'outer'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                labelLine: {\n                    show: false,\n                    length: 20,\n                    lineStyle: {\n                        // color: 各异,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            }\n        }\n    },\n\n    map: {\n        mapType: 'china',   // 各省的mapType暂时都用中文\n        mapLocation: {\n            x : 'center',\n            y : 'center'\n            // width    // 自适应\n            // height   // 自适应\n        },\n        showLegendSymbol : true,       // 显示图例颜色标识（系列标识的小圆点），存在legend时生效\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                borderColor: '#fff',\n                borderWidth: 1,\n                areaStyle: {\n                    color: '#ccc'//rgba(135,206,250,0.8)\n                },\n                label: {\n                    show: false,\n                    textStyle: {\n                        color: 'rgba(139,69,19,1)'\n                    }\n                }\n            },\n            emphasis: {                 // 也是选中样式\n                // color: 各异,\n                borderColor: 'rgba(0,0,0,0)',\n                borderWidth: 1,\n                areaStyle: {\n                    color: 'rgba(255,215,0,0.8)'\n                },\n                label: {\n                    show: false,\n                    textStyle: {\n                        color: 'rgba(139,69,19,1)'\n                    }\n                }\n            }\n        }\n    },\n\n    force : {\n        // 数据map到圆的半径的最小值和最大值\n        minRadius : 10,\n        maxRadius : 20,\n        density : 1.0,\n        attractiveness : 1.0,\n        // 初始化的随机大小位置\n        initSize : 300,\n        // 向心力因子，越大向心力越大\n        centripetal : 1,\n        // 冷却因子\n        coolDown : 0.99,\n        // 分类里如果有样式会覆盖节点默认样式\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                nodeStyle : {\n                    brushType : 'both',\n                    color : '#f08c2e',\n                    strokeColor : '#5182ab'\n                },\n                linkStyle : {\n                    strokeColor : '#5182ab'\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                nodeStyle : {},\n                linkStyle : {}\n            }\n        }\n    },\n\n    chord : {\n        radius : ['65%', '75%'],\n        center : ['50%', '50%'],\n        padding : 2,\n        sort : 'none', // can be 'none', 'ascending', 'descending'\n        sortSub : 'none', // can be 'none', 'ascending', 'descending'\n        startAngle : 90,\n        clockWise : false,\n        showScale : false,\n        showScaleText : false,\n        itemStyle : {\n            normal : {\n                label : {\n                    show : true\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                lineStyle : {\n                    width : 0,\n                    color : '#000'\n                },\n                chordStyle : {\n                    lineStyle : {\n                        width : 1,\n                        color : '#666'\n                    }\n                }\n            },\n            emphasis : {\n                lineStyle : {\n                    width : 0,\n                    color : '#000'\n                },\n                chordStyle : {\n                    lineStyle : {\n                        width : 2,\n                        color : '#333'\n                    }\n                }\n            }\n        }\n    },\n\n    island: {\n        r: 15,\n        calculateStep: 0.1  // 滚轮可计算步长 0.1 = 10%\n    },\n\n    markPoint : {\n        symbol: 'pin',         // 标注类型\n        symbolSize: 10,        // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\n        //symbolRotate : null, // 标注旋转控制\n        itemStyle: {\n            normal: {\n                // color: 各异，\n                // borderColor: 各异,     // 标注边线颜色，优先于color \n                borderWidth: 2,            // 标注边线线宽，单位px，默认为1\n                label: {\n                    show: true,\n                    position: 'inside' // 可选为'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            },\n            emphasis: {\n                // color: 各异\n                label: {\n                    show: true\n                    // position: 'inside'  // 'left'|'right'|'top'|'bottom'\n                    // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            }\n        }\n    },\n\n    markLine : {\n        // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string\n        symbol: ['circle', 'arrow'],  \n        // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\n        symbolSize: [2, 4],\n        // 标线起始和结束的symbol旋转控制\n        //symbolRotate : null,\n        itemStyle: {\n            normal: {\n                // color: 各异,           // 标线主色，线色，symbol主色\n                // borderColor: 随color,     // 标线symbol边框颜色，优先于color \n                borderWidth: 2,          // 标线symbol边框线宽，单位px，默认为2\n                label: {\n                    show: false,\n                    // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom'\n                    position: 'inside',  \n                    textStyle: {         // 默认使用全局文本样式，详见TEXTSTYLE\n                        color: '#333'\n                    }\n                },\n                lineStyle: {\n                    // color: 随borderColor, // 主色，线色，优先级高于borderColor和color\n                    // width: 随borderWidth, // 优先于borderWidth\n                    type: 'solid',\n                    shadowColor : 'rgba(0,0,0,0)', //默认透明\n                    shadowBlur: 5,\n                    shadowOffsetX: 3,\n                    shadowOffsetY: 3\n                }\n            },\n            emphasis: {\n                // color: 各异\n                label: {\n                    show: false\n                    // position: 'inside' // 'left'|'right'|'top'|'bottom'\n                    // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                lineStyle : {}\n            }\n        }\n    },\n\n    textStyle: {\n        decoration: 'none',\n        fontFamily: 'Arial, Verdana, sans-serif',\n        fontFamily2: '微软雅黑',    // IE8- 字体模糊并且不支持不同字体混排，额外指定一份\n        fontSize: 12,\n        fontStyle: 'normal',\n        fontWeight: 'normal'\n    },\n\n    // 默认标志图形类型列表\n    symbolList : [\n      'circle', 'rectangle', 'triangle', 'diamond',\n      'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond'\n    ],\n    loadingText : 'Loading...',\n    // 可计算特性配置，孤岛，提示颜色\n    calculable: false,              // 默认关闭可计算特性\n    calculableColor: 'rgba(255,165,0,0.6)',       // 拖拽提示边框颜色\n    calculableHolderColor: '#ccc', // 可计算占位提示颜色\n    nameConnector: ' & ',\n    valueConnector: ' : ',\n    animation: true,\n    animationThreshold: 2500,       // 动画元素阀值，产生的图形原素超过2500不出动画\n    addDataAnimation: true,         // 动态数据接口是否开启动画效果\n    animationDuration: 2000,\n    animationEasing: 'ExponentialOut'    //BounceOut\n}\n\n```\n\n","tags":["Echarts"]},{"title":"Spring Boot 拦截器","url":"/2019/04/12/Spring-Boot-登录拦截器验证/","content":"\njava里的拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在AOP（Aspect-Oriented Programming）中拦截器用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## HandlerInterceptor 接口介绍:\n\n在HandlerInterceptor 中有三个方法:\n\n```java\ndefault boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    return true;\n}\n\ndefault void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {\n}\n\ndefault void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n}\n```\n\n**preHandle:** 预处理方法,实现处理器的预处理(例如登录状态),handler参数为相应的处理器,返回值:true表示继续流程,false表示流程中断,我们需要通过reponse来产生响应.\n\n**postHandle**：后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。\n\n**afterCompletion**：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。\n\n\n\n## 配置拦截器:\n\n### 创建拦截器类:\n\n```java\npackage caicai.springbootinterceptor1.interceptor;\n\nimport org.springframework.lang.Nullable;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * @author liu\n * @title: LoginInterceptor\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:31\n */\npublic class LoginInterceptor implements HandlerInterceptor{\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        System.out.println(\"preHandle.............................\");\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {\n        System.out.println(\"postHandle.............................\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n        System.out.println(\"afterCompletion.............................\");\n    }\n}\n```\n\n### 创建拦截器配置类:\n\n```java\npackage caicai.springbootinterceptor1.config;\n\nimport caicai.springbootinterceptor1.interceptor.LoginInterceptor;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n/**\n * @author liu\n * @title: LoginInterceptorConfig\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:33\n */\n@Configuration\npublic class LoginInterceptorConfig implements WebMvcConfigurer{\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/login\");\n\n    }\n}\n```\n\naddPathPatterns(\"/**\"):表示拦截所有的url请求;\n\nexcludePathPatterns(\"/login\"):表示排除login\n\n完成了拦截器配置后,在启动springboot项目的时候,除了login以外,其他所有的请求都会经过拦截器处理,我们可以使用preHandle来完成一个登录验证的功能\n\n\n\n## 登录验证实现:\n\n### 效果:\n\n1.有两个界面: 登录界面, 主界面\n\n2:登录界面和主界面都可以通过相应请求跳转到,但是主界面只有登录之后才能查看,否则就跳回登录界面\n\n项目目录:\n\n![](Spring-Boot-登录拦截器验证\\1.png)\n\n### \n\n### index.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<form action=\"/login\">\n    <span>用户名:</span> <input type=\"text\" name=\"username\">\n    <span>密码:</span>  <input type=\"text\" name=\"password\">\n    <button>提交</button>\n</form>\n</body>\n</html>\n```\n\n\n\n### main.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"><head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<h1>这里是主页面</h1>\n当前登录用户:<span th:text=\"${session.username}\"></span>\n</body>\n</html>\n```\n\n如果登录的话 ${session.username}会获取到存贮在session中的用户名\n\n\n\n\n\n### Logininterceptor.java\n\n```java\npackage caicai.springbootinterceptor1.interceptor;\n\nimport org.springframework.lang.Nullable;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * @author liu\n * @title: LoginInterceptor\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:31\n */\npublic class LoginInterceptor implements HandlerInterceptor{\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        /**\n        通过session中的用户名来判断是否登录,因为一旦登录了就会在session中存储用户名\n        **/\n        if(request.getSession().getAttribute(\"username\")!=null){\n            System.out.println(\"登录了\");\n            return true;\n        }else{\n            System.out.println(\"未登录\");\n            response.sendRedirect(request.getContextPath()+\"/index\");\n\n            return false;\n        }\n\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {\n        System.out.println(\"postHandle.............................\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n        System.out.println(\"afterCompletion.............................\");\n    }\n}\n```\n\n\n\n### LoginController\n\n```java\npackage caicai.springbootinterceptor1.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n * @author liu\n * @title: LoginController\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:22\n */\n@Controller\npublic class LoginController {\n\n    /**\n    登录界面的url映射\n    **/\n    @RequestMapping(\"/index\")\n    public String index(){\n        return \"index\";\n    }\n    /**\n    登录,此处直接用字符串是否是admin的方式来模拟数据库查询登录\n    若账号密码正确则跳转到main界面若账号密码错误则继续跳转到登录界面\n    **/\n    @RequestMapping(\"/login\")\n    public String login(String username, String password, HttpServletRequest request){\n        if (username.equals(\"admin\")&& password.equals(\"admin\")){\n            request.getSession().setAttribute(\"username\",username);\n            return \"main\";\n        }else {\n            return \"login\";\n        }\n    }\n    /**\n    主界面的url映射  为了测试不登陆直接进主页面被拦截\n    **/\n    @RequestMapping(\"/main\")\n    public String main(){\n        return \"main\";\n    }\n\n}\n```\n\n### LoginInterceptorConfig.java:\n\n配置文件,配置了拦截器和拦截路径\n\n```java\npackage caicai.springbootinterceptor1.config;\n\nimport caicai.springbootinterceptor1.interceptor.LoginInterceptor;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n/**\n * @author liu\n * @title: LoginInterceptorConfig\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:33\n */\n@Configuration\npublic class LoginInterceptorConfig implements WebMvcConfigurer{\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/login\").excludePathPatterns(\"/index\");\n\n    }\n}\n```\n\n\n\n本实例只是粗略的完成了登录拦截的功能,对于一些细节没有完善,例如错误提示等.","tags":["Spring Boot"]},{"title":"MYSQL随机选择数据","url":"/2019/04/10/MYSQL随机选择数据/","content":"\n最近在做一个在线考试系统,遇到需要随机选择20道选择题的需求.\n\n\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 使用ORDER BY RAND()选择随机记录\n\nMySQL没有内置语句来从数据库表中选择随机记录。为了实现这个目的，可使用`RAND`函数。 以下查询是从数据库表中选择N个随机记录：\n\n```mysql\nSELECT \n    *\nFROM\n    tbl\nORDER BY RAND()\nLIMIT N;\n```\n\n- `RAND（）`函数为表中的每一行生成一个随机值。 \n- [ORDER BY](http://www.studymysql.com/mysql/order-by.html)子句按照`RAND（）`函数生成的随机数对表中的所有行进行排序。 \n\n这种技术非常适合小表。如果在大的表上执行速度是非常缓慢的，因为MySQL必须排序整个表，以挑选随机的行数据。查询的速度还取决于表中的行数。表具有的行越多，MySQL都要为每行生成随机数，所以所需的时间就越多。\n\n\n\n","tags":["MYSQL"]},{"title":"Jpa 自定义查询语句","url":"/2019/04/10/jpa-自定义查询语句/","content":"\n在使用Spring Data Jpa框架时，根据业务需求我们通常需要进行复杂的数据库查询，并返回我们自定义的实体类，而在该框架下，目前仅仅支持返回与数据库映射进行持久化的POJO实体。虽然在框架上我们可以使用@Query注解执行我们自定义的sql语句，但是其返回值为List<Object[]> 类型，即多个Object数组的List集合。\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## @Query()注解\n\n通过使@query注解,可以自定义语句进行sql操作\n\n下例为在数据库中查询10个随机的选择题的自定义查询方法:\n\n```java\npublic interface MultipleChoiceRepository extends JpaRepository<MultipleChoice,Long> {\n    @Query(value = \"select * from choice ORDER BY RAND() limit :num\",nativeQuery = true)\n    public List<MultipleChoice> findByNmber(@Param(\"num\") Integer num);\n}\n```\n\n## 开启mysql语句\n\n```java\n  @Query(value = \"\",nativeQuery = true)  //nativeQuery= true开启mysql\n```\n\n## @Modefying()注解\n\n如果是删除或修改操作，需要加入此注解进行修饰. 以通知 SpringData， 这是一个 UPDATE 或 DELETE 操作 ；默认情况下，是只读，所以查询不需要\n\n# 参数传递:\n\n## @Param()注解\n\n使用@Param注解可以给查询语句中注入参数\n\n```java\n@Param(\"num\") Integer num\n```\n\n在sql语句中使用  :参数名    进行调用\n\n## 使用?占位符\n\n```java\npublic interface MultipleChoiceRepository extends JpaRepository<MultipleChoice,Long> {\n    @Query(value = \"select * from choice ORDER BY RAND() limit ?\",nativeQuery = true)\n\n    public List<MultipleChoice> findByNmber(Integer num);\n\n}\n```\n\nsql语句中也可以使用?占位符的方式进行参数写入","tags":["Spring Boot"]},{"title":"Spring Boot Jpa","url":"/2019/03/31/Spring-Boot-Jpa/","content":"\n  全称Java Persistence API，通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。\n\n​     JPA的出现有两个原因：\n 其一，简化现有Java EE和Java SE应用的对象持久化的开发工作；\n 其二，Sun希望整合对ORM技术，实现持久化领域的统一。\n\n​     JPA提供的技术：\n\n 1）ORM映射元数据：JPA支持XML和JDK 5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中；\n\n 2）JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。\n\n 3）查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## pom.xml中导入依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n   <modelVersion>4.0.0</modelVersion>\n   <parent>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-parent</artifactId>\n      <version>2.1.3.RELEASE</version>\n      <relativePath/> <!-- lookup parent from repository -->\n   </parent>\n   <groupId>com.caicai</groupId>\n   <artifactId>spring-boot-jpa</artifactId>\n   <version>0.0.1-SNAPSHOT</version>\n   <name>spring-boot-jpa</name>\n   <description>Demo project for Spring Boot</description>\n\n   <properties>\n      <java.version>1.8</java.version>\n   </properties>\n\n   <dependencies>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-data-jpa</artifactId>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-jdbc</artifactId>\n      </dependency>\n\n      <dependency>\n         <groupId>mysql</groupId>\n         <artifactId>mysql-connector-java</artifactId>\n         <scope>runtime</scope>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-test</artifactId>\n         <scope>test</scope>\n      </dependency>\n   </dependencies>\n\n   <build>\n      <plugins>\n         <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n         </plugin>\n      </plugins>\n   </build>\n\n</project>\n```\n\n## 创建实体类\n\n```java\npackage com.caicai.springbootjpa.entity;\n\nimport javax.persistence.*;\n\n/**\n * @author liu\n * @title: User\n * @projectName spring-boot-jpa\n * @description: TODO\n * @date 2019/3/3121:14\n */\n\n@Entity\npublic class User {\n    @GeneratedValue(strategy = GenerationType.AUTO)//设置自增长策略\n    @Id\n    private Integer id;\n    @Column(length = 20,nullable = false)  //column可以设置属性\n    private String name;\n    @Column(length = 20,nullable = true)\n    private Integer age;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public User() {\n    }\n\n    public User(String name, Integer age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n\n\n## 创建UserRepository\n\n```java\npackage com.caicai.springbootjpa.repository;\n\nimport com.caicai.springbootjpa.entity.User;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\n/**\n * @author liu\n * @title: UserRepository\n * @projectName spring-boot-jpa\n * @description: TODO\n * @date 2019/3/3121:06\n */\npublic interface UserRepository extends JpaRepository<User,Integer>{\n}\n\n```\n\n## 配置数据源和自动建表:\n\n```xml\nspring:\n  datasource:\n    username: root\n    password: 123456\n    url: jdbc:mysql://localhost:3306/jpa\n    driver-class-name: com.mysql.jdbc.Driver\n  jpa:\n    hibernate:\n      ddl-auto: update\n    show-sql: true\n```\n\n\n\n## 测试类:\n\n```java\npackage com.caicai.springbootjpa;\n\nimport com.caicai.springbootjpa.entity.User;\nimport com.caicai.springbootjpa.repository.UserRepository;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootJpaApplicationTests {\n    @Autowired\n    UserRepository userRepository;\n\t@Test\n\tpublic void test() {\n\t    User user = new User();\n\t    user.setAge(10);\n\t    user.setName(\"caicai\");\n\t    userRepository.save(user);\n\t}\n\n}\n```\n\n","tags":["Spring Boot"]},{"title":"Spring Boot 整合Mybatis(基于注解)","url":"/2019/03/31/Spring-Boot-整合Mybatis-基于注解/","content":"\n基于注解的Spring Boot 整合Mybatis\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 项目结构\n\n![](Spring-Boot-整合Mybatis-基于注解\\1.png)\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.1.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.caicai</groupId>\n\t<artifactId>spring-boot-mybatis-annotation</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>spring-boot-mybatis-annotation</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-jdbc</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.spring.boot</groupId>\n\t\t\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t\t\t<version>2.0.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>mysql</groupId>\n\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t\t<scope>runtime</scope>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n## UserMapper.java\n\n```java\npackage com.caicai.springbootmybatisannotation.mapper;\n\nimport com.caicai.springbootmybatisannotation.pojo.User;\nimport org.apache.ibatis.annotations.Insert;\nimport org.apache.ibatis.annotations.Mapper;\n\n/**\n * @author liu\n * @title: UserMapper\n * @projectName spring-boot-mybatis-annotation\n * @description: TODO\n * @date 2019/3/3120:16\n */\n@Mapper\npublic interface UserMapper {\n    @Insert(\"insert into users(name,age) values(#{name},#{age})\")\n    public void addUser(User user);\n\n}\n```\n\n\n\n## User.java\n\n```java\npackage com.caicai.springbootmybatisannotation.pojo;\n\n/**\n * @author liu\n * @title: User\n * @projectName spring-boot-mybatis-annotation\n * @description: TODO\n * @date 2019/3/3120:16\n */\npublic class User {\n    private Integer id;\n    private String name;\n    private Integer age;\n\n    public User() {\n    }\n\n    public User(Integer id, String name, Integer age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n```\n\n\n\n## application.yml\n\n```xml\nspring:\n  datasource:\n    password: 123456\n    username: root\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm\n```\n\n\n\n## SpringBootMybatisAnnotationApplicationTests.java\n\n```java\npackage com.caicai.springbootmybatisannotation;\n\nimport com.caicai.springbootmybatisannotation.mapper.UserMapper;\nimport com.caicai.springbootmybatisannotation.pojo.User;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootMybatisAnnotationApplicationTests {\n    @Autowired\n    UserMapper userMapper;\n   @Test\n    public void addUser(){\n        User user = new User();\n        user.setAge(10);\n        user.setName(\"caicai\");\n        userMapper.addUser(user);\n    }\n\n}\n```\n\n## 对比xml文件配置\n\n```java\n@Insert(\"insert into users(name,age) values(#{name},#{age})\")\npublic void addUser(User user);\n```\n\n@Insert注解的配置就相当于在UserMapper.xml中配置:","tags":["Spring Boot","Mybatis"]},{"title":"org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)异常处理","url":"/2019/03/31/org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found-异常处理/","content":"\n在SpringBoot整合Mybatis出现org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): 错误\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 报错信息:\n\n```java\norg.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.caicai.springbootspringmvcmybatis.mapper.UsersMapper.insertUser\n\tat org.apache.ibatis.binding.MapperMethod$SqlCommand.<init>(MapperMethod.java:232) ~[mybatis-3.5.0.jar:3.5.0]\n\tat org.apache.ibatis.binding.MapperMethod.<init>(MapperMethod.java:50) ~[mybatis-3.5.0.jar:3.5.0]\n\tat org.apache.ibatis.binding.MapperProxy.lambda$cachedMapperMethod$0(MapperProxy.java:62) ~[mybatis-3.5.0.jar:3.5.0]\n\tat java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1660) ~[na:1.8.0_201]\n\tat org.apache.ibatis.binding.MapperProxy.cachedMapperMethod(MapperProxy.java:62) ~[mybatis-3.5.0.jar:3.5.0]\n\tat org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:57) ~[mybatis-3.5.0.jar:3.5.0]\n\tat com.sun.proxy.$Proxy56.insertUser(Unknown Source) ~[na:na]\n\tat com.caicai.springbootspringmvcmybatis.service.UserServiceImpl.addUser(UserServiceImpl.java:23) ~[classes/:na]\n\tat com.caicai.springbootspringmvcmybatis.service.UserServiceImpl$$FastClassBySpringCGLIB$$3b4656c9.invoke(<generated>) ~[classes/:na]\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:294) ~[spring-tx-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98) ~[spring-tx-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat com.caicai.springbootspringmvcmybatis.service.UserServiceImpl$$EnhancerBySpringCGLIB$$c9ef3195.addUser(<generated>) ~[classes/:na]\n\tat com.caicai.springbootspringmvcmybatis.controller.UserController.addUser(UserController.java:30) ~[classes/:na]\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_201]\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_201]\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_201]\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_201]\n\tat org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:800) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:908) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:660) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_201]\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_201]\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_201]\n```\n\n\n\n## 解决\n\n经过研究,发现UsersMapper.xml文件在com.caicai.springbootspringmvcmybatis.mapper包里不会被编译,所以考虑在resources里创建一个mapper文件夹,并且在application.yml配置mybatis\n\n```xml\nmybatis:\n  type-aliases-package: com.caicai.springbootspringmvcmybatis.pojo\n  mapper-locations: classpath:mapper/*.xml\n\n```\n\n","tags":["Spring Boot","Mybatis"]},{"title":"JDBC连接Mysql8.0驱动版本过低报错","url":"/2019/03/29/JDBC连接Mysql8-0-11版本出现问题/","content":"\nJDBC连接Mysql8.0.11版本出现问题,不停循环报错 错误信息如下:\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 报错信息:\n\n```java\nFri Mar 29 21:39:01 CST 2019 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.\nERROR [Druid-ConnectionPool-Create-2085079540] - create connection SQLException, url: jdbc:mysql://localhost:3306/phone, errorCode 0, state 08001\ncom.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server.\n\tat sun.reflect.GeneratedConstructorAccessor36.newInstance(Unknown Source)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat com.mysql.jdbc.Util.handleNewInstance(Util.java:404)\n\tat com.mysql.jdbc.Util.getInstance(Util.java:387)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:917)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:896)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:885)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:860)\n\tat com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2332)\n\tat com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2085)\n\tat com.mysql.jdbc.ConnectionImpl.<init>(ConnectionImpl.java:795)\n\tat com.mysql.jdbc.JDBC4Connection.<init>(JDBC4Connection.java:44)\n\tat sun.reflect.GeneratedConstructorAccessor27.newInstance(Unknown Source)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat com.mysql.jdbc.Util.handleNewInstance(Util.java:404)\n\tat com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:400)\n\tat com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:327)\n\tat com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1513)\n\tat com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1578)\n\tat com.alibaba.druid.pool.DruidDataSource$CreateConnectionThread.run(DruidDataSource.java:2451)\nCaused by: java.lang.NullPointerException\n\tat com.mysql.jdbc.ConnectionImpl.getServerCharset(ConnectionImpl.java:3005)\n\tat com.mysql.jdbc.MysqlIO.sendConnectionAttributes(MysqlIO.java:1916)\n\tat com.mysql.jdbc.MysqlIO.proceedHandshakeWithPluggableAuthentication(MysqlIO.java:1845)\n\tat com.mysql.jdbc.MysqlIO.doHandshake(MysqlIO.java:1215)\n\tat com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2255)\n\tat com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2286)\n\t... 12 more\n\n```\n\n\n\n## 解决方案:\n\nMysql是8.0版本的 ,但是项目中用的jdbc驱动包5.1.31,将jdbc驱动包改为8.0.13后不再报错","tags":["MYSQL"]},{"title":"Spring Boot 整合mybatis","url":"/2019/03/29/Spring-Boot-整合mybatis/","content":"\n Spring Boot 整合mybatis\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 创建项目   pom.xml中添加依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.1.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.caicai</groupId>\n\t<artifactId>12-spring-boot-springmvc-mybatis</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>12-spring-boot-springmvc-mybatis</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-thymeleaf</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.spring.boot</groupId>\n\t\t\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t\t\t<version>2.0.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>1.1.8</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n## 创建application.yml\n\n```xml\nspring:\n  datasource:\n    driver-class-name: com.mysql.jdbc.Driver\n    username: root\n    password: 123456\n    url: jdbc:mysql://localhost:3306/ssm\n    type: com.alibaba.druid.pool.DruidDataSource\nmybatis:\n  type-aliases-package: com.caicai.springbootspringmvcmybatis.pojo\n  mapper-locations: classpath:mapper/*.xml\n```\n\n## 创建Users类\n\n```java\npackage com.caicai.springbootspringmvcmybatis.pojo;\n\npublic class Users {\n\n    private Integer id;\n    private String name;\n    private Integer age;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n\n```\n\n\n\n## 创建Controller\n\n```java\npackage com.caicai.springbootspringmvcmybatis.controller;\n\nimport com.caicai.springbootspringmvcmybatis.pojo.Users;\nimport com.caicai.springbootspringmvcmybatis.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n/**\n * @author liu\n * @title: Controller\n * @projectName 12-spring-boot-springmvc-mybatis\n * @description: TODO\n * @date 2019/3/3113:01\n */\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n    @Autowired\n    private UserService userService;\n    @RequestMapping(\"/{page}\")\n    public String showPage(@PathVariable String page){\n        return page;\n    }\n    @RequestMapping(\"/addUser\")\n    @ResponseBody\n    public String addUser(Users user){\n        userService.addUser(user);\n        return \"success\";\n    }\n}\n\n```\n\n## 创建 UserMapper接口和UsersMapper.xml(创建路径在resources/mapper下)\n\n```\npackage com.caicai.springbootspringmvcmybatis.mapper;\n\n\nimport com.caicai.springbootspringmvcmybatis.pojo.Users;\n\npublic interface UsersMapper {\n\t\n\tvoid insertUser(Users users);\n}\n\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\nPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.caicai.springbootspringmvcmybatis.mapper.UsersMapper\">\n\t<insert id=\"insertUser\" parameterType=\"users\">\n\t\tinsert into users(name,age) values(#{name},#{age})\n\t</insert>\n</mapper>\n```\n\n## 创建Service\n\n```java\npackage com.caicai.springbootspringmvcmybatis.service;\n\nimport com.caicai.springbootspringmvcmybatis.pojo.Users;\n\n/**\n * @author liu\n * @title: UserService\n * @projectName 12-spring-boot-springmvc-mybatis\n * @description: TODO\n * @date 2019/3/3112:16\n */\npublic interface UserService {\n    void addUser(Users users);\n}\n\n```\n\n```java\npackage com.caicai.springbootspringmvcmybatis.service;\n\nimport com.caicai.springbootspringmvcmybatis.mapper.UsersMapper;\nimport com.caicai.springbootspringmvcmybatis.pojo.Users;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n/**\n * @author liu\n * @title: UserServiceImpl\n * @projectName 12-spring-boot-springmvc-mybatis\n * @description: TODO\n * @date 2019/3/3112:25\n */\n@Service\n@Transactional\npublic class UserServiceImpl implements  UserService{\n    @Autowired\n    private UsersMapper usersMapper;\n    @Override\n    public void addUser(Users users) {\n        this.usersMapper.insertUser(users);\n    }\n}\n\n```\n\n## 创建page.html\n\n```html\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<form th:action=\"@{/users/addUser}\" method=\"post\">\n用户姓名<input type=\"text\" name=\"name\"><br>\n用户年龄<input type=\"text\" name=\"age\"><br>\n<input type=\"submit\" th:value=\"确定\"><br>\n\n</form>\n\n</body>\n</html>\n```\n\n## 创建启动类:\n\n```java\npackage com.caicai.springbootspringmvcmybatis;\n\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n@MapperScan(\"com.caicai.springbootspringmvcmybatis.mapper\")\npublic class Application {\n\n   public static void main(String[] args) {\n      SpringApplication.run(Application.class, args);\n   }\n\n}\n```\n\n\n\n\n\n","tags":["Spring Boot","Mybatis"]},{"title":"thymeleaf的整合和使用","url":"/2019/03/29/thymeleaf基本语法/","content":"\nThymeleaf是用于Web和独立环境的现代服务器端Java模板引擎。Thymeleaf的主要目标是将优雅的自然模板带到您的开发工作流程中—HTML能够在浏览器中正确显示，并且可以作为静态原型，从而在开发团队中实现更强大的协作。Thymeleaf能够处理HTML，XML，JavaScript，CSS甚至纯文本。\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 整合thymeleaf\n\n## 修改pom.xml文件,添加依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.1.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.caicai</groupId>\n\t<artifactId>10-spring-boot-view-thymeleaf</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>10-spring-boot-view-thymeleaf</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-thymeleaf</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n## 编写视图:\n\n在templates/ 下建立 userList2.html:\n\n```html\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\">\n<head>\n    <title>index</title>\n</head>\n<body>\n<table border=\"1\" align=\"center\" width=\"50%\">\n    <tr>\n        <th>ID</th>\n        <th>Name</th>\n        <th>Age</th>\n    </tr>\n\n    <tr th:each=\"user:${list}\">\n        <td th:text=\"${user.userid}\"></td>\n        <td th:text=\"${user.username}\"></td>\n        <td th:text=\"${user.userage}\"></td>\n    </tr>\n\n</table>\n</body>\n</html>\n```\n\n## 创建Controller\n\n```java\npackage com.caicai.springbootviewfreemarker.controller;\n\nimport com.caicai.springbootviewfreemarker.pojo.Users;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author liu\n * @title: UserController\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2820:06\n */\n@Controller\npublic class UserController {\n    @RequestMapping(\"/showuser2\")\n    public String index(Model model){\n        List<Users> list = new ArrayList<>();\n        list.add(new Users(1,\"caicai\",21));\n        list.add(new Users(2,\"honghong\",32));\n        list.add(new Users(3,\"mingming\",43));\n        model.addAttribute(\"list\",list);\n        return \"userList2\";\n    }\n}\n\n```\n\n## 创建Users类:\n\n```java\npackage com.caicai.springbootviewfreemarker.pojo;\n\n/**\n * @author liu\n * @title: Users\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2820:06\n */\npublic class Users {\n    private Integer userid;\n    private String username;\n    private Integer userage;\n\n\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Integer getUserage() {\n        return userage;\n    }\n\n    public void setUserage(Integer userage) {\n        this.userage = userage;\n    }\n\n    public Users() {\n    }\n\n    public Integer getUserid() {\n        return userid;\n    }\n\n    public void setUserid(Integer userid) {\n        this.userid = userid;\n    }\n\n    public Users(Integer userid, String username, Integer userage) {\n        this.userid = userid;\n        this.username = username;\n        this.userage = userage;\n    }\n}\n\n\n```\n\n## 创建启动类\n\n```java\npackage com.caicai.springbootviewfreemarker;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n\n```\n\n\n\n# thymeleaf基本语法:\n\n## 变量输出与字符串操作\n\n### th:text\n\n在页面中输出值\n\n### th:value\n\n可以将一个值放入到 input 标签的 value 中\n\n### 判断字符串是否为空\nThymeleaf 内置对象\n注意语法：\n1，调用内置对象一定要用#\n2，大部分的内置对象都以 s 结尾 strings、numbers、dates\n\n```\n${#strings.isEmpty(key)}\n判断字符串是否为空，如果为空返回 true，否则返回 false\n${#strings.contains(msg,'T')}\n判断字符串是否包含指定的子串，如果包含返回 true，否则返回 false\n${#strings.startsWith(msg,'a')}\n判断当前字符串是否以子串开头，如果是返回 true，否则返回 false\n${#strings.endsWith(msg,'a')}\n判断当前字符串是否以子串结尾，如果是返回 true，否则返回 false\n${#strings.length(msg)}\n返回字符串的长度\n${#strings.indexOf(msg,'h')}\n查找子串的位置，并返回该子串的下标，如果没找到则返回-1\n${#strings.substring(msg,13)}\n${#strings.substring(msg,13,15)}\n截取子串，用户与 jdk String 类下 SubString 方法相同\n${#strings.toUpperCase(msg)}\n${#strings.toLowerCase(msg)}\n字符串转大小写。\n```\n\n\n\n## 日期格式化处理\n\n```\n${#dates.format(key)}\n格式化日期，默认的以浏览器默认语言为格式化标准\n${#dates.format(key,'yyy/MM/dd')}\n按照自定义的格式做日期转换\n${#dates.year(key)}\n${#dates.month(key)}\n${#dates.day(key)}\nyear：取年\nMonth：取月\nDay：取日    \n\n```\n\n## 条件判断\n\n### th:if\n\n```html\n<span th:if=\"${sex} == '男'\">\n    性别男\n</span>\n<span th:if=\"${sex} == '女'\">\n    性别女\n</span>\n```\n\n### th:switch\n\n```html\n<span th:switch=\"${id}\">\n    <span th:case=\"1\">ID 为1</span>\n    <span th:case=\"2\">ID 为2</span>\n    <span th:case=\"2\">ID 为3</span>\n</span>\n```\n\n## 迭代遍历\n\n```html\n<table border=\"1\" align=\"center\" width=\"50%\">\n    <tr>\n        <th>ID</th>\n        <th>Name</th>\n        <th>Age</th>\n    </tr>\n\n    <tr th:each=\"user:${list}\">\n        <td th:text=\"${user.userid}\"></td>\n        <td th:text=\"${user.username}\"></td>\n        <td th:text=\"${user.userage}\"></td>\n    </tr>\n\n</table>\n```\n\n```java\n    @RequestMapping(\"/index\")\n    public String index(Model model){\n        List<Users> list = new ArrayList<>();\n        list.add(new Users(1,\"caicai\",21));\n        list.add(new Users(2,\"honghong\",32));\n        list.add(new Users(3,\"mingming\",43));\n        model.addAttribute(\"list\",list);\n        return \"index\";\n\n    }\n```\n\n状态变量属性\n1,index:当前迭代器的索引 从 0 开始\n2,count:当前迭代对象的计数 从 1 开始\n3,size:被迭代对象的长度\n4,even/odd:布尔值，当前循环是否是偶数/奇数 从 0 开始\n5,first:布尔值，当前循环的是否是第一条，如果是返回 true 否则返回 false\n6,last:布尔值，当前循环的是否是最后一条，如果是则返回 true 否则返回 false\n\n### th:each 迭代Map\n\n```html\n<table border=\"1\">\n    <tr>\n        <th>ID</th>\n        <th>Name</th>\n        <th>Age</th>\n    </tr>\n    <tr th:each=\"maps : ${map}\">\n        <td th:text=\"${maps}\"></td>\n    </tr>\n</table>\n<th/>\n<table border=\"1\">\n    <tr>\n        <th>ID</th>\n        <th>Name</th>\n        <th>Age</th>\n    </tr>\n    <tr th:each=\"maps : ${map}\">\n        <td th:each=\"entry:${maps}\"\n            th:text=\"${entry.value.id}\" ></td>\n        <td th:each=\"entry:${maps}\"\n            th:text=\"${entry.value.name}\"></td>\n        <td th:each=\"entry:${maps}\"\n            th:text=\"${entry.value.age}\"></td>\n    </tr>\n</table>\n```\n\n```java\n\n    @RequestMapping(\"/index3\")\n    public String index3(Model model){\n        Map<String, User> map = new HashMap<>();\n        map.put(\"u1\", new User(1,\"张三\",20));\n        map.put(\"u2\", new User(2,\"李四\",22));\n        map.put(\"u3\", new User(3,\"王五\",24));\n        model.addAttribute(\"map\", map);\n        return \"index3\" ;\n    }\n```\n\n\n\n## 域对象操作\n\n```java\n    @RequestMapping(\"/index4\")\n    public String index4(HttpServletRequest httpServletRequest, Model model){\n        httpServletRequest.setAttribute(\"req\",\"HttpServletRequest\");\n        httpServletRequest.getSession().setAttribute(\"sess\",\"HttpSession\");\n        httpServletRequest.getSession().getServletContext().setAttribute(\"app\",\"Application\");\n        return \"index4\" ;\n    }\n```\n\n```html\n<body>\n<span th:text=\"${#httpServletRequest.getAttribute('req')}\"></span><br>\n<span th:text=\"${session.sess}\"></span><br>\n<span th:text=\"${application.app}\"></span><br>\n</body>\n```\n\n## URL表达式\n\nth:href\nth:src\n\n### URL表达式语法\n\n基本语法：@{}\n\n### URL类型\n\n#### 绝对路径\n\n```html\n<a th:href=\"@{http://www.baidu.com}\">绝对路径</a><br/>\n```\n\n#### 相对路径\n\n1)相对于当前项目的根\n相对于项目的上下文的相对路径\n\n```html\n<a th:href=\"@{/show}\">相对路径</a>\n```\n\n2) 相对于服务器路径的根\n\n```html\n<a th:href=\"@{~/project2/resourcename}\">相对于服务器的根</a>\n```\n\n### 在 url  中实现参数传递\n\n```html\n<a th:href=\"@{/show(id=1,name=zhagnsan)}\">相对路径-传参</a>\n```\n\n###   在 url  中通过 restful  风格进行参数传递\n\n```html\n<a th:href=\"@{/path/{id}/show(id=1,name=zhagnsan)}\"> 相 对 路 径 - 传 参\n-restful</a>\n```\n\n","tags":["Spring Boot","thymeleaf"]},{"title":"Spring Boot 整合Freemarker","url":"/2019/03/28/Spring-Boot-整合Freemarker/","content":"\nFreeMarker 是一个模板引擎，一个基于模板生成文本输出的通用工具，使用纯 Java 编写，FreeMarker 被设计用来生成 HTML Web 页面，特别是基于 MVC 模式的应用程序，虽然 FreeMarker 具有一些编程的能力，但通常由 Java 程序准备要显示的数据，由FreeMarker 生成页面，通过模板显示准备的数据。符合MVC模式，采用哈希表存储，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据\n\n\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 整合Freemarker \n\n## 创建maven项目,添加依赖\n\n```xml\n<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-freemarker</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n```\n\n## 编写视图\n\n在templates/ 下建立 userList.ftl:\n\n```html\n<html>\n\t\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<title>显示用户数据</title>\n\t</head>\n\t<body>\n\t\t<table border=\"1\" align=\"center\" width=\"50%\">\n\t\t\t<tr>\n\t\t\t\t<th>ID</th>\n\t\t\t\t<th>Name</th>\n\t\t\t\t<th>Age</th>\n\t\t\t</tr>\n\n            <#list list as user>\n                <tr>\n                    <td>${user.userid}</td>\n                    <td>${user.username}</td>\n                    <td>${user.userage}</td>\n                </tr>\n            </#list>\n\n\t\t</table>\n\t</body>\n</html>\n\n```\n\n## 创建Controller\n\n```java\npackage com.caicai.springbootviewfreemarker.controller;\n\nimport com.caicai.springbootviewfreemarker.pojo.Users;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author liu\n * @title: UserController\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2820:06\n */\n@Controller\npublic class UserController {\n    /**\n     * 处理请求 产生数据\n     */\n    @RequestMapping(\"/showuser\")\n    public String showUser(Model model){\n        List<Users> list = new ArrayList<>();\n        list.add(new Users(1,\"caicai\",21));\n        list.add(new Users(2,\"honghong\",32));\n        list.add(new Users(3,\"mingming\",43));\n        model.addAttribute(\"list\",list);\n        return \"userList\";\n\n    }\n}\n\n```\n\n## 创建Uesrs类\n\n```java\npackage com.caicai.springbootviewfreemarker.pojo;\n\n/**\n * @author liu\n * @title: Users\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2820:06\n */\npublic class Users {\n    private Integer userid;\n    private String username;\n    private Integer userage;\n\n\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Integer getUserage() {\n        return userage;\n    }\n\n    public void setUserage(Integer userage) {\n        this.userage = userage;\n    }\n\n    public Users() {\n    }\n\n    public Integer getUserid() {\n        return userid;\n    }\n\n    public void setUserid(Integer userid) {\n        this.userid = userid;\n    }\n\n    public Users(Integer userid, String username, Integer userage) {\n        this.userid = userid;\n        this.username = username;\n        this.userage = userage;\n    }\n}\n\n```\n\n## 创建启动类\n\n```java\npackage com.caicai.springbootviewfreemarker;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n\n```\n\n","tags":["Spring Boot"]},{"title":"Spring Boot 整合jsp","url":"/2019/03/28/Spring-Boot-整合jsp/","content":"\n Spring Boot 整合jsp\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 创建maven项目,添加pom依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.1.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.caicai</groupId>\n\t<artifactId>08-spring-boot-view-jsp</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>08-spring-boot-view-jsp</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\n        <!-- tomcat支持 -->\n        <dependency>\n            <groupId>org.apache.tomcat.embed</groupId>\n            <artifactId>tomcat-embed-jasper</artifactId>\n        </dependency>\n        <!-- jstl标签库 -->\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>jstl</artifactId>\n        </dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n\n\n## 创建SpringBoot全局配置\n\napplication.yml:\n\n```xml\nspring:\n  mvc:\n    view:\n      prefix: /WEB-INF/jsp/\n      suffix: .jsp\n```\n\n## 创建Users类\n\n```java\npackage com.caicai.springbootviewjsp.pojo;\n\n/**\n * @author liu\n * @title: Users\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2813:16\n */\npublic class Users {\n    private Integer userid;\n    private String username;\n    private Integer userage;\n\n\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Integer getUserage() {\n        return userage;\n    }\n\n    public void setUserage(Integer userage) {\n        this.userage = userage;\n    }\n\n    public Users() {\n    }\n\n    public Integer getUserid() {\n        return userid;\n    }\n\n    public void setUserid(Integer userid) {\n        this.userid = userid;\n    }\n\n    public Users(Integer userid, String username, Integer userage) {\n        this.userid = userid;\n        this.username = username;\n        this.userage = userage;\n    }\n}\n\n```\n\n\n\n## 创建Controller\n\n```java\npackage com.caicai.springbootviewjsp.controller;\n\nimport com.caicai.springbootviewjsp.pojo.Users;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author liu\n * @title: UserController\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2813:15\n */\n@Controller\npublic class UserController {\n    /**\n     * 处理请求 产生数据\n     */\n    @RequestMapping(\"/showuser\")\n    public String showUser(Model model){\n        List<Users> list = new ArrayList<>();\n        list.add(new Users(1,\"caicai\",21));\n        list.add(new Users(2,\"honghong\",32));\n        list.add(new Users(3,\"mingming\",43));\n        model.addAttribute(\"list\",list);\n        return \"userList\";\n\n    }\n}\n\n```\n\n\n\n## 创建jsp\n\nuserList.jsp:\n\n```xml\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n         pageEncoding=\"UTF-8\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Insert title here</title>\n</head>\n<body>\n    <table border=\"1\" align=\"center\" width=\"50%\">\n        <tr>\n            <th>ID:</th>\n            <th>姓名:</th>\n            <th>年龄</th>\n\n        </tr>\n        <c:forEach items=\"${list}\" var=\"user\">\n        <tr>\n            <td>${user.userid}</td>\n            <td>${user.username}</td>\n            <td>${user.userage}</td>\n        </tr>\n\n\n        </c:forEach>\n    </table>\n</body>\n</html>\n```\n\n\n\n## 创建启动类:\n\n```java\npackage com.caicai.springbootviewjsp;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n\n```\n\n\n\n## 效果图:\n\n![](/Spring-Boot-整合jsp/1.png)","tags":["Spring Boot"]},{"title":"Spring-Boot-文件上传","url":"/2019/03/27/Spring-Boot-文件上传/","content":"\nSpring-Boot-文件上传\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 编写Controller\n\n```java\npackage com.caicai.springbootstaticresources1.controller;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * @author liu\n * @title: FileController\n * @projectName 05-spring-boot-static-resources1\n * @description: TODO\n * @date 2019/3/2719:04\n */\n@RestController\npublic class FileController {\n\n    @RequestMapping(value = \"/fileUploadController\")\n    public String fileUpload(@RequestParam(\"filename\") MultipartFile file){\n        System.out.println(file.getName());\n        try {\n            file.transferTo(new File(\"F:/\"+file.getName()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"success\";\n    }\n}\n\n```\n\n## 编写上传界面\n\n为了方便在static文件夹下建立upload.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>文件上传</title>\n</head>\n<body>\n    <form action=\"fileUploadController\" method=\"post\" enctype=\"multipart/form-data\">\n        上传文件:<input type=\"file\" name=\"filename\">\n        <input type=\"submit\">\n    </form>\n</body>\n</html>\n```\n\n## 设置上传文件大小的默认值\n\n在resources下建立application.yml文件\n\n```xml\nspring:\n  servlet:\n    multipart:\n      max-file-size: 10MB   #设置单个上传文件的大小\n      max-request-size: 100MB  #设置一次请求上传文件的总容量\n      enabled: true\n```\n\n","tags":["Spring Boot"]},{"title":"Spring-Boot 整合Servlet和Filter","url":"/2019/03/27/Spring-Boot-整合Servlet/","content":"\nSpring-Boot 整合Servlet和Filter\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 整合Servlet\n\n## 传统方式配置\n\n```xml\n\n<servlet>\n<servlet-name>FirstServlet</servlet-name>\n<servlet-class>com.caicai.springbootservlet.filter.FirstFilter</servlet-class>\n</servlet>\n\n<servlet-mapping>\n<servlet-name>FirstServlet</servlet-name>\n<url-pattern>/first</url-pattern>\n</servlet-mapping>\n\n```\n\n## 通过注解扫描注册Servlet\n\n使用@WebServlet注解并在启动类上使用@ServletComponentScan注解\n\n```java\n@WebServlet(name = \"FirstServlet\",urlPatterns = \"/first\")\npublic class FirstServlet extends HttpServlet{\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"FirstServlet.....\");\n    }\n}\n```\n\n```java\n@SpringBootApplication\n@ServletComponentScan //在SpringBoot启动时会扫描@WebServlet注解 并将该类实例化\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n```\n\n## 通过方法完成Servlet组件的注册\n\n通过使用@Bean注解的形式注册组件\n\n```java\npublic class SecondServlet extends HttpServlet{\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"SecondServlet.....\");\n    }\n}\n```\n\n```java\n@SpringBootApplication\npublic class App2 {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Bean\n    public ServletRegistrationBean getServletRegistrationBean() {\n        ServletRegistrationBean bean = new ServletRegistrationBean(new SecondServlet());\n        bean.addUrlMappings(\"/second\");//添加url路径\n        return bean;\n    }\n}\n```\n\n\n\n\n\n# 整合Filter\n\n## 传统方式配置\n\n```xml\n<filter>\n<filter-name>FirstFilter</filter-name>\n<filter-class>com.caicai.springbootservlet.filter.FirstFilter</filter-class>\n</filter>\n<filter-mapping>\n<filter-name>FirstFilter</filter-name>\n<url-pattern>/filter1</url-pattern>\n</filter-mapping>\n\n```\n\n\n\n## 通过注解扫描注册Servlet\n\n```java\npackage com.caicai.springbootservlet.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n/**\n * @author liu\n * @title: FirstFilter\n * @projectName 02-spring-boot-servlet\n * @description: TODO\n * @date 2019/3/2718:19\n */\n//@WebFilter(filterName = \"\",urlPatterns ={\"*.do\",\"*.jsp\"})\n@WebFilter(filterName = \"FirstFilter\",urlPatterns =\"/filter1\")\npublic class FirstFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println(\"init.......\");\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"进入filter.......\");\n        filterChain.doFilter(servletRequest,servletResponse);\n        System.out.println(\"离开filter.......\");\n\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(\"destroy.......\");\n\n    }\n}\n\n```\n\n启动类:\n\n````java\npackage com.caicai.springbootservlet;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.web.servlet.ServletComponentScan;\n\n@SpringBootApplication\n@ServletComponentScan //在SpringBoot启动时会扫描@WebServlet注解 并将该类实例化\npublic class App3 {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(App3.class, args);\n\t}\n\n}\n\n````\n\n## 通过方法完成Filter的注册\n\n```java\npackage com.caicai.springbootservlet.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n/**\n * @author liu\n * @title: SecondFilter\n * @projectName 02-spring-boot-servlet\n * @description: TODO\n * @date 2019/3/2718:19\n */\n\npublic class SecondFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println(\"init.......\");\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"进入filter2.......\");\n        filterChain.doFilter(servletRequest,servletResponse);\n        System.out.println(\"离开filter2.......\");\n\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(\"destroy.......\");\n\n    }\n}\n\n```\n\n```java\npackage com.caicai.springbootservlet;\n\nimport com.caicai.springbootservlet.filter.SecondFilter;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\n\n@SpringBootApplication\npublic class App4 {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(App4.class, args);\n\t}\n\n\t@Bean\n\tpublic FilterRegistrationBean filterRegistrationBean(){\n        FilterRegistrationBean bean = new FilterRegistrationBean(new SecondFilter()) ;\n        bean.addUrlPatterns(\"/filter2\");\n        return bean;\n    }\n\n}\n```\n\n","tags":["Spring Boot","Servlet"]},{"title":"String，StringBuilder，StringBuffer三者的区别","url":"/2019/03/26/string相关/","content":"\n最近突然被问起String，StringBuilder，StringBuffer三者的区别,发现自己确实对这方面的知识不是很了解.所以学习了一下做个笔记.\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## String\n\n+ String 类是一个常量，String类本身和其中存储字符的数组都是用final关键字修饰的,所以不能被继承\n\n```java\n    /** The value is used for character storage. */\n    private final char value[];\n```\n\n### String str=\"hello world\"和String str=new String(\"hello world\")的区别\n\n\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        String string1 = \"hello word\";\n        String string2 = new String(\"hello world\");\n        String string3 = \"hello word\";\n        String string4 = new String(\"hello world\");\n        System.out.println(string1 == string2);\n        System.out.println(string1 == string3);\n        System.out.println(string2 == string4);\n    }\n}\n\n```\n\n上面代码的输出结果为:\n\nfalse\n\ntrue\n\nfalse\n\n我们发现 同样都都是\"helllo world\" string1 和 string3 相等.是因为string1 和 string3 都是赋值为一个字面常量\"hello world\",在JVM运行时候,会在常量池里寻找是否已经存在相同的常量,如果存在便直接将引用指向已有常量,否则就创建一个常量,并且将引用指向他,对于string2 和string4来说,两者都是采取了new 来创建的,是两个不同的对象,所以不相等.\n\n## StringBuilder\n\n\n\n在第二点中,我们看到String是一个final类,打开StringBuilder,我们发现StringBuilder类是AbstractStringBuilder的子类,在AbstractStringBuilder类中,我们看到与String不同,StringBuilder存储字符的数组是可变的\n\n```java\n  /**\n     * The value is used for character storage.\n     */\n    char[] value;\n```\n\n## StringBuilder和String 区别\n\n\n\n对于实际应用来说 假设有如下代码\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        String string = \"\";\n        for (int i = 0; i < 1000; i++) {\n            string += \"A\";\n        }\n\n\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i < 1000; i++) {\n            stringBuilder.append(\"A\");\n        }\n    }\n}\n\n```\n\n上述代码进行了一个1000次的循环,每次在字符串string后面追加一个字符A,无论使用的是String,还是StringBuilder,最后的结果都为长度为1000的字符全为A的字符串.而不同的是,如果使用StringBuilder,append操作是在原有的对象基础上进行的,而使用String每次循环都会新建一个StringBuilder对象,进行append操作,通过toString方法返回String对象,如果这些对象没有被回收会浪费大量资源,\n\n## StringBuilder和StringBuffer区别\n\n对比StringBuilder和StringBuffer源码,我们发现在StringBuffer中很多方法都加上了synchronized关键字,所以StringBuffer是线程安全的,不过相应的,在提升了安全的同时对资源的消耗也会增大\n\n```java\n        /**\n         * StringBuffer append方法\n         */\n        @Override\n        public synchronized StringBuffer append (String str){\n            toStringCache = null;\n            super.append(str);\n            return this;\n        }\n        \n        /**\n         * StringBuilder append方法\n         */\n\n        @Override\n        public StringBuilder append (String str){\n            super.append(str);\n            return this;\n        }\n```\n\n## 结论\n\n三个类应当根据不同的情况来进行选择使用：\n\n当字符串相加操作或者改动较少的情况下，建议使用 String str=\"hello\"这种形式\n\n当字符串相加操作较多的情况下，建议使用StringBuilder\n\n如果采用了多线程，则使用StringBuffer。\n\n","tags":["java","String"]},{"title":"swagger2简介","url":"/2019/03/19/swagger2简介/","content":"\nSwagger 是一款RESTFUL接口的、基于YAML、JSON语言的文档在线自动生成、代码自动生成的工具。\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 关于Swagger\n\n\n\nSwagger能成为最受欢迎的REST APIs文档生成工具之一，有以下几个原因：\n\n- Swagger 可以生成一个具有互动性的API控制台，开发者可以用来快速学习和尝试API。\n- Swagger 可以生成客户端SDK代码用于各种不同的平台上的实现。\n- Swagger 文件可以在许多不同的平台上从代码注释中自动生成。\n- Swagger 有一个强大的社区，里面有许多强悍的贡献者。\n\nSwagger 文档提供了一个方法，使我们可以用指定的 JSON 或者 YAML 摘要来描述你的 API，包括了比如 names、order 等 API 信息。\n\n你可以通过一个文本编辑器来编辑 Swagger 文件，或者你也可以从你的代码注释中自动生成。各种工具都可以使用 Swagger 文件来生成互动的 API 文档。\n\n> 注意：用 Swagger 文件生成互动的 API 文档是最精简的，它展示了资源、参数、请求、响应。但是它不会提供你的API如何工作的其他任何一个细节。\n\n## Spring Boot集成使用Swagger\n\n### 创建Spring Boot Web工程并且引入Swagger依赖\n\n所需Swagger依赖可以在[Maven仓库](https://mvnrepository.com/) 中找查询\n\n```xml\n        <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 -->\n        <dependency>\n            <groupId>io.springfox</groupId>\n            <artifactId>springfox-swagger2</artifactId>\n            <version>2.9.2</version>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui -->\n        <dependency>\n            <groupId>io.springfox</groupId>\n            <artifactId>springfox-swagger-ui</artifactId>\n            <version>2.9.2</version>\n        </dependency>\n\n```\n\n### 创建User实体类\n\n```java\npackage com.example.demo.domain;\n\n/**\n * @author liu\n * @title: User\n * @projectName demo\n * @description: TODO\n * @date 2019/3/1821:52\n */\npublic class User {\n    private Long id;\n    private String username;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                '}';\n    }\n}\n\n```\n\n### 在启动类目录创建Swagger2配置类\n\n```java\npackage com.example.demo;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n@Configuration\n@EnableSwagger2\npublic class Swagger2  {\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(\"com.example.demo.controller\"))//扫描controller下的包\n                .paths(PathSelectors.any())\n                .build();\n    }\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                .title(\"Spring Boot中使用Swagger2构建RESTful APIs\")\n                .description(\"swagger2 构建APIS\")\n                .version(\"1.0\")\n                .build();\n    }\n}\n```\n\n### 创建UserController类\n\n```java\npackage com.example.demo.controller;\n\nimport com.example.demo.domain.User;\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiImplicitParam;\nimport io.swagger.annotations.ApiImplicitParams;\nimport io.swagger.annotations.ApiOperation;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author liu\n * @title: HelloController\n * @projectName demo\n * @description: TODO\n * @date 2019/3/1821:48\n */\n@RestController\n@Api(tags = \"用户模块\")\n@RequestMapping(value = \"/user\")\npublic class UserController {\n    /**\n     * 此处为了方便直接用一个Map来模拟数据库进行操作\n     */\n    static Map<Long, User> userMap;\n\n    static {\n        userMap = new HashMap<>();\n        User user = new User();\n        user.setId((long) 10000);\n        user.setUsername(\"admin\");\n        userMap.put((long) 10000,user);\n    }\n\n    @ApiOperation(value = \"获取用户列表\")\n    @RequestMapping(value = \"list\", method = RequestMethod.GET)\n    public List<User> getUserList() {\n\n        return new ArrayList<User>(userMap.values());\n    }\n\n\n    @ApiOperation(value = \"创建用户\")\n    @ApiImplicitParams({@ApiImplicitParam(paramType = \"query\", name = \"id\", dataType = \"Long\", required = true, value = \"用户id\", defaultValue = \"10001\"),\n            @ApiImplicitParam(paramType = \"query\", name = \"username\", dataType = \"String\", required = true, value = \"用户名字\", defaultValue = \"菜菜\")\n    })\n    @RequestMapping(value = \"\", method = RequestMethod.POST)\n    public String postUser(User user) {\n\n        userMap.put(user.getId(),user);\n        return \"添加成功\";\n    }\n\n\n\n    @ApiOperation(value = \"获取用户\")\n    @ApiImplicitParam(paramType = \"query\", required = true, name = \"id\", dataType = \"Long\", value = \"用户id\")\n    @RequestMapping(value = \"\", method = RequestMethod.GET)\n    public User getUser(@RequestParam(\"id\") Long id) {\n        System.out.println(id);\n        return userMap.get(id);\n    }\n\n\n\n    @ApiOperation(value = \"更新用户\")\n    @ApiImplicitParams({@ApiImplicitParam(paramType = \"query\", name = \"id\", dataType = \"Long\", required = true, value = \"用户id\", defaultValue = \"10001\"),\n            @ApiImplicitParam(paramType = \"query\", name = \"username\", dataType = \"String\", required = true, value = \"用户名字\", defaultValue = \"菜菜\")\n    })\n    @RequestMapping(value = \"\", method = RequestMethod.PUT)\n    public String putUser(User user) {\n        userMap.put(user.getId(),user);\n        return \"更新成功\";\n    }\n\n\n    @ApiOperation(value = \"删除用户\")\n    @ApiImplicitParam(paramType = \"query\", required = true, name = \"id\", dataType = \"Long\", value = \"用户id\")\n    @RequestMapping(value = \"\", method = RequestMethod.DELETE)\n    public String deleteUser(@RequestParam(\"id\") Long id) {\n        userMap.remove(id);\n        return \"删除成功\";\n    }\n}\n\n```\n\n### 测试:\n\n主界面:\n\n![主界面](/swagger2简介/1.png)\n\n查询用户列表:\n\n![](/swagger2简介/2.png)\n\n创建用户:\n\n![](/swagger2简介/3.png)\n\n获取用户:\n\n![](/swagger2简介/4.png)\n\n删除用户:\n\n![](/swagger2简介/5.png)\n\n## 使用过程中遇到的问题\n\n(1)java.lang.NumberFormatException: For input string: \"\"\n\n在使用@ApiModelProperty注解在字段上时，如果字段的类型为Long或是int类型，那么程序启动后，访问swagger-ui.html的页面，程序会报错\n\njava.lang.NumberFormatException: For input string: \"\"\n在swagger的官方文档中介绍是一个bug；可以忽略这个错误，如果看着不爽，可以调整日志的级别\n\napplication.yml:\n\n```xml\nlogging:\n  level:\n    io.swagger.models.parameters.AbstractSerializableParameter: error\n```\n\n\n\n(2)@Api()注解中使用tags = \"\"参数才能改变api名字 例如@Api(tags = \"用户模块\")\n\n\n\n(3)requestparam 和pathvariable区别 :\n\n@PathVariable:从路径路去获取变量,也就是把路径名当作变量 例如:\n\n```xml\nhttp://localhost:8080/user?id=5\n```\n\n@RequestParam:从请求里面获取参数,例如:\n\n```xml\nhttp://localhost:8080/user?5\n```\n\n","tags":["Spring Boot","swagger"]},{"title":"mysql的时区错误问题： The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one","url":"/2019/03/18/mysql的时区错误问题：-The-server-time-zone-value-OÐ¹u±e×¼E±¼a-is-unrecognized-or-represents-more-than-one/","content":"\n链接数据库时候出现cexception is org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException:\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n## spring boot 链接数据库的时候报错\n\n```java\ncexception is org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: \n### Error querying database.  Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Connections could not be acquired from the underlying database!\n### The error may exist in com/wj/mapper/UserLoginMapper.xml\n### The error may involve com.wj.mapper.UserLoginMapper.selectByName\n### The error occurred while executing a query\n### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Connections could not be acquired from the underlying database!\n    org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:982)\n    org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872)\n    javax.servlet.http.HttpServlet.service(HttpServlet.java:650)\n    org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)\n    javax.servlet.http.HttpServlet.service(HttpServlet.java:731)\n```\n```java\njava.sql.SQLException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:127)\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:95)\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:87)\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:61)\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:71)\n    com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:76)\n    com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:862)\n    com.mysql.cj.jdbc.ConnectionImpl.<init>(ConnectionImpl.java:444)\n    com.mysql.cj.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:230)\n    com.mysql.cj.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:226)\n    com.mchange.v2.c3p0.DriverManagerDataSource.getConnection(DriverManagerDataSource.java:175)\n    com.mchange.v2.c3p0.WrapperConnectionPoolDataSource.getPooledConnection(WrapperConnectionPoolDataSource.java:220)\n    com.mchange.v2.c3p0.WrapperConnectionPoolDataSource.getPooledConnection(WrapperConnectionPoolDataSource.java:206)\n    com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool$1PooledConnectionResourcePoolManager.acquireResource(C3P0PooledConnectionPool.java:203)\n    com.mchange.v2.resourcepool.BasicResourcePool.doAcquire(BasicResourcePool.java:1138)\n    com.mchange.v2.resourcepool.BasicResourcePool.doAcquireAndDecrementPendingAcquiresWithinLockOnSuccess(BasicResourcePool.java:1125)\n    com.mchange.v2.resourcepool.BasicResourcePool.access$700(BasicResourcePool.java:44)\n    com.mchange.v2.resourcepool.BasicResourcePool$ScatteredAcquireTask.run(BasicResourcePool.java:1870)\n    com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread.run(ThreadPoolAsynchronousRunner.java:696)\n```\n## 解决方案:\n\n据查询是因为电脑的时区和mysql的时区不一样导致的\n用 打开mysql \n\n```sql\nshow variables like '%time_zone%'; //查询mysql的时区\nset global time_zone='+8:00'; //设置时区\n```","tags":["MYSQL","Spring Boot"]},{"title":"navicat 连接 mysql   Client does not support authentication protocol requested by server","url":"/2019/03/18/navicat-连接-mysql-Client-does-not-support-authentication-protocol-requested-by-server/","content":"\nClient does not support authentication protocol requested by server; consider upgrading MySQL client\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 报错信息:\n\n```java\nClient does not support authentication protocol requested by server; consider upgrading MySQL client\n```\n\n## 解决方案:\n\n打开mysql的MySQL Command Line Client 输入:\n```\nUSE mysql;\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';\nFLUSH PRIVILEGES; \n```\n\nlocalhost:本机地址\n123456:要设置的密码","tags":["MYSQL"]},{"title":"hexo 常用命令","url":"/2019/03/18/hexo-常用命令/","content":"\nhexo 的一些常用命令\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## hexo\n\n```\nnpm install hexo -g #安装  \nnpm update hexo -g #升级  \nhexo init #初始化\n```\n\n## 简写\n\n`hexo n \"我的博客\"` == `hexo new \"我的博客\"` #新建文章\n`hexo p` == `hexo publish`\n`hexo g` == `hexo generate`#生成\n`hexo s` == `hexo server` #启动服务预览\n`hexo d` == `hexo deploy`#部署\n\n## 服务器\n\n`hexo server` #Hexo 会监视文件变动并自动更新，您无须重启服务器。\n`hexo server -s` #静态模式\n`hexo server -p 5000` #更改端口\n`hexo server -i 192.168.1.1` #自定义 IP\n\n`hexo clean` #清除缓存 网页正常情况下可以忽略此条命令\n`hexo g` #生成静态网页\n`hexo d` #开始部署\n\n### 监视文件变动\n\n`hexo generate` #使用 Hexo 生成静态文件快速而且简单\n`hexo generate --watch` #监视文件变动\n\n### 完成后部署\n\n> 两个命令的作用是相同的\n> `hexo generate --deploy`\n> `hexo deploy --generate`\n\n```\nhexo deploy -g`\n`hexo server -g\n```\n\n## 草稿\n\n```\nhexo publish [layout] <title>\n```\n\n## 模版\n\n`hexo new \"postName\"` #新建文章\n`hexo new page \"pageName\"` #新建页面\n`hexo generate` #生成静态页面至public目录\n`hexo server` #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n`hexo deploy` #将.deploy目录部署到GitHub\n\n```\nhexo new [layout] <title>`\n`hexo new photo \"My Gallery\"`\n`hexo new \"Hello World\" --lang tw\n```\n\n| 变量   | 描述         |\n| ------ | ------------ |\n| layout | 布局         |\n| title  | 标题         |\n| date   | 文件建立日期 |\n\n```\ntitle: 使用Hexo搭建个人博客\nlayout: post\ndate: 2019-03-18 14:59:30\ncomments: true\ncategories: Blog\ntags: [Hexo]\nkeywords: Hexo, Blog\ndescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。\n```\n\n## 模版（Scaffold）\n\n```\nhexo new photo \"My Gallery\"\n```\n\n| 变量   | 描述         |\n| ------ | ------------ |\n| layout | 布局         |\n| title  | 标题         |\n| date   | 文件建立日期 |\n\n## 设置文章摘要\n\n```\n以上是文章摘要 <!--more--> 以下是余下全文 \n```\n\n## 写作\n\n```\nhexo new page <title>`\n`hexo new post <title>\n```\n\n| 变量     | 描述                       |\n| -------- | -------------------------- |\n| :title   | 标题                       |\n| :year    | 建立的年份（4 位数）       |\n| :month   | 建立的月份（2 位数）       |\n| :i_month | 建立的月份（去掉开头的零） |\n| :day     | 建立的日期（2 位数）       |\n| :i_day   | 建立的日期（去掉开头的零） |\n\n### 推送到服务器上\n\n```\nhexo n` #写文章\n`hexo g` #生成\n`hexo d` #部署 #可与`hexo g`合并为 `hexo d -g\n```\n\n## 报错\n\n### 1.找不到git部署\n\n```\nERROR Deployer not found: git\n```\n\n**解决方法**\n\n```\nnpm install hexo-deployer-git --save\n```\n\n### 3.部署类型设置git\n\nhexo 3.0 部署类型不再是`github`，`_config.yml` 中修改\n\n```\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@***.github.com:***/***.github.io.git\n  branch: master\n```\n\n### 4. xcodebuild\n\nxcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance\n\n```\nnpm install bcrypt\n```\n\n### 5. RSS不显示\n\n#### 安装RSS插件\n\n```\nnpm install hexo-generator-feed --save\n```\n\n#### 开启RSS功能\n\n编辑hexo/_config.yml，添加如下代码：\n\n```\nrss: /atom.xml #rss地址  默认即可\n```","tags":["hexo"]}]