[{"title":"Java Builder Pattern","url":"/2019/05/15/Java-Builder-Pattern/","content":"\n静态工厂和构造函数有一个共同的限制:它们不能很好地扩展到大量可选参数，所以考虑通过构造器来构造一个类的实例。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n# Telescoping constructor pattern\n\n通常我们在创建一个类的实例时候都是用它的构造函数来创建。例如：\n\n```java\n// Telescoping constructor pattern - does not scale well!\npublic class NutritionFacts {\n    private final int servingSize; // (mL) required\n    private final int servings; // (per container) required\n    private final int calories; // (per serving) optional\n    private final int fat; // (g/serving) optional\n    private final int sodium; // (mg/serving) optional\n    private final int carbohydrate; // (g/serving) optional\n\n    public NutritionFacts(int servingSize, int servings) {\n        this(servingSize, servings, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings,\n                          int calories) {\n        this(servingSize, servings, calories, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings,\n                          int calories, int fat) {\n        this(servingSize, servings, calories, fat, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings,\n                          int calories, int fat, int sodium) {\n        this(servingSize, servings, calories, fat, sodium, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings,\n                          int calories, int fat, int sodium, int carbohydrate) {\n        this.servingSize = servingSize;\n        this.servings = servings;\n        this.calories = calories;\n        this.fat = fat;\n        this.sodium = sodium;\n        this.carbohydrate = carbohydrate;\n    }\n}\n```\n\n\n\n```java\nNutritionFacts cocaCola =\nnew NutritionFacts(240, 8, 100, 0, 35, 27);\n```\n\n但是这种方式存在很多不便之处：\n\n+ 即使只需要设定一部分参数也要为不需要设置的参数设置默认值\n+ 当参数过多的时候，尤其是存在许多同类型的参数的时候，很容易产生参数设置的混淆，这种混淆编译是不会发现的，在程序运行的时候才会产生错误\n+ 代码不易读懂，用户使用函数时候需要参照api\n\n\n\n# JavaBeans Pattern\n\n另外一种可选的方式是javabean的形式，其主要理念是通过空构造函数来创建一个实例，然后通过set方法对参数进行赋值。例如：\n\n```java\n// JavaBeans Pattern - allows inconsistency, mandates mutability\npublic class NutritionFacts {\n    // Parameters initialized to default values (if any)\n    private int servingSize = -1; // Required; no default value\n    private int servings = -1; // Required; no default value\n    private int calories = 0;\n    private int fat = 0;\n    private int sodium = 0;\n    private int carbohydrate = 0;\n\n    public NutritionFacts() {\n    }\n\n    // Setters\n    public void setServingSize(int val) {\n        servingSize = val;\n    }\n\n    public void setServings(int val) {\n        servings = val;\n    }\n\n    public void setCalories(int val) {\n        calories = val;\n    }\n\n    public void setFat(int val) {\n        fat = val;\n    }\n\n    public void setSodium(int val) {\n        sodium = val;\n    }\n\n    public void setCarbohydrate(int val) {\n        carbohydrate = val;\n    }\n}\n```\n\n这种模式没有Telescoping constructor pattern的任何缺点。\n\n创建实例很容易，虽然有点冗长，并且很容易读取生成的代码:\n\n```java\nNutritionFacts cocaCola = new NutritionFacts();\ncocaCola.setServingSize(240);\ncocaCola.setServings(8);\ncocaCola.setCalories(100);\ncocaCola.setSodium(35);\ncocaCola.setCarbohydrate(27);\n```\n\n但是，javabean模式本身有严重的缺点。因为构造是在多个调用之间分割的，所以JavaBean在构造过程中可能处于不一致的状态。\n\n# Builder pattern \n\n客户机不直接生成所需的对象，而是使用所有必需的参数调用构造函数(或静态工厂)并获得一个构建器对象。然后客户端调用builder对象上类似setter的方法来设置每个可选参数。最后，客户端调用一个无参数的构建方法来生成对象，该对象通常是不可变的。\n\n```java\n/**\n * @Author liu\n * @Description //TODO\n * @Date 9:08 2019/5/15\n * @Param\n * @return\n **/\npublic class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private final int carbohydrate;\n\n    public static class Builder {\n        // Required parameters\n        private final int servingSize;\n        private final int servings;\n        // Optional parameters - initialized to default values\n        private int calories = 0;\n        private int fat = 0;\n        private int sodium = 0;\n        private int carbohydrate = 0;\n\n        public Builder(int servingSize, int servings) {\n            this.servingSize = servingSize;\n            this.servings = servings;\n        }\n\n        public Builder calories(int val) {\n            calories = val;\n            return this;\n        }\n\n        public Builder fat(int val) {\n            fat = val;\n            return this;\n        }\n\n        public Builder sodium(int val) {\n            sodium = val;\n            return this;\n        }\n\n        public Builder carbohydrate(int val) {\n            carbohydrate = val;\n            return this;\n        }\n\n        public NutritionFacts build() {\n            return new NutritionFacts(this);\n        }\n    }\n\n    private NutritionFacts(Builder builder) {\n        servingSize = builder.servingSize;\n        servings = builder.servings;\n        calories = builder.calories;\n        fat = builder.fat;\n        sodium = builder.sodium;\n        carbohydrate = builder.carbohydrate;\n    }\n\n    public static void main(String[] args) {\n        NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)\n                .calories(100).sodium(35).carbohydrate(27).build();\n    }\n}\n```\n\nBuilder pattern也有缺点。为了创建对象，必须首先创建它的构建器。虽然在实践中创建这个构建器的成本不太可能显著，但在性能关键的情况下，它可能会成为一个问题。此外，Builder pattern的代码较为冗长，在设计构造函数或静态工厂有多个参数的类时，尤其是当许多参数是可选的或具有相同类型时，Builder模式是一个很好的选择，因为它更易读、更安全。","tags":["JAVA","Effective Java"]},{"title":"java文件夹拷贝","url":"/2019/05/13/java文件夹拷贝/","content":"\n使用File类和io流对一个文件夹进行拷贝\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n```java\nimport java.io.*;\n\n/**\n * @Author liu\n * @Description //TODO\n * @Date 15:16 2019/5/13\n * @Param\n * @return\n **/\npublic class Main {\n\n    public static void main(String[] args) {\n        File file = new File(\"D:\", \"attached\");//要拷贝的文件夹目录\n        copy(file, \"D:\\\\copy\"); //\"D:\\\\copy\"为拷贝到的文件夹目录\n    }\n\n    /**\n     * @return void\n     * @Author liu\n     * @Description 对文件夹进行遍历，调用copyfile拷贝\n     * @Date 15:15 2019/5/13\n     * @Param [file, path]\n     **/\n    private static void copy(File file, String path) {\n\n        if (null == file) {\n            return;\n        }\n        File[] files = file.listFiles();\n        for (File file1 : files) {\n            if (file1.isFile()) {\n                copyfile(file1.getAbsolutePath(), path + file1.getAbsolutePath().substring(file1.getAbsolutePath().indexOf(\"\\\\\")));\n            } else if (file1.isDirectory()) {\n                copyfile(file1.getAbsolutePath(), path + file1.getAbsolutePath().substring(file1.getAbsolutePath().indexOf(\"\\\\\")));\n                copy(file1, path);\n            }\n        }\n    }\n\n    /**\n     * @return void\n     * @Author liu\n     * @Description //TODO\n     * @Date 15:15 2019/5/13\n     * @Param [path1, path2]\n     **/\n    private static void copyfile(String path1, String path2) {\n        System.out.println(path1);\n        System.out.println(path2);\n        File file = new File(path1);\n        File file1 = new File(path2);\n\n        if (!file.exists()) {\n            return;\n        }\n        //如果是文件夹就创建文件夹，否则使用FileInputstream复制文件。\n        if (file.isDirectory()) {\n            file1.mkdirs();\n            return;\n        }\n        try {\n            int n;\n            FileInputStream fileInputStream = new FileInputStream(file);\n            FileOutputStream fileOutputStream = new FileOutputStream(new File(path2));\n            byte[] bytes = new byte[1024];\n            while ((n = fileInputStream.read(bytes)) != -1) {\n                fileOutputStream.write(bytes, 0, n);\n                fileOutputStream.flush();\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n\n```\n\n","tags":["JAVA"]},{"title":"java异常、线程","url":"/2019/05/12/java异常、线程/","content":"\n异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：\n\n- **异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。\n\n在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 1.1 异常概念\n\n异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：\n\n- **异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。\n\n在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。\n\n> 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.\n\n## 1.2 异常体系\n\n异常机制其实是帮助我们**找到**程序中的问题，异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`。\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png)\n\n**Throwable体系：**\n\n- **Error**:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。\n- **Exception**:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。\n\n**Throwable中的常用方法：**\n\n- `public void printStackTrace()`:打印异常的详细信息。\n\n  *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*\n\n- `public String getMessage()`:获取发生异常的原因。\n\n  *提示给用户的时候,就提示错误原因。*\n\n- `public String toString()`:获取异常的类型和异常描述信息(不用)。\n\n***出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。***\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9F%A5%E7%9C%8B.bmp)\n\n## 1.3 异常分类\n\n我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。\n\n**异常(Exception)的分类**:根据在编译时期还是运行时期去检查异常?\n\n- **编译时期异常**:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)\n- **运行时期异常**:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)\n\n​    ![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png)\n\n## 1.4     异常的产生过程解析\n\n先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。\n\n 工具类\n\n```java\npublic class ArrayTools {\n    // 对给定的数组通过给定的角标获取元素。\n    public static int getElement(int[] arr, int index) {\n        int element = arr[index];\n        return element;\n    }\n}\n```\n\n 测试类\n\n```java\npublic class ExceptionDemo {\n    public static void main(String[] args) {\n        int[] arr = { 34, 12, 67 };\n        intnum = ArrayTools.getElement(arr, 4)\n        System.out.println(\"num=\" + num);\n        System.out.println(\"over\");\n    }\n}\n```\n\n上述程序执行过程图解：\n\n ![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png)\n\n# 第二章 异常的处理\n\nJava异常处理的五个关键字：**try、catch、finally、throw、throws**\n\n## 2.1 \t抛出异常throw\n\n在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。\n\n在java中，提供了一个**throw**关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？\n\n1. 创建一个异常对象。封装一些提示信息(信息可以自己编写)。\n\n2. 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。\n\n   throw**用在方法内**，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。\n\n**使用格式：**\n\n```\nthrow new 异常类名(参数);\n```\n\n 例如：\n\n```java\nthrow new NullPointerException(\"要访问的arr数组不存在\");\n\nthrow new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\");\n```\n\n学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。\n\n```java\npublic class ThrowDemo {\n    public static void main(String[] args) {\n        //创建一个数组 \n        int[] arr = {2,4,52,2};\n        //根据索引找对应的元素 \n        int index = 4;\n        int element = getElement(arr, index);\n\n        System.out.println(element);\n        System.out.println(\"over\");\n    }\n    /*\n     * 根据 索引找到数组中对应的元素\n     */\n    public static int getElement(int[] arr,int index){ \n       \t//判断  索引是否越界\n        if(index<0 || index>arr.length-1){\n             /*\n             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。\n             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 \n              */\n             throw new ArrayIndexOutOfBoundsException(\"哥们，角标越界了~~~\");\n        }\n        int element = arr[index];\n        return element;\n    }\n}\n```\n\n> 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。\n>\n> 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。\n\n## 2.2 Objects非空判断\n\n还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。\n\n- `public static <T> T requireNonNull(T obj)`:查看指定引用对象不是null。\n\n查看源码发现这里对为null的进行了抛出异常操作：\n\n```java\npublic static <T> T requireNonNull(T obj) {\n    if (obj == null)\n      \tthrow new NullPointerException();\n    return obj;\n}\n```\n\n## 2.3  声明异常throws\n\n**声明异常**：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。\n\n关键字**throws**运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).\n\n**声明异常格式：**\n\n```\n修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }\t\n```\n\n声明异常的代码演示：\n\n```java\npublic class ThrowsDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        read(\"a.txt\");\n    }\n\n    // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n```\n\nthrows用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。\n\n```java\npublic class ThrowsDemo2 {\n    public static void main(String[] args) throws IOException {\n        read(\"a.txt\");\n    }\n\n    public static void read(String path)throws FileNotFoundException, IOException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n        if (!path.equals(\"b.txt\")) {\n            throw new IOException();\n        }\n    }\n}\n```\n\n## 2.4  捕获异常try…catch\n\n如果异常出现的话,会立刻终止程序,所以我们得处理异常:\n\n1. 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。\n2. 在方法中使用try-catch的语句块来处理异常。\n\n**try-catch**的方式就是捕获异常。\n\n- **捕获异常**：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。\n\n捕获异常语法如下：\n\n```java\ntry{\n     编写可能会出现异常的代码\n}catch(异常类型  e){\n     处理异常的代码\n     //记录日志/打印异常信息/继续抛出异常\n}\n```\n\n**try：**该代码块中编写可能产生异常的代码。\n\n**catch：**用来进行某种异常的捕获，实现对捕获到的异常进行处理。\n\n> 注意:try和catch都不能单独使用,必须连用。\n\n演示如下：\n\n```java\npublic class TryCatchDemo {\n    public static void main(String[] args) {\n        try {// 当产生异常时，必须有处理方式。要么捕获，要么声明。\n            read(\"b.txt\");\n        } catch (FileNotFoundException e) {// 括号中需要定义什么呢？\n          \t//try中抛出的是什么异常，在括号中就定义什么异常类型\n            System.out.println(e);\n        }\n        System.out.println(\"over\");\n    }\n    /*\n     *\n     * 我们 当前的这个方法中 有异常  有编译期异常\n     */\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n```\n\n如何获取异常信息：\n\nThrowable类中定义了一些查看方法:\n\n- `public String getMessage()`:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。\n\n- `public String toString()`:获取异常的类型和异常描述信息(不用)。\n- `public void printStackTrace()`:打印异常的跟踪栈信息并输出到控制台。\n\n​            *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*\n\n## 2.4 finally 代码块\n\n**finally**：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。\n\n什么时候的代码必须最终执行？\n\n当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。\n\nfinally的语法:\n\n try...catch....finally:自身需要处理异常,最终还得关闭资源。\n\n> 注意:finally不能单独使用。\n\n比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。\n\nfinally代码参考如下：\n\n```java\npublic class TryCatchDemo4 {\n    public static void main(String[] args) {\n        try {\n            read(\"a.txt\");\n        } catch (FileNotFoundException e) {\n            //抓取到的是编译期异常  抛出去的是运行期 \n            throw new RuntimeException(e);\n        } finally {\n            System.out.println(\"不管程序怎样，这里都将会被执行。\");\n        }\n        System.out.println(\"over\");\n    }\n    /*\n     *\n     * 我们 当前的这个方法中 有异常  有编译期异常\n     */\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n```\n\n> 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E6%AD%BB%E4%BA%86%E9%83%BD%E8%A6%81try.bmp)\n\n## 2.5   异常注意事项\n\n- 多个异常使用捕获又该如何处理呢？\n\n  1. 多个异常分别处理。\n  2. 多个异常一次捕获，多次处理。\n  3. 多个异常一次捕获一次处理。\n\n  一般我们是使用一次捕获多次处理方式，格式如下：\n\n  ```java\n  try{\n       编写可能会出现异常的代码\n  }catch(异常类型A  e){  当try中出现A类型异常,就用该catch来捕获.\n       处理异常的代码\n       //记录日志/打印异常信息/继续抛出异常\n  }catch(异常类型B  e){  当try中出现B类型异常,就用该catch来捕获.\n       处理异常的代码\n       //记录日志/打印异常信息/继续抛出异常\n  }\n  ```\n\n  > 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。\n\n- 运行时异常被抛出可以不处理。即不捕获也不声明抛出。\n\n- 如果finally有return语句,永远返回finally中的结果,避免该情况. \n\n- 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。\n\n- 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出\n\n# 第三章 自定义异常\n\n## 3.1 概述\n\n**为什么需要自定义异常类:**\n\n我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。\n\n在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？\n\n**什么是自定义异常类:**\n\n在开发中根据自己业务的异常情况来定义异常类.\n\n自定义一个业务逻辑异常: **RegisterException**。一个注册异常类。\n\n**异常类如何定义:**\n\n1. 自定义一个编译期异常: 自定义类 并继承于`java.lang.Exception`。\n2. 自定义一个运行时期的异常类:自定义类 并继承于`java.lang.RuntimeException`。\n\n## 3.2 自定义异常的练习\n\n要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。\n\n首先定义一个登陆异常类RegisterException：\n\n```java\n// 业务逻辑异常\npublic class RegisterException extends Exception {\n    /**\n     * 空参构造\n     */\n    public RegisterException() {\n    }\n\n    /**\n     *\n     * @param message 表示异常提示\n     */\n    public RegisterException(String message) {\n        super(message);\n    }\n}\n```\n\n模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。\n\n```java\npublic class Demo {\n    // 模拟数据库中已存在账号\n    private static String[] names = {\"bill\",\"hill\",\"jill\"};\n   \n    public static void main(String[] args) {     \n        //调用方法\n        try{\n              // 可能出现异常的代码\n            checkUsername(\"nill\");\n            System.out.println(\"注册成功\");//如果没有异常就是注册成功\n        }catch(RegisterException e){\n            //处理异常\n            e.printStackTrace();\n        }\n    }\n\n    //判断当前注册账号是否存在\n    //因为是编译期异常，又想调用者去处理 所以声明该异常\n    public static boolean checkUsername(String uname) throws LoginException{\n        for (String name : names) {\n            if(name.equals(uname)){//如果名字在这里面 就抛出登陆异常\n                throw new RegisterException(\"亲\"+name+\"已经被注册了！\");\n            }\n        }\n        return true;\n    }\n}\n```\n\n# 第四章 多线程\n\n我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？\n\n要解决上述问题,咱们得使用多进程或者多线程来解决.\n\n## 4.1 并发与并行\n\n- **并发**：指两个或多个事件在**同一个时间段内**发生。\n- **并行**：指两个或多个事件在**同一时刻**发生（同时发生）。\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91.bmp)\n\n在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。\n\n而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。\n\n> 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。\n\n## 4.2 线程与进程\n\n- **进程**：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。\n\n- **线程**：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 \n\n  简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 \n\n我们可以再电脑底部任务栏，右键----->打开任务管理器,可以查看当前任务的进程：\n\n**进程**\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5.png)\n\n**线程**\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png)\n\n**线程调度:**\n\n- 分时调度\n\n  所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。\n\n- 抢占式调度\n\n  优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。\n\n  - 设置线程的优先级\n\n  ![设置线程优先级](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.bmp)\n\n  - 抢占式调度详解\n\n    大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。\n\n    实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。\n    其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。\n\n    ![抢占式调度](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.bmp)\n\n## 4.3 创建线程类\n\nJava使用`java.lang.Thread`类代表**线程**，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来**创建**并**启动多线程**的步骤如下：\n\n1. 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。\n2. 创建Thread子类的实例，即创建了线程对象\n3. 调用线程对象的start()方法来启动该线程\n\n代码如下：\n\n测试类：\n\n```java\npublic class Demo01 {\n\tpublic static void main(String[] args) {\n\t\t//创建自定义线程对象\n\t\tMyThread mt = new MyThread(\"新的线程！\");\n\t\t//开启新线程\n\t\tmt.start();\n\t\t//在主方法中执行for循环\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tSystem.out.println(\"main线程！\"+i);\n\t\t}\n\t}\n}\n```\n\n自定义线程类：\n\n```java\npublic class MyThread extends Thread {\n\t//定义指定线程名称的构造方法\n\tpublic MyThread(String name) {\n\t\t//调用父类的String参数的构造方法，指定线程的名称\n\t\tsuper(name);\n\t}\n\t/**\n\t * 重写run方法，完成该线程执行的逻辑\n\t */\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tSystem.out.println(getName()+\"：正在执行！\"+i);\n\t\t}\n\t}\n}\n```","tags":["java"]},{"title":"java集合工具对自定义类进行排序","url":"/2019/05/11/java集合工具对自定义类进行排序/","content":"\n想要被排序的类需要实现Comparable接口并且重写compareTo方法。 this - 传进来的参数为升序。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n```java\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) throws ParseException {\n\n        List<User> list = new ArrayList<User>();\n        list.add(new User(65, \"小张\"));\n        list.add(new User(77, \"小强\"));\n        list.add(new User(39, \"小明\"));\n        list.add(new User(99, \"小红\"));\n        Collections.sort(list);\n        System.out.println(list);\n    }\n\n}\n\nclass User implements Comparable<User> {\n    private int score;\n    private String name;\n\n    public User(int score, String name) {\n\n        this.score = score;\n        this.name = name;\n    }\n\n    public int getScore() {\n        return score;\n    }\n\n    public void setScore(int score) {\n        this.score = score;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"score=\" + score +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n\n    @Override\n    public int compareTo(User o) {\n        return this.getScore() - o.getScore();\n    }\n}\n```\n\n","tags":["JAVA"]},{"title":"java常用类api","url":"/2019/05/10/java常用类api/","content":"\njava常用类api\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n#  Object类\n\n## 1.1 概述\n\n`java.lang.Object`类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。\n\n如果一个类没有特别指定父类，\t那么默认则继承自Object类。例如：\n\n```java\npublic class MyClass /*extends Object*/ {\n  \t// ...\n}\n```\n\n根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：\n\n- `public String toString()`：返回该对象的字符串表示。\n- `public boolean equals(Object obj)`：指示其他某个对象是否与此对象“相等”。\n\n## 1.2 toString方法\n\n### 方法摘要\n\n- `public String toString()`：返回该对象的字符串表示。\n\ntoString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。\n\n由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。\n\n### 覆盖重写\n\n如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：\n\n```java\npublic class Person {  \n    private String name;\n    private int age;\n\n    @Override\n    public String toString() {\n        return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}';\n    }\n\n    // 省略构造器与Getter Setter\n}\n```\n\n在IntelliJ IDEA中，可以点击`Code`菜单中的`Generate...`，也可以使用快捷键`alt+insert`，点击`toString()`选项。选择需要包含的成员变量并确定。如下图所示：\n\n> 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。\n\n## 1.3 equals方法\n\n### 方法摘要\n\n- `public boolean equals(Object obj)`：指示其他某个对象是否与此对象“相等”。\n\n调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。\n\n### 默认地址比较\n\n如果没有覆盖重写equals方法，那么Object类中默认进行`==`运算符的对象地址比较，只要不是同一个对象，结果必然为false。\n\n### 对象内容比较\n\n如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：\n\n```java\nimport java.util.Objects;\n\npublic class Person {\t\n\tprivate String name;\n\tprivate int age;\n\t\n    @Override\n    public boolean equals(Object o) {\n        // 如果对象地址一样，则认为相同\n        if (this == o)\n            return true;\n        // 如果参数为空，或者类型信息不一样，则认为不同\n        if (o == null || getClass() != o.getClass())\n            return false;\n        // 转换为当前类型\n        Person person = (Person) o;\n        // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果\n        return age == person.age && Objects.equals(name, person.name);\n    }\n}\n```\n\n这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用`Code`菜单中的`Generate…`选项，也可以使用快捷键`alt+insert`，并选择`equals() and hashCode()`进行自动代码生成。如下图所示：\n\n\n\n## 1.4 Objects类\n\n在刚才IDEA自动重写equals代码中，使用到了`java.util.Objects`类，那么这个类是什么呢？\n\n在**JDK7**添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。\n\n在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：\n\n- `public static boolean equals(Object a, Object b)`:判断两个对象是否相等。\n\n我们可以查看一下源码，学习一下：\n\n```java\npublic static boolean equals(Object a, Object b) {  \n    return (a == b) || (a != null && a.equals(b));  \n}\n```\n\n# 日期时间类\n\n## 2.1 Date类\n\n### 概述\n\n` java.util.Date`类 表示特定的瞬间，精确到毫秒。\n\n继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。\n\n- `public Date()`：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。\n- `public Date(long date)`：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。\n\n> tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。\n\n简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：\n\n```java\nimport java.util.Date;\n\npublic class Demo01Date {\n    public static void main(String[] args) {\n        // 创建日期对象，把当前的时间\n        System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018\n        // 创建日期对象，把当前的毫秒值转成日期对象\n        System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970\n    }\n}\n```\n\n> tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。\n\n### 常用方法\n\nDate类中的多数方法已经过时，常用的方法有：\n\n- `public long getTime()` 把日期对象转换成对应的时间毫秒值。\n\n## 2.2 DateFormat类\n\n`java.text.DateFormat` 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。\n\n- **格式化**：按照指定的格式，从Date对象转换为String对象。\n- **解析**：按照指定的格式，从String对象转换为Date对象。\n\n### 构造方法\n\n由于DateFormat为抽象类，不能直接使用，所以需要常用的子类`java.text.SimpleDateFormat`。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：\n\n- `public SimpleDateFormat(String pattern)`：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。\n\n参数pattern是一个字符串，代表日期时间的自定义格式。\n\n### 格式规则\n\n常用的格式规则为：\n\n| 标识字母（区分大小写） | 含义 |\n| ---------------------- | ---- |\n| y                      | 年   |\n| M                      | 月   |\n| d                      | 日   |\n| H                      | 时   |\n| m                      | 分   |\n| s                      | 秒   |\n\n> 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。\n\n创建SimpleDateFormat对象的代码如：\n\n```java\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\n\npublic class Demo02SimpleDateFormat {\n    public static void main(String[] args) {\n        // 对应的日期格式如：2018-01-16 15:06:38\n        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    }    \n}\n```\n\n### 常用方法\n\nDateFormat类的常用方法有：\n\n- `public String format(Date date)`：将Date对象格式化为字符串。\n- `public Date parse(String source)`：将字符串解析为Date对象。\n\n#### format方法\n\n使用format方法的代码为：\n\n```java\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n/*\n 把Date对象转换成String\n*/\npublic class Demo03DateFormatMethod {\n    public static void main(String[] args) {\n        Date date = new Date();\n        // 创建日期格式化对象,在获取格式化对象时可以指定风格\n        DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\");\n        String str = df.format(date);\n        System.out.println(str); // 2008年1月23日\n    }\n}\n```\n\n#### parse方法\n\n使用parse方法的代码为：\n\n```java\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n/*\n 把String转换成Date对象\n*/\npublic class Demo04DateFormatMethod {\n    public static void main(String[] args) throws ParseException {\n        DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\");\n        String str = \"2018年12月11日\";\n        Date date = df.parse(str);\n        System.out.println(date); // Tue Dec 11 00:00:00 CST 2018\n    }\n}\n```\n\n\n\n## 2.4 Calendar类\n\n### 概念\n\n日历我们都见过\n\n`java.util.Calendar`是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。\n\n### 获取方式\n\nCalendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：\n\nCalendar静态方法\n\n- `public static Calendar getInstance()`：使用默认时区和语言环境获得一个日历\n\n例如：\n\n```java\nimport java.util.Calendar;\n\npublic class Demo06CalendarInit {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n    }    \n}\n```\n\n### 常用方法\n\n根据Calendar类的API文档，常用方法有：\n\n- `public int get(int field)`：返回给定日历字段的值。\n- `public void set(int field, int value)`：将给定的日历字段设置为给定值。\n- `public abstract void add(int field, int amount)`：根据日历的规则，为给定的日历字段添加或减去指定的时间量。\n- `public Date getTime()`：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。\n\nCalendar类中提供很多成员常量，代表给定的日历字段：\n\n| 字段值       | 含义                                  |\n| ------------ | ------------------------------------- |\n| YEAR         | 年                                    |\n| MONTH        | 月（从0开始，可以+1使用）             |\n| DAY_OF_MONTH | 月中的天（几号）                      |\n| HOUR         | 时（12小时制）                        |\n| HOUR_OF_DAY  | 时（24小时制）                        |\n| MINUTE       | 分                                    |\n| SECOND       | 秒                                    |\n| DAY_OF_WEEK  | 周中的天（周几，周日为1，可以-1使用） |\n\n#### get/set方法\n\nget方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：\n\n```java\nimport java.util.Calendar;\n\npublic class CalendarUtil {\n    public static void main(String[] args) {\n        // 创建Calendar对象\n        Calendar cal = Calendar.getInstance();\n        // 设置年 \n        int year = cal.get(Calendar.YEAR);\n        // 设置月\n        int month = cal.get(Calendar.MONTH) + 1;\n        // 设置日\n        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\");\n    }    \n}\n```\n\n```java\nimport java.util.Calendar;\n\npublic class Demo07CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.YEAR, 2020);\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日\n    }\n}\n```\n\n#### add方法\n\nadd方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：\n\n```java\nimport java.util.Calendar;\n\npublic class Demo08CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日\n        // 使用add方法\n        cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天\n        cal.add(Calendar.YEAR, -3); // 减3年\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; \n    }\n}\n```\n\n#### getTime方法\n\nCalendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。\n\n```java\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class Demo09CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        Date date = cal.getTime();\n        System.out.println(date); // Tue Jan 16 16:03:09 CST 2018\n    }\n}\n```\n\n> 小贴士：\n>\n> ​     西方星期的开始为周日，中国为周一。\n>\n> ​     在Calendar类中，月份的表示是以0-11代表1-12月。\n>\n> ​     日期是有大小关系的，时间靠后，时间越大。\n\n#  System类\n\n`java.lang.System`类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：\n\n- `public static long currentTimeMillis()`：返回以毫秒为单位的当前时间。\n- `public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`：将数组中指定的数据拷贝到另一个数组中。\n\n## 3.1 currentTimeMillis方法\n\n实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值\n\n```java\nimport java.util.Date;\n\npublic class SystemDemo {\n    public static void main(String[] args) {\n       \t//获取当前时间毫秒值\n        System.out.println(System.currentTimeMillis()); // 1516090531144\n    }\n}\n```\n\n### 练习\n\n验证for循环打印数字1-9999所需要使用的时间（毫秒）\n\n```java\npublic class SystemTest1 {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 10000; i++) {\n            System.out.println(i);\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"共耗时毫秒：\" + (end - start));\n    }\n}\n```\n\n## 3.2 arraycopy方法\n\n- `public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`：将数组中指定的数据拷贝到另一个数组中。\n\n数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：\n\n| 参数序号 | 参数名称 | 参数类型 | 参数含义             |\n| -------- | -------- | -------- | -------------------- |\n| 1        | src      | Object   | 源数组               |\n| 2        | srcPos   | int      | 源数组索引起始位置   |\n| 3        | dest     | Object   | 目标数组             |\n| 4        | destPos  | int      | 目标数组索引起始位置 |\n| 5        | length   | int      | 复制元素个数         |\n\n### 练习\n\n将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]\n\n```java\nimport java.util.Arrays;\n\npublic class Demo11SystemArrayCopy {\n    public static void main(String[] args) {\n        int[] src = new int[]{1,2,3,4,5};\n        int[] dest = new int[]{6,7,8,9,10};\n        System.arraycopy( src, 0, dest, 0, 3);\n        /*代码运行后：两个数组中的元素发生了变化\n         src数组元素[1,2,3,4,5]\n         dest数组元素[1,2,3,9,10]\n        */\n    }\n}\n```\n\n# StringBuilder类\n\n## 4.1 字符串拼接问题\n\n由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：\n\n```java\npublic class StringDemo {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        s += \"World\";\n        System.out.println(s);\n    }\n}\n```\n\n在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。\n\n根据这句话分析我们的代码，其实总共产生了三个字符串，即`\"Hello\"`、`\"World\"`和`\"HelloWorld\"`。引用变量s首先指向`Hello`对象，最终指向拼接出来的新字符串对象，即`HelloWord` 。\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/03.%E5%B8%B8%E7%94%A8API%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/12.%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91/12.%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/img/String%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98.bmp)\n\n由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用`java.lang.StringBuilder`类。\n\n## 4.2 StringBuilder概述\n\n查阅`java.lang.StringBuilder`的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。\n\n原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。\n\n它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)\n\n![06-StringBuilder的原理](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/03.%E5%B8%B8%E7%94%A8API%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/12.%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91/12.%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/img/06-StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.png)\n\n## 4.3 构造方法\n\n根据StringBuilder的API文档，常用构造方法有2个：\n\n- `public StringBuilder()`：构造一个空的StringBuilder容器。\n- `public StringBuilder(String str)`：构造一个StringBuilder容器，并将字符串添加进去。\n\n```java\npublic class StringBuilderDemo {\n    public static void main(String[] args) {\n        StringBuilder sb1 = new StringBuilder();\n        System.out.println(sb1); // (空白)\n        // 使用带参构造\n        StringBuilder sb2 = new StringBuilder(\"itcast\");\n        System.out.println(sb2); // itcast\n    }\n}\n```\n\n## 4.4 常用方法\n\nStringBuilder常用的方法有2个：\n\n- `public StringBuilder append(...)`：添加任意类型数据的字符串形式，并返回当前对象自身。\n- `public String toString()`：将当前StringBuilder对象转换为String对象。\n\n### append方法\n\nappend方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：\n\n```java\npublic class Demo02StringBuilder {\n\tpublic static void main(String[] args) {\n\t\t//创建对象\n\t\tStringBuilder builder = new StringBuilder();\n\t\t//public StringBuilder append(任意类型)\n\t\tStringBuilder builder2 = builder.append(\"hello\");\n\t\t//对比一下\n\t\tSystem.out.println(\"builder:\"+builder);\n\t\tSystem.out.println(\"builder2:\"+builder2);\n\t\tSystem.out.println(builder == builder2); //true\n\t    // 可以添加 任何类型\n\t\tbuilder.append(\"hello\");\n\t\tbuilder.append(\"world\");\n\t\tbuilder.append(true);\n\t\tbuilder.append(100);\n\t\t// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。\n        // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下\n\t\t//链式编程\n\t\tbuilder.append(\"hello\").append(\"world\").append(true).append(100);\n\t\tSystem.out.println(\"builder:\"+builder);\n\t}\n}\n```\n\n> 备注：StringBuilder已经覆盖重写了Object当中的toString方法。\n\n### toString方法\n\n通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：\n\n```java\npublic class Demo16StringBuilder {\n    public static void main(String[] args) {\n        // 链式创建\n        StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\");\n        // 调用方法\n        String str = sb.toString();\n        System.out.println(str); // HelloWorldJava\n    }\n}\n```\n\n# 包装类\n\n## 5.1 概述\n\nJava提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：\n\n| 基本类型 | 对应的包装类（位于java.lang包中） |\n| -------- | --------------------------------- |\n| byte     | Byte                              |\n| short    | Short                             |\n| int      | **Integer**                       |\n| long     | Long                              |\n| float    | Float                             |\n| double   | Double                            |\n| char     | **Character**                     |\n| boolean  | Boolean                           |\n\n## 5.2 装箱与拆箱\n\n基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：\n\n- **装箱**：从基本类型转换为对应的包装类对象。\n- **拆箱**：从包装类对象转换为对应的基本类型。\n\n用Integer与 int为例：（看懂代码即可）\n\n基本数值---->包装对象\n\n```java\nInteger i = new Integer(4);//使用构造函数函数\nInteger iii = Integer.valueOf(4);//使用包装类中的valueOf方法\n```\n\n包装对象---->基本数值\n\n```java\nint num = i.intValue();\n```\n\n## 5.3自动装箱与自动拆箱\n\n由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：\n\n```java\nInteger i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);\ni = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;\n//加法运算完成后，再次装箱，把基本数值转成对象。\n```\n\n## 5.3 基本类型与字符串之间的转换\n\n### 基本类型转换为String\n\n   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： \n\n```\n基本类型直接与””相连接即可；如：34+\"\"\n```\n\nString转换成对应的基本类型 \n\n除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：\n\n- `public static byte parseByte(String s)`：将字符串参数转换为对应的byte基本类型。\n- `public static short parseShort(String s)`：将字符串参数转换为对应的short基本类型。\n- `public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。\n- `public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。\n- `public static float parseFloat(String s)`：将字符串参数转换为对应的float基本类型。\n- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。\n- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的boolean基本类型。\n\n代码使用（仅以Integer类的静态方法parseXxx为例）如：\n\n```java\npublic class Demo18WrapperParse {\n    public static void main(String[] args) {\n        int num = Integer.parseInt(\"100\");\n    }\n}\n```\n\n> 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。\n\n","tags":["java"]},{"title":"Spring Bootd单/多文件上传","url":"/2019/05/06/Spring-Boot单文件上传/","content":"\nSpring Bootd单/多文件上传\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 单/多文件上传\n\nupload.html：\n\n```html\n<!DOCTYPE HTML>\n<html>\n<head>\n    <title>文件上传</title>\n</head>\n\n<body>\n<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">\n    上传文件1：<input type=\"file\" name=\"file\"><br/>\n    <input type=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n\n\nUploadController:\n\n```java\npackage com.example.demo.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.multipart.MultipartFile;\nimport org.springframework.web.multipart.MultipartHttpServletRequest;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\n\n@Controller\npublic class UploadController {\n    @GetMapping(\"/upload\")\n    public String upload() {\n        return \"upload\";\n    }\n\n    @GetMapping(\"/multiUpload\")\n    public String multiUpload() {\n        return \"multiUpload\";\n    }\n\n\n    @PostMapping(\"/multiUpload\")\n    @ResponseBody\n    public String multiUpload(HttpServletRequest request) {\n        List<MultipartFile> files = ((MultipartHttpServletRequest) request).getFiles(\"file\");\n        String filePath = \"D:/path/\";\n        for (int i = 0; i < files.size(); i++) {\n            MultipartFile file = files.get(i);\n            if (file.isEmpty()) {\n                return \"上传第\" + (i++) + \"个文件失败\";\n            }\n            String fileName = file.getOriginalFilename();\n\n            File dest = new File(filePath + fileName);\n            try {\n                file.transferTo(dest);\n            } catch (IOException e) {\n                return \"上传第\" + (i++) + \"个文件失败\";\n            }\n        }\n\n        return \"上传成功\";\n\n    }\n\n\n    @PostMapping(\"/upload\")\n    @ResponseBody\n    public String upload(@RequestParam(\"file\") MultipartFile file) {\n        if (file.isEmpty()) {\n            return \"上传失败，请选择文件\";\n        }\n\n        String fileName = file.getOriginalFilename();\n        String filePath = \"D:/path/\";\n        File dest = new File(filePath + fileName);\n        try {\n            file.transferTo(dest);\n            return \"上传成功\";\n        } catch (IOException e) {\n        }\n        return \"上传失败！\";\n    }\n}\n\n\n```\n\n\n\nmultiUpload.html\n\n```html\n<!DOCTYPE HTML>\n<html>\n<head>\n    <title>文件上传</title>\n</head>\n\n<body>\n<form action=\"/multiUpload\" enctype=\"multipart/form-data\" method=\"post\">\n    上传文件：<input type=\"file\" name=\"file\"><br/>\n    上传文件：<input type=\"file\" name=\"file\"><br/>\n    上传文件：<input type=\"file\" name=\"file\"><br/>\n    上传文件：<input type=\"file\" name=\"file\"><br/>\n    <input type=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n\n\n\n\n\n\n## 设置上传文件大小的两种方式\n\n### springboot 1.5.X系列处理方式\n\n#### 创建tomcat配置类\n\n```java\n @Bean  \n    public MultipartConfigElement multipartConfigElement() {  \n        MultipartConfigFactory factory = new MultipartConfigFactory();  \n        //文件最大  \n        factory.setMaxFileSize(\"10240KB\"); //KB,MB  \n        /// 设置总上传数据总大小  \n        factory.setMaxRequestSize(\"102400KB\");  \n        return factory.createMultipartConfig();  \n    }  \n```\n\n**注意**\nspring.http.multipart.maxFileSize=10Mb\nspring.http.multipart.maxRequestSize=10Mb\n已经过期 >>>>\n\n#### **在application.properties中添加如下配置信息**\n\napplication.properties\n\n```xml\n spring.servlet.multipart.max-file-size=20MB\n spring.servlet.multipart.max-request-size=20MB\n```\n\nmaxFileSize 是单个文件大小\nmaxRequestSize是设置总上传的数据大小\n\n\n\n### Springboot 2.X系列配置\n\n#### 创建tomcat配置类\n\n```java\n\n@Configuration\npublic class TomcatConfig {\n\n\n    @Bean\n    public MultipartConfigElement multipartConfigElement() {\n        MultipartConfigFactory factory = new MultipartConfigFactory();\n        //文件最大10M,DataUnit提供5中类型B,KB,MB,GB,TB\n        factory.setMaxFileSize(DataSize.of(100, DataUnit.MEGABYTES));\n        /// 设置总上传数据总大小10M\n        factory.setMaxRequestSize(DataSize.of(100, DataUnit.MEGABYTES));\n        return factory.createMultipartConfig();\n    }\n}\n```\n\n#### 配置文件配置\n\napplication.properties\n\n```xml\n   spring.servlet.multipart.max-file-size=20MB\n   spring.servlet.multipart.max-request-size=20MB\n```\n\n\n\n","tags":["Sprint Boot"]},{"title":"JAVAWEB文件上传","url":"/2019/05/06/form表单文件上传/","content":"\n对于文件上传，浏览器在上传的过程中是将文件以流的形式提交到服务器端的，如果直接使用Servlet获取上传文件的输入流然后再解析里面的请求参数是比较麻烦，所以一般选择采用apache的开源工具common-fileupload这个文件上传组件。这个common-fileupload上传组件的jar包可以去apache官网上面下载，也可以在struts的lib文件夹下面找到，struts上传的功能就是基于这个实现的。common-fileupload是依赖于common-io这个包的，所以还需要下载这个包。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\nUploadHandleServlet的代码如下：\n\n```java\npackage me.gacl.web.controller;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.UUID;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadBase;\nimport org.apache.commons.fileupload.ProgressListener;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n* @ClassName: UploadHandleServlet\n*\n*/ \npublic class UploadHandleServlet extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n                //得到上传文件的保存目录，将上传的文件存放于WEB-INF目录下，不允许外界直接访问，保证上传文件的安全\n                String savePath = this.getServletContext().getRealPath(\"/WEB-INF/upload\");\n                //上传时生成的临时文件保存目录\n                String tempPath = this.getServletContext().getRealPath(\"/WEB-INF/temp\");\n                File tmpFile = new File(tempPath);\n                if (!tmpFile.exists()) {\n                    //创建临时目录\n                    tmpFile.mkdir();\n                }\n                \n                //消息提示\n                String message = \"\";\n                try{\n                    //使用Apache文件上传组件处理文件上传步骤：\n                    //1、创建一个DiskFileItemFactory工厂\n                    DiskFileItemFactory factory = new DiskFileItemFactory();\n                    //设置工厂的缓冲区的大小，当上传的文件大小超过缓冲区的大小时，就会生成一个临时文件存放到指定的临时目录当中。\n                    factory.setSizeThreshold(1024*100);//设置缓冲区的大小为100KB，如果不指定，那么缓冲区的大小默认是10KB\n                    //设置上传时生成的临时文件的保存目录\n                    factory.setRepository(tmpFile);\n                    //2、创建一个文件上传解析器\n                    ServletFileUpload upload = new ServletFileUpload(factory);\n                    //监听文件上传进度\n                    upload.setProgressListener(new ProgressListener(){\n                        public void update(long pBytesRead, long pContentLength, int arg2) {\n                            System.out.println(\"文件大小为：\" + pContentLength + \",当前已处理：\" + pBytesRead);\n                            /**\n                             * 文件大小为：14608,当前已处理：4096\n                                文件大小为：14608,当前已处理：7367\n                                文件大小为：14608,当前已处理：11419\n                                文件大小为：14608,当前已处理：14608\n                             */\n                        }\n                    });\n                     //解决上传文件名的中文乱码\n                    upload.setHeaderEncoding(\"UTF-8\"); \n                    //3、判断提交上来的数据是否是上传表单的数据\n                    if(!ServletFileUpload.isMultipartContent(request)){\n                        //按照传统方式获取数据\n                        return;\n                    }\n                    \n                    //设置上传单个文件的大小的最大值，目前是设置为1024*1024字节，也就是1MB\n                    upload.setFileSizeMax(1024*1024);\n                    //设置上传文件总量的最大值，最大值=同时上传的多个文件的大小的最大值的和，目前设置为10MB\n                    upload.setSizeMax(1024*1024*10);\n                    //4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List<FileItem>集合，每一个FileItem对应一个Form表单的输入项\n                    List<FileItem> list = upload.parseRequest(request);\n                    for(FileItem item : list){\n                        //如果fileitem中封装的是普通输入项的数据\n                        if(item.isFormField()){\n                            String name = item.getFieldName();\n                            //解决普通输入项的数据的中文乱码问题\n                            String value = item.getString(\"UTF-8\");\n                            //value = new String(value.getBytes(\"iso8859-1\"),\"UTF-8\");\n                            System.out.println(name + \"=\" + value);\n                        }else{//如果fileitem中封装的是上传文件\n                            //得到上传的文件名称，\n                            String filename = item.getName();\n                            System.out.println(filename);\n                            if(filename==null || filename.trim().equals(\"\")){\n                                continue;\n                            }\n                            //注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如：  c:\\a\\b\\1.txt，而有些只是单纯的文件名，如：1.txt\n                            //处理获取到的上传文件的文件名的路径部分，只保留文件名部分\n                            filename = filename.substring(filename.lastIndexOf(\"\\\\\")+1);\n                            //得到上传文件的扩展名\n                            String fileExtName = filename.substring(filename.lastIndexOf(\".\")+1);\n                            //如果需要限制上传的文件类型，那么可以通过文件的扩展名来判断上传的文件类型是否合法\n                            System.out.println(\"上传的文件的扩展名是：\"+fileExtName);\n                            //获取item中的上传文件的输入流\n                            InputStream in = item.getInputStream();\n                            //得到文件保存的名称\n                            String saveFilename = makeFileName(filename);\n                            //得到文件的保存目录\n                            String realSavePath = makePath(saveFilename, savePath);\n                            //创建一个文件输出流\n                            FileOutputStream out = new FileOutputStream(realSavePath + \"\\\\\" + saveFilename);\n                            //创建一个缓冲区\n                            byte buffer[] = new byte[1024];\n                            //判断输入流中的数据是否已经读完的标识\n                            int len = 0;\n                            //循环将输入流读入到缓冲区当中，(len=in.read(buffer))>0就表示in里面还有数据\n                            while((len=in.read(buffer))>0){\n                                //使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath + \"\\\\\" + filename)当中\n                                out.write(buffer, 0, len);\n                            }\n                            //关闭输入流\n                            in.close();\n                            //关闭输出流\n                            out.close();\n                            //删除处理文件上传时生成的临时文件\n                            //item.delete();\n                            message = \"文件上传成功！\";\n                        }\n                    }\n                }catch (FileUploadBase.FileSizeLimitExceededException e) {\n                    e.printStackTrace();\n                    request.setAttribute(\"message\", \"单个文件超出最大值！！！\");\n                    request.getRequestDispatcher(\"/message.jsp\").forward(request, response);\n                    return;\n                }catch (FileUploadBase.SizeLimitExceededException e) {\n                    e.printStackTrace();\n                    request.setAttribute(\"message\", \"上传文件的总的大小超出限制的最大值！！！\");\n                    request.getRequestDispatcher(\"/message.jsp\").forward(request, response);\n                    return;\n                }catch (Exception e) {\n                    message= \"文件上传失败！\";\n                    e.printStackTrace();\n                }\n                request.setAttribute(\"message\",message);\n                request.getRequestDispatcher(\"/message.jsp\").forward(request, response);\n    }\n    \n    /**\n    * @Method: makeFileName\n    */ \n    private String makeFileName(String filename){  //2.jpg\n        //为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名\n        return UUID.randomUUID().toString() + \"_\" + filename;\n    }\n    \n    /**\n     * 为防止一个目录下面出现太多文件，要使用hash算法打散存储\n    */ \n    private String makePath(String filename,String savePath){\n        //得到文件名的hashCode的值，得到的就是filename这个字符串对象在内存中的地址\n        int hashcode = filename.hashCode();\n        int dir1 = hashcode&0xf;  //0--15\n        int dir2 = (hashcode&0xf0)>>4;  //0-15\n        //构造新的保存目录\n        String dir = savePath + \"\\\\\" + dir1 + \"\\\\\" + dir2;  //upload\\2\\3  upload\\3\\5\n        //File既可以代表文件也可以代表目录\n        File file = new File(dir);\n        //如果目录不存在\n        if(!file.exists()){\n            //创建目录\n            file.mkdirs();\n        }\n        return dir;\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        doGet(request, response);\n    }\n}\n```\n\n\n\nupload.jsp页面的代码如下：\n\n```html\n<%@ page language=\"java\" pageEncoding=\"UTF-8\"%>\n<!DOCTYPE HTML>\n<html>\n  <head>\n    <title>文件上传</title>\n  </head>\n  \n  <body>\n    <form action=\"${pageContext.request.contextPath}/servlet/UploadHandleServlet\" enctype=\"multipart/form-data\" method=\"post\">\n        上传用户：<input type=\"text\" name=\"username\"><br/>\n        上传文件1：<input type=\"file\" name=\"file1\"><br/>\n        上传文件2：<input type=\"file\" name=\"file2\"><br/>\n        <input type=\"submit\" value=\"提交\">\n    </form>\n  </body>\n</html>\n```\n\n\n\n","tags":["JAVA"]},{"title":"C++自学笔记(一)","url":"/2019/04/21/C-自学笔记-一/","content":"\nC++查漏补缺\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## C++ 类 & 对象\n\n### C++类定义\n\n类定义是以关键字 **class** 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 **class** 定义 Box 数据类型，如下所示：\n\n```c++\nclass Box\n{\n\tpublic:\n\t\tdouble length;\n\t\tdouble breadth;\n\t\tdouble height;\n};\n\n```\n\n\n\n### 定义C++对象\n\n```c++\nBox Box1;          // 声明 Box1，类型为 Box\nBox Box2;          // 声明 Box2，类型为 Box\n```\n\n\n\n### 数据成员的访问\n\n类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。\n\n```c++\n   Box1.height = 5.0; \n   Box1.length = 6.0; \n   Box1.breadth = 7.0;\n```\n\n\n\n### 类成员函数\n\n```c++\n#include<iostream>\nusing namespace std;\nclass Box\n{\n\tpublic:\n\t\tdouble length;\n\t\tdouble breadth;\n\t\tdouble height;\n\t\tdouble getVolume();\n};\nint main() {\n\tBox box;\n\tbox.height = 3;\n\tbox.breadth = 5;\n\tbox.length = 2;\n\tcout << box.getVolume() << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\ndouble Box::getVolume() {\n\treturn length * breadth * height;\n\n}\n```\n\n上述例子在Box类中定义了getVolume函数,并且在类外对其声明\n\n### C++ 类访问修饰符\n\n数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 **public、private、protected** 来指定的。关键字 **public、private、protected** 称为访问修饰符。\n\n一个类可以有多个 public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的默认访问修饰符是 private。\n\n+ **公有**成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值.\n+ **私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。\n+ **保护**成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。\n\n有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。\n\n- 1.**public 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private\n- 2.**protected 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private\n- 3.**private 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private\n\n但无论哪种继承方式，上面两点都没有改变：\n\n- 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；\n- 2.protected 成员可以被派生类访问。\n\n### C++构造函数\n\n类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。\n\n构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。\n\n### 使用初始化列表来初始化字段\n\n使用初始化列表来初始化字段：\n\n```c++\nLine::Line( double len): length(len) {     cout << \"Object is being created, length = \" << len << endl; }\n```\n\n\n\n上面的语法等同于如下语法：\n\n```c++\nLine::Line( double len) {     length = len;     cout << \"Object is being created, length = \" << len << endl; }\n```\n\n\n\n假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：\n\n```c++\nC::C( double a, double b, double c): X(a), Y(b), Z(c) {   .... }\n```\n\n\n\n### C++拷贝构造函数\n\n**拷贝构造函数**是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：\n\n- 通过使用另一个同类型的对象来初始化新创建的对象。\n- 复制对象把它作为参数传递给函数。\n- 复制对象，并从函数返回这个对象。","tags":["C++"]},{"title":"C语言自学小笔记(三)","url":"/2019/04/20/C语言自学小笔记-三/","content":"\nC语言查缺补漏小笔记\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## C的文件读写\n\n### 打开文件\n\n```c\nFILE *fopen( const char * filename, const char * mode );\n```\n\nmode可以是下列值中的一个\n\n| 模式 | 描述                                                         |\n| :--- | :----------------------------------------------------------- |\n| r    | 打开一个已有的文本文件，允许读取文件。                       |\n| w    | 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。 |\n| a    | 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。 |\n| r+   | 打开一个文本文件，允许读写文件。                             |\n| w+   | 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 |\n| a+   | 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 |\n\n\n\n### 关闭文件\n\n```c\nint fclose( FILE *fp );\n```\n\n如果成功关闭文件，**fclose( )** 函数返回零，如果关闭文件时发生错误，函数返回 **EOF**。\n\n\n\n### 写入文件\n\n写入一个字符:\n\n```c\nint fputc( int c, FILE *fp );\n```\n\n \n\n写入一个字符串:\n\n```c\nint fputs( const char *s, FILE *fp );\n```\n\n\n\n写入字符串的另一种方式:\n\n```c\n int fprintf(FILE *fp,const char *format, ...)\n```\n\n\n\n### 读取文件\n\n```c\nint fgetc( FILE * fp );\n```\n\n**fgetc()** 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 **EOF**\n\n```c\nchar *fgets( char *buf, int n, FILE *fp );\n```\n\n函数 **fgets()** 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 **buf**，并在最后追加一个 **null** 字符来终止字符串。函数在读取最后一个字符之前就遇到一个换行符 '\\n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。\n\n```c\nint fscanf(FILE *fp, const char *format, ...) \n```\n\n函数来从文件中读取字符串，但是在遇到第一个空格字符时，它会停止读取\n\n\n\n## C预处理器\n\n### 预处理指令\n\n| 指令     | 描述                                                        |\n| :------- | :---------------------------------------------------------- |\n| #define  | 定义宏                                                      |\n| #include | 包含一个源代码文件                                          |\n| #undef   | 取消已定义的宏                                              |\n| #ifdef   | 如果宏已经定义，则返回真                                    |\n| #ifndef  | 如果宏没有定义，则返回真                                    |\n| #if      | 如果给定条件为真，则编译下面代码                            |\n| #else    | #if 的替代方案                                              |\n| #elif    | 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 |\n| #endif   | 结束一个 #if……#else 条件编译块                              |\n| #error   | 当遇到标准错误时，输出错误消息                              |\n| #pragma  | 使用标准化方法，向编译器发布特殊的命令到编译器中            |\n\n\n\n### 预处理宏\n\n| 宏       | 描述                                                |\n| :------- | :-------------------------------------------------- |\n| __DATE__ | 当前日期，一个以 \"MMM DD YYYY\" 格式表示的字符常量。 |\n| __TIME__ | 当前时间，一个以 \"HH:MM:SS\" 格式表示的字符常量。    |\n| __FILE__ | 这会包含当前文件名，一个字符串常量。                |\n| __LINE__ | 这会包含当前行号，一个十进制常量。                  |\n| __STDC__ | 当编译器以 ANSI 标准编译时，则定义为 1。            |\n\n\n\n## C头文件\n\n### 引用头文件的语法\n\n使用预处理指令 **#include** 可以引用用户和系统头文件。它的形式有以下两种：\n\n```c\n#include <file>\n```\n\n这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。\n\n```c\n#include \"file\"\n```\n\n这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。\n\n\n\n## C 可变参数\n\n```c\n#include <stdio.h>\n#include <stdarg.h>\n \ndouble average(int num,...)\n{\n \n    va_list valist;\n    double sum = 0.0;\n    int i;\n \n    /* 为 num 个参数初始化 valist */\n    va_start(valist, num);\n \n    /* 访问所有赋给 valist 的参数 */\n    for (i = 0; i < num; i++)\n    {\n       sum += va_arg(valist, int);\n    }\n    /* 清理为 valist 保留的内存 */\n    va_end(valist);\n \n    return sum/num;\n}\n \nint main()\n{\n   printf(\"Average of 2, 3, 4, 5 = %f\\n\", average(4, 2,3,4,5));\n   printf(\"Average of 5, 10, 15 = %f\\n\", average(3, 5,10,15));\n}\n```\n\n为了使用这个功能，需要使用 **stdarg.h** 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：\n\n- 定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。\n- 在函数定义中创建一个 **va_list** 类型变量，该类型是在 stdarg.h 头文件中定义的。\n- 使用 **int** 参数和 **va_start** 宏来初始化 **va_list** 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。\n- 使用 **va_arg** 宏和 **va_list** 变量来访问参数列表中的每个项。\n- 使用宏 **va_end** 来清理赋予 **va_list** 变量的内存。\n\n\n\n## C内存管理\n\nC 语言为内存的分配和管理提供了几个函数。这些函数可以在 **<stdlib.h>** 头文件中找到。\n\n| 序号 | 函数和描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | **void \\*calloc(int num, int size);** 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。 |\n| 2    | **void free(void \\*address);**  该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。 |\n| 3    | **void \\*malloc(int num);**  在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。 |\n| 4    | **void \\*realloc(void \\*address, int newsize);**  该函数重新分配内存，把内存扩展到 **newsize**。 |\n\nvoid * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["C"]},{"title":"vue学习笔记(三)","url":"/2019/04/20/vue学习笔记-三/","content":"\n## 列表渲染\n\n","tags":["vue.js"]},{"title":"vue学习笔记(二)","url":"/2019/04/19/vue学习笔记-二/","content":"\nVue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与[现代化的工具链](https://cn.vuejs.org/v2/guide/single-file-components.html)以及各种[支持类库](https://github.com/vuejs/awesome-vue#libraries--plugins)结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## Class与Style绑定\n\n### 绑定HTML Class\n\n#### 对象语法\n\n可以传给v-bind:class一个对象,动态的切换class:\n\n```html\n<div class=\"static\" id = \"div1\"  v-bind:class=\"{'active': isActive, 'text-danger' : hasError}\">\n\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#div1',\n\t\t\t\tdata:{\n\t\t\t\t\tisActive : true,\n\t\t\t\t\thasError : true\n\t\t\t\t}\n\t\t\t})\n```\n\n当对应的属性的值为true的时候,div的class里就会增加相应的格式,上述例子的class为:\n\n```html\nstatic active text-danger\n```\n\n\n\n绑定的数据对象不必内联定义在模板里：\n\n```html\n<div id=\"div2\" v-bind:class=\"classObject\"></div>\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#div2',\n\t\t\t\tdata:{\n\t\t\t\tclassObject:{\n\t\t\t\t\tavtive:true,\n\t\t\t\t\t'text-danger':true\n\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t})\n```\n\n 也可以使 div   class=\"avtive text-danger\"\n\n我们也可以在这里绑定一个返回对象的计算属性:\n\n```java\n<div id=\"div3\" v-bind:class=\"classObject3\"></div>\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#div3',\n\t\t\t\tdata:{\n\t\t\t\t\tisActive:true,\n\t\t\t\t\terror: null\n\t\t\t\t},\n\t\t\t\tcomputed:{\n\t\t\t\t\tclassObject3:function(){\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tactive:this.isActive&&!this.error,'text-danger':this.error&&this.error.type ==='fatal'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t)\n```\n\n\n\n#### 数组语法:\n\n我们可以把一个数组传给v-bind:class,以应用一个class列表:\n\n```html\n<div id = \"div4\" v-bind:class=\"[activeClass, errorClass]\">div4</div>\n\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#div4',\n\t\t\t\tdata:{\n\t\t\t\t\tactiveClass: 'active',\n\t\t\t\t\terrorClass: 'text-danger'\n\t\t\t\t}\n\t\t\t})\n```\n\n\n\n也可以用三元表达式来按条件切换class\n\n```html\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n```\n\n\n\n#### 用在组件上\n\n当在一个自定义组件上使用 `class` 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。\n\n例如，如果你声明了这个组件：\n\n```\nVue.component('my-component', {\n  template: '<p class=\"foo bar\">Hi</p>'\n})\n```\n\n然后在使用它的时候添加一些 class：\n\n```\n<my-component class=\"baz boo\"></my-component>\n```\n\nHTML 将被渲染为:\n\n```html\n<p class=\"foo bar baz boo\">Hi</p>\n```\n\nhtml对于带数据绑定 class 也同样适用：\n\n```html\n<my-component v-bind:class=\"{ active: isActive }\"></my-component>\n```\n\n当 `isActive` 为 truthy[[1\\]](https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1) 时，HTML 将被渲染成为：\n\n```html\n<p class=\"foo bar active\">Hi</p>\n```\n\n\n\n### 绑定内联样式\n\n#### 对象语法\n\n```html\n\t\t<div id=\"div5\" v-bind:style=\"{color: activeColor, fontSize:fontSize + 'px'}\"> div5</div>\n\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel: '#div5',\n\t\t\t\tdata: {\n\t\t\t\t\tactiveColor: 'red',\n\t\t\t\t\tfontSize: 30\n\t\t\t\t}\n\n\t\t\t})\n\n```\n\n\n\n直接绑定到一个样式对象会让模板更清晰：\n\n```html\n\t\t<div id=\"div6\" v-bind:style=\"styleObject\"> div6</div>\n\n\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel: '#div6',\n\t\t\t\tdata: {\n\t\t\t\t\tstyleObject:{\n\t\t\t\t\t\tcolor: 'red',\n\t\t\t\t\t\tfontSize: '30px'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\n```\n\n\n\n#### 数组语法\n\nv-bind:style的数组语法可以将多个样式对象应用到同一个元素上:\n\n#### 数组语法\n\n`v-bind:style` 的数组语法可以将多个样式对象应用到同一个元素上：\n\n```html\n<div v-bind:style=\"[baseStyles, overridingStyles]\"></div>\n\n```\n\n#### 自动添加前缀\n\n当 `v-bind:style` 使用需要添加浏览器引擎前缀的 CSS 属性时，如 `transform`，Vue.js 会自动侦测并添加相应的前缀。\n\n\n\n## 条件渲染\n\n#### v-if\n\n```html\n\t\t<div id=\"example\">\n\t\t\t<p v-if=\"greeting\">\n\t\t\t\tDirective1\n\t\t\t</p>\n\t\t\t<p v-else=\"greeting\">\n\t\t\t\tDirective2\n\t\t\t</p>\n\t\t</div>\n\n```\n\n\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel: '#example',\n\t\t\t\tdata: {\n\t\t\t\t\tgreeting: true\n\t\t\t\t}\n\t\t\t});\n\n```\n\nv-else必须要和v-if匹配使用，v-else不能单独使用。\n只有v-if的值为false时，v-else模块才会显示出来。\n\n因为 `v-if` 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 `<template>` 元素当做不可见的包裹元素，并在上面使用 `v-if`。最终的渲染结果将不包含 `<template>` 元素。\n\n#### 在template 元素上使用v-if 条件渲染分组\n\n```html\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n\n```\n\n\n\n#### v-else-if\n\n`v-else-if`，顾名思义，充当 `v-if` 的“else-if 块”，可以连续使用：\n\n```html\n<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else-if=\"type === 'C'\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n\n```\n\n\n\n#### 用key管理可复用的元素\n\nVue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：\n\n```html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\">\n</template>\n\n```\n\n\n\n添加一个具有唯一值的 `key` 属性,每次切换时，输入框都将被重新渲染。\n\n```html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\" key=\"username-input\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\" key=\"email-input\">\n</template>\n\n```\n\n#### v-show\n\n`v-show` 只是简单地切换元素的 CSS 属性 `display`。\n\n```html\n<h1 v-show=\"ok\">Hello!</h1>\n\n```\n\n v-if 和v-show区别\n\n`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\n\n\n\n\n\n\n\n\n\n","tags":["vue.js"]},{"title":"vue学习笔记(一)","url":"/2019/04/18/vue学习笔记-一/","content":"\nVue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与[现代化的工具链](https://cn.vuejs.org/v2/guide/single-file-components.html)以及各种[支持类库](https://github.com/vuejs/awesome-vue#libraries--plugins)结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 引入vue\n\n可以通过如下方式引入vue\n\n<!-- 开发环境版本，包含了有帮助的命令行警告 -->\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n\n或者\n\n<!-- 生产环境版本，优化了尺寸和速度 -->\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue\"></script>\n\n或者去\n\n[vue git仓库]: https://github.com/vuejs/vue\n\n下载vue.js文件本地引入\n\n\n\n## vue的使用:\n\n### 创建vue实例:\n\n```js\n\t\tvar vm = new Vue({\n\t\t\tel: '#app',\n\t\t\tdata: {\n\t\t\t\tmessage: 'hello Vue.js'\n\t\t\t}\n\t\t})\n```\n对应的html的id为app的div:\n\n```html\n        <div id=\"app\">\n            <p>{{message}}</p>  \n        </div>\n```\n当运行时,message会被替换为data中的 message的值 'hello Vue.js' ,值得注意的是使用双大括号会把值解析为纯文本,所以即使Vue的定义为:\n\n```javascript\n\tvar vm = new Vue({\n\t\tel: '#app',\n\t\tdata: {\n\t\t\tmessage: '<h1>标题</h1>'\n\t\t}\n\t})\n```\nmessage的值也会被解析为<h1>标题</h1> 文本,而不会被解析为html的格式\n\n### 数据与方法:\n\n当一个 Vue 实例被创建时，它将 `data` 对象中的所有的属性加入到 Vue 的**响应式系统**中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。\n\n\t\t<div id=\"app1\">\n\t\t\t{{data}}\n\t\t</div>\n\n\n```html\n\t<script>\n\t\tvar data = \"1\"\n\t\tvar vm = new Vue({\n\t\t\tel: '#app1',\n\t\t\tdata: data\n\t\t})\n\t</script>\n```\n在上述代码中,我们在js控制台中无论改变data的值或者vm.data的值,两者都会一起改变.值得注意的是只有当实例被创建时 `data` 中存在的属性才是**响应式**的。也就是说如果你添加一个新的属性，比如： vm.b = 'hi'那么对 `b` 的改动将不会触发任何视图的更新。\n\n除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 `$`，以便与用户定义的属性区分开来。例如：\n\n```js\nvar data = { a: 1 }\nvar vm = new Vue({\n  el: '#example',\n  data: data\n})\n\nvm.$data === data // => true\nvm.$el === document.getElementById('example') // => true\n\n// $watch 是一个实例方法\nvm.$watch('a', function (newValue, oldValue) {\n  // 这个回调将在 `vm.a` 改变后调用\n})\n```\n\n### 生命周期钩子:\n\n例如create 可以用来在一个实例被创建之后执行代码,：\n\n```js\nnew Vue({\n  data: {\n    a: 1\n  },\n  created: function () {\n    // `this` 指向 vm 实例\n    console.log('a is: ' + this.a)\n  }\n})\n```\n\n\n\n| 钩子          |                                                              |\n| ------------- | ------------------------------------------------------------ |\n| beforeCreate  | 创建实例之前执行                                             |\n| created       | 实例创建完成后执行                                           |\n| beforeMount   | 将编译完成的HTML挂载到对应虚拟dom时触发的钩子,此时页面并没有内容 |\n| mounted       | 将编译完成的HTML挂载到页面完成后执行的钩子,此时钩子函数中一般会做一些ajax请求获取数据进行数据初始化,mounted在整个实例中只执行一次 |\n| beforeUpdate  | 实时监控数据变化并随之更新DOM                                |\n| updated       | 更新之后的钩子                                               |\n| beforeDestroy | 实例销毁之前执行的钩子                                       |\n| destroyed     | 实例销毁完成执行的钩子                                       |\n\n### 使用JavaScript表达式:\n\n对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。\n\n```js\n{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div v-bind:id=\"'list-' + id\"></div>\n```\n\n这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含**单个表达式**，所以下面的例子都**不会**生效。\n\n```html\n<!-- 这是语句，不是表达式 -->\n{{ var a = 1 }}\n\n<!-- 流控制也不会生效，请使用三元表达式 -->\n{{ if (ok) { return message } }}\n\n```\n\n### 指令:\n\n指令 (Directives) 是带有 `v-` 前缀的特殊特性。指令特性的值预期是**单个 JavaScript 表达式** (`v-for` 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。\n\n```html\n\t\t<div id=\"app2\">\n\t\t\t<span v-bind:title=\"message\">\n\t\t\t\t鼠标悬停几秒钟查看此处动态绑定的提示信息;\n\t\t\t</span>\n\n\t\t</div>\t\t\n\n\t\t<div id=\"app3\">\n\t\t\t<p v-if=\"seen\">现在你看到我了</p>\n\t\t</div>\n\n\t\t<div id=\"app4\">\n\t\t\t<ol>\n\t\t\t\t<li v-for=\"todo in todos\">\n\t\t\t\t\t{{todo.text}}\n\t\t\t\t</li>\n\t\t\t</ol>\n\t\t</div>\n\n\t\t<div id=\"app5\">\n\t\t\t<p>\n\t\t\t\t{{message}}\n\t\t\t</p>\n\t\t\t<button v-on:click=\"reverseMessage\"> 逆转消息</button>\n\t\t</div>\n\n```\n\n\n\n```js\n\t\tvar app2 = new Vue({\n\t\t\tel: '#app2',\n\t\t\tdata: {\n\t\t\t\tmessage: '页面加载于' + new Date().toLocaleDateString()\n\t\t\t}\n\t\t})\t\n        \n\t\tvar app3 = new Vue({\n\t\t\tel: '#app3',\n\t\t\tdata: {\n\t\t\t\tseen: true\n\t\t\t}\n\t\t})\n\n\n\t\tvar app4 = new Vue({\n\t\t\tel: '#app4',\n\t\t\tdata: {\n\t\t\t\ttodos: [{\n\t\t\t\t\t\ttext: '学习javascript'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttext: '学习vue'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttext: '整个牛项目'\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t})\n\n\n\t\tvar app5 = new Vue({\n\t\t\tel: '#app5',\n\t\t\tdata: {\n\t\t\t\tmessage: 'Hello Vue.js'\n\t\t\t},\n\t\t\tmethods: {\n\t\t\t\treverseMessage: function() {\n\t\t\t\t\tthis.message = this.message.split('').reverse().join('')\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n```\n\n\n\n在app2,app3,app4.app5中分别实现了绑定鼠标事件,if判断,for循环,函数功能\n\n### 动态参数:\n\n```html\n\t\t<a id = \"a1\" v-bind:[url]=\"url\"> ... </a>\t<br>\n\t\t<a id = \"a2\" v-on:[name]=\"doSomething\"> ... </a>\n\n```\n\n\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#a1',\n\t\t\t\tdata:{\n\t\t\t\t\turl:'href'\n\t\t\t\t}\n\t\t\t})\t\t\t\t\n\n\t\t\tnew Vue({\n\t\t\t\tel:'#a2',\n\t\t\t\tdata:{\n\t\t\t\t\tname:'dblclick'\n\t\t\t\t},\n\t\t\t\tmethods:{\n\t\t\t\t\tdoSomething : function (){\n\t\t\t\t\t\talert(\"函数执行\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t\n\t\t\t\n```\n\n从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：\n\na1 中 v-bind:[url] ,中括号内的url会被替换为Vue中定义的url值:href\n\na2中v-on:[name],中括号内的name会被替换为Vue中定义的name值:dblclick\n\n","tags":["vue.js"]},{"title":"C语言自学小笔记(二)","url":"/2019/04/17/C语言自学小笔记-二/","content":"\nC语言查缺补漏小笔记\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 枚举类型:\n\n例如当我们想用常量表达周一至周日时,可能需要#define七个\n\n```c\n#define MON  1\n#define TUE  2\n#define WED  3\n#define THU  4\n#define FRI  5\n#define SAT  6\n#define SUN  7\n```\n\n这样就会显得代码量很多,所以我们可以采取用创建一个枚举:\n\n```c\n\nenum DAY\n{\n\tMON = 1, TUE, WED, THU, FRI, SAT, SUN\n};\n\n```\n\n第一个枚举成员的默认值为0,后续的枚举成员为前一个成员的值+1,例如上述代码中,MON设置了值为1,那么TUE,WED,THU,FRI,SAT,SUN的值分别为2,3,4,5,6,7;\n\n\n\n\n\n## 指针:\n\n指针是一个变量,他的值是其指向变量的地址,即内存位置的直接地址.\n\n### 指针的声明:\n\n我们可以通过type *var-name 的格式进行声明一个指针,例如\n\n```c\nint    *ip;    /* 一个整型的指针 */\ndouble *dp;    /* 一个 double 型的指针 */\nfloat  *fp;    /* 一个浮点型的指针 */\nchar   *ch;     /* 一个字符型的指针 */\n```\n\n所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。\n\n\n\n### 指针的使用:\n\n既然指针存储的是一个变量的地址,理所应当他的值应该等于地址,我们可以通过&符号来获取到一个变量的地址,然后复制给指针.并且通过*p的方式来访问所指变量\n\n例:\n\n```c\n#include<stdio.h>\n\nint main() {\n\tint a = 10;\n\tint *p = &a;\n\tprintf(\"%d\", *p);\n\tgetchar();\n\n\treturn 0;\n}\n```\n\n\n\n### NULL指针:\n\n在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为**空**指针。NULL 指针是一个定义在标准库中的值为零的常量。\n\n\n\n### 指针的运算:\n\nC指针的值是一个用数值表示的地址,所以指针也可以执行算术运算,可以对指针进行的运算有++,--,+,-.\n\n```c\n#include<stdio.h>\n/**\n++运算\n**/\nint main() {\n\tint a = 10;\n\tint *p = &a;\n\tprintf(\"p所指向的地址%d\\n\", p);\n\tp++;\n\tprintf(\"p++后所指向的地址%d\\n\", p);\n\tchar c = 'c';\n\tchar *pc = &c;\n\tprintf(\"pc所指向的地址%d\\n\", pc);\n\tpc++;\n\tprintf(\"pc++后所指向的地址%d\", pc);\n\tgetchar();\n\n\treturn 0;\n}\n```\n\n\n\n![](C语言自学小笔记-二\\1.png)\n\n运行后我们可以看到进行++运算之后,p的值增加了4,这个4正是一个整型所占的字节数,相对应的,一个char类型所占字节数为1,所以pc进行++操作以后地址增加了1.  既然++操作可以让地址往后跳一个类型的字节数,而C语言中数组的分配内存方式都是连续分配的,所以我们可以用++操作来读取数组里的值.\n\n```c\n#include<stdio.h>\n\nint main() {\n\tint a[5] = {1,2,3,4,5};\n\tfor (int i = 0; i < 5; i++) {\n\t\tprintf(\"%d,\", a[i]);\n\t}\n\tprintf(\"\\n\");\n\tint *p = a;\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tprintf(\"%d,\", *p++);\n\t}\n\n\tgetchar();\n\treturn 0;\n}\n```\n\n--运算跟++运算相反,是对指针所指地址减去类型对应的字节数.\n\n\n\n### 指针的比较:\n\n既然指针所存的数为数值,则指针也可以进行大小比较,例如我们知道数组的第一个元素的地址,和最后一个元素的地址,我们就可以通过地址判断的方式对数组进行遍历\n\n \n\n### 指向指针的指针:\n\n一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：\n\n```c\nint **var;\n```\n\n当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符\n\n## 字符串:\n\n在 C 语言中，字符串实际上是使用 **null** 字符 '\\0' 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。\n\n下面的声明和初始化创建了一个 \"Hello\" 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 \"Hello\" 的字符数多一个。\n\nC 中有大量操作字符串的函数:\n\n```c\nstrcpy(s1, s2); //复制字符串 s2 到字符串 s1。       \nstrcat(s1, s2); //连接字符串 s2 到字符串 s1 的末尾。   \nstrlen(s1); //返回字符串 s1 的长度。               \nstrcmp(s1, s2); //如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。\nstrchr(s1, ch); //返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。\nstrstr(s1, s2); //返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。\n```\n\n","tags":["C"]},{"title":"C语言自学小笔记(一)","url":"/2019/04/17/C语言自学小笔记-一/","content":"\nC语言查缺补漏小笔记\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 常量定义:\n\nC语言中,有两种简单的定义常量的方式:\n\n1.#define预处理\n\n2.使用const关键字\n\n```c\n#define LENGTH 10\nconst int  LENGTH = 10;\n```\n\n\n\n## 前缀和后缀:\n\n### 前缀:\n\n+ 0x和0X 表示十六进制,例如:0x4b\n+ 0表示八进制,例如:0213\n+ 不带前缀则默认表示十进制\n\n### 后缀:\n\n+ U:表示无符号整数\n+ L:表示长整数\n+ 后缀可大写可小写,且顺序任意,例如:30ul\n\n## C的存储类:\n\n存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：\n\n- auto\n- register\n- static\n- extern\n\n### auto存储类:\n\n局部变量默认的存储类为auto\n\n### register:\n\n**register** 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）.寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。\n\n### static存储类:\n\n**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。\n\nstatic 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。\n\n全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。\n\n以下实例演示了 static 修饰全局变量和局部变量的应用：\n\n\n\n### extern存储类:\n\n**extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\n\n当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，*extern* 是用来在另一个文件中声明一个全局变量或函数。\n\n\n\n## C的运算符:\n\n### 逻辑运算符:\n\n&& : 逻辑与运算符,两个操作数都非零则条件为真,(全真则真,有一假即假)\n\n||    : 逻辑或运算符,两个操作数只要有一个非零则条件为真.(全假则假,一真即真)\n\n!     : 逻辑非运算符,用来逆转操作数逻辑状态,如果条件为真则逻辑非运算符使其为假\n\n\n\n### 位运算符:\n\n```C\n==\t检查两个操作数的值是否相等，如果相等则条件为真。\t(A == B) 不为真。\n!=\t检查两个操作数的值是否相等，如果不相等则条件为真。\t(A != B) 为真。\n<   检查左操作数的值是否大于右操作数的值，如果是则条件为真。\t(A > B) 不为真。\n<\t检查左操作数的值是否小于右操作数的值，如果是则条件为真。\t(A < B) 为真。\n=\t检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。\t(A >= B) 不为真。\n<=\t检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。\t(A <= B) 为真。\n```\n\n\n\n## C函数:\n\n### 传值调用:\n\n传值调用向函数内传的参数实际上是实际值的复制,也叫形参.在这种情况下,修改函数内的形参不会影响实际的参数.\n\n```c\n#include<stdio.h>\n\nvoid swap(int a, int b);\nint main() {\n\tint a = 10;\n\tint b = 20;\n\tswap(10, 20);\n\tprintf(\"a的值为:%d\\n\", a);\n\tprintf(\"b的值为:%d\", b);\n\tgetchar();\n\treturn 0;\n}\n\n\n\nvoid swap(int a, int b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n\treturn;\n}\n```\n\n当我们通过main函数调用swap后打印a和b的值,发现a和b的值并没有改变.\n\n\n\n### 传址调用\n\n通过引用传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。\n\n传递指针可以让多个函数访问指针所引用的对象，而不用把对象声明为全局可访问\n\n\n\n```c\n#include<stdio.h>\nvoid swap(int *a, int *b);\nint main() {\n\tint a = 10;\n\tint b = 20;\n\tswap(&a, &b);\n\tprintf(\"a的值为:%d\\n\", a);\n\tprintf(\"b的值为:%d\", b);\n\tgetchar();\n\treturn 0;\n}\n\n\n\nvoid swap(int *a, int *b) {\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n\treturn;\n}\n```\n\n代码运行之后a和b的值调换了\n\n### 引用调用:\n\n在声明函数的时候,声明参数为引用\n\n```c\n#include<stdio.h>\nvoid swap(int &a, int &b);\nint main() {\n\tint a = 10;\n\tint b = 20;\n\tswap(a, b);\n\tprintf(\"a的值为:%d\\n\", a);\n\tprintf(\"b的值为:%d\", b);\n\tgetchar();\n\treturn 0;\n}\n\n\n\nvoid swap(int &a, int &b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n\treturn;\n}\n```\n\n代码运行之后a和b的值调换了\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["C"]},{"title":"org.springframework.expression.spel.SpelEvaluationException: EL1008E:","url":"/2019/04/15/org-springframework-expression-spel-SpelEvaluationException-EL1008E/","content":"\n今天发生了一个很诡异的事情,在进行thymeleaf进行前端视图显示的时候总是出现SpelEvaluationException异常.刚开始以为自己的属性名字填错了,经过反复确认发现没填错.后来考虑是不是get方法的问题.去类里一看,果真是get方法出了问题.\n\n\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n正确的get方法是\n\n```java\n    public Long getDid() {\n        return did;\n    }\n```\n\n然而我的get方法是从原来改的,当时为了省劲就直接把名字改了改,直接输入了did,导致在使用${dept.did}时找不到did属性\n\n```java\n    public Long getdid() {\n        return did;\n    }\n```\n\n\n\n\n\n## 错误信息:\n\n```java\n\n\norg.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field 'did' cannot be found on object of type 'com.caicai.aidangjian.entity.Department' - maybe not public or not valid?\n\tat org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:217) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:51) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:406) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:90) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:109) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:328) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:263) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:144) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.OpenElementTag.beHandled(OpenElementTag.java:205) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.Model.process(Model.java:290) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.IteratedGatheringModelProcessable.processIterationModel(IteratedGatheringModelProcessable.java:367) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.IteratedGatheringModelProcessable.process(IteratedGatheringModelProcessable.java:221) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.ProcessorTemplateHandler.handleCloseElement(ProcessorTemplateHandler.java:1640) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleCloseElementEnd(TemplateHandlerAdapterMarkupHandler.java:388) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleCloseElementEnd(InlinedOutputExpressionMarkupHandler.java:322) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleCloseElementEnd(OutputExpressionInlinePreProcessorHandler.java:220) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleCloseElementEnd(InlinedOutputExpressionMarkupHandler.java:164) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.attoparser.HtmlElement.handleCloseElementEnd(HtmlElement.java:169) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.HtmlMarkupHandler.handleCloseElementEnd(HtmlMarkupHandler.java:412) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.MarkupEventProcessorHandler.handleCloseElementEnd(MarkupEventProcessorHandler.java:473) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.ParsingElementMarkupUtil.parseCloseElement(ParsingElementMarkupUtil.java:201) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:725) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1370) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1116) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1055) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_201]\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_201]\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_201]\n```\n\n\n\n## \n\n\n\n","tags":["Spring Boot"]},{"title":"JPA Space is not allowed after parameter prefix ':'","url":"/2019/04/14/JPA-Space-is-not-allowed-after-parameter-prefix/","content":"\n查询时候想根据分数排序并且添加对应的名词序号,所以mysql语句中出现了(@i:=@i+1),在navicat下可以正常的运行.但是在使用@Query时出现'JPA Space is not allowed after parameter prefix '':'''错误;\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n@Query注解如下:\n\n```java\n    @Query(value = \"select (@i:=@i+1)pm from record s,(select @i:=0)t  order by score desc;\",nativeQuery = true)\n\n```\n\n\n\n去查资料,解决方案是把:转义 变成//:\n\n\n\n```java\n@Query(value = \"select (@i\\\\:=@i+1)pm from record s,(select @i\\\\:=0)t  order by score desc;\",nativeQuery = true)\n```","tags":["Spring Boot","JPA"]},{"title":"Echarts 初体验","url":"/2019/04/13/Echarts-初体验/","content":"\nECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的矢量图形库 [ZRender](https://github.com/ecomfe/zrender)，提供直观，交互丰富，可高度个性化定制的数据可视化图表。\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 引入Echarts.js文件\n\n> Echarts.js文件可以到\n>\n> [echarts官网](<https://echarts.baidu.com/>)下载\n>\n> ```html\n> <script src=\"echarts.min.js\"></script>\n> ```\n>\n> \n\n## 准备一个存放图表的容器\n\n```html\n<div id=\"box\" style=\"width: 600px;height:400px;\"></div>\n```\n\n\n\n## 设置参数 初始化图表\n\n```html\n\t<script>\n    var myChart = echarts.init(document.getElementById(\"box\"));\n\tvar option = {\n\t\ttitle : {\n\t\t\ttext: '未来一周气温变化',\n\t\t\tsubtext: '纯属虚构'\n\t\t},\n\t\ttooltip : {\n\t\t\ttrigger: 'axis'\n\t\t},\n\t\tlegend: {\n\t\t\tdata:['最高气温','最低气温']\n\t\t},\n\t\ttoolbox: {\n\t\t\tshow : true,\n\t\t\tfeature : {\n\t\t\t\tmark : {show: true},\n\t\t\t\tdataView : {show: true, readOnly: false},\n\t\t\t\tmagicType : {show: true, type: ['line', 'bar']},\n\t\t\t\trestore : {show: true},\n\t\t\t\tsaveAsImage : {show: true}\n\t\t\t}\n\t\t},\n\t\tcalculable : true,\n\t\txAxis : [\n\t\t\t{\n\t\t\t\ttype : 'category',\n\t\t\t\tboundaryGap : false,\n\t\t\t\tdata : ['周一','周二','周三','周四','周五','周六','周日']\n\t\t\t}\n\t\t],\n\t\tyAxis : [\n\t\t\t{\n\t\t\t\ttype : 'value',\n\t\t\t\taxisLabel : {\n\t\t\t\t\tformatter: '{value} °C'\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\tseries : [\n\t\t\t{\n\t\t\t\tname:'最高气温',\n\t\t\t\ttype:'line',\n\t\t\t\tdata:[11, 11, 15, 13, 12, 13, 10],\n\t\t\t\tmarkPoint : {\n\t\t\t\t\tdata : [\n\t\t\t\t\t\t{type : 'max', name: '最大值'},\n\t\t\t\t\t\t{type : 'min', name: '最小值'}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tmarkLine : {\n\t\t\t\t\tdata : [\n\t\t\t\t\t\t{type : 'average', name: '平均值'}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:'最低气温',\n\t\t\t\ttype:'line',\n\t\t\t\tdata:[1, -2, 2, 5, 3, 2, 0],\n\t\t\t\tmarkPoint : {\n\t\t\t\t\tdata : [\n\t\t\t\t\t\t{name : '周最低', value : -2, xAxis: 1, yAxis: -1.5}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tmarkLine : {\n\t\t\t\t\tdata : [\n\t\t\t\t\t\t{type : 'average', name : '平均值'}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t};\n    myChart.setOption(option);\n</script>\n```\n\n## 效果图\n\n![](/Echarts-初体验/1.png)\n\n​\t\t\t\n\n\n\n![](Echarts-初体验\\2.png)\n\n## 各个配置参数的说明\n\n```java\ntheme = {\n    // 全图默认背景\n    // backgroundColor: 'rgba(0,0,0,0)',\n\n    // 默认色板\n    color: ['#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed',\n            '#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0',\n            '#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700',\n            '#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'],\n\n    // 图表标题\n    title: {\n        x: 'left',                 // 水平安放位置，默认为左对齐，可选为：\n                                   // 'center' ¦ 'left' ¦ 'right'\n                                   // ¦ {number}（x坐标，单位px）\n        y: 'top',                  // 垂直安放位置，默认为全图顶端，可选为：\n                                   // 'top' ¦ 'bottom' ¦ 'center'\n                                   // ¦ {number}（y坐标，单位px）\n        //textAlign: null          // 水平对齐方式，默认根据x设置自动调整\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',       // 标题边框颜色\n        borderWidth: 0,            // 标题边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 标题内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        itemGap: 10,               // 主副标题纵向间隔，单位px，默认为10，\n        textStyle: {\n            fontSize: 18,\n            fontWeight: 'bolder',\n            color: '#333'          // 主标题文字颜色\n        },\n        subtextStyle: {\n            color: '#aaa'          // 副标题文字颜色\n        }\n    },\n\n    // 图例\n    legend: {\n        orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：\n                                   // 'horizontal' ¦ 'vertical'\n        x: 'center',               // 水平安放位置，默认为全图居中，可选为：\n                                   // 'center' ¦ 'left' ¦ 'right'\n                                   // ¦ {number}（x坐标，单位px）\n        y: 'top',                  // 垂直安放位置，默认为全图顶端，可选为：\n                                   // 'top' ¦ 'bottom' ¦ 'center'\n                                   // ¦ {number}（y坐标，单位px）\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',       // 图例边框颜色\n        borderWidth: 0,            // 图例边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 图例内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，\n                                   // 横向布局时为水平间隔，纵向布局时为纵向间隔\n        itemWidth: 20,             // 图例图形宽度\n        itemHeight: 14,            // 图例图形高度\n        textStyle: {\n            color: '#333'          // 图例文字颜色\n        }\n    },\n\n    // 值域\n    dataRange: {\n        orient: 'vertical',        // 布局方式，默认为垂直布局，可选为：\n                                   // 'horizontal' ¦ 'vertical'\n        x: 'left',                 // 水平安放位置，默认为全图左对齐，可选为：\n                                   // 'center' ¦ 'left' ¦ 'right'\n                                   // ¦ {number}（x坐标，单位px）\n        y: 'bottom',               // 垂直安放位置，默认为全图底部，可选为：\n                                   // 'top' ¦ 'bottom' ¦ 'center'\n                                   // ¦ {number}（y坐标，单位px）\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',       // 值域边框颜色\n        borderWidth: 0,            // 值域边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 值域内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，\n                                   // 横向布局时为水平间隔，纵向布局时为纵向间隔\n        itemWidth: 20,             // 值域图形宽度，线性渐变水平布局宽度为该值 * 10\n        itemHeight: 14,            // 值域图形高度，线性渐变垂直布局高度为该值 * 10\n        splitNumber: 5,            // 分割段数，默认为5，为0时为线性渐变\n        color:['#1e90ff','#f0ffff'],//颜色 \n        //text:['高','低'],         // 文本，默认为数值文本\n        textStyle: {\n            color: '#333'          // 值域文字颜色\n        }\n    },\n\n    toolbox: {\n        orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：\n                                   // 'horizontal' ¦ 'vertical'\n        x: 'right',                // 水平安放位置，默认为全图右对齐，可选为：\n                                   // 'center' ¦ 'left' ¦ 'right'\n                                   // ¦ {number}（x坐标，单位px）\n        y: 'top',                  // 垂直安放位置，默认为全图顶端，可选为：\n                                   // 'top' ¦ 'bottom' ¦ 'center'\n                                   // ¦ {number}（y坐标，单位px）\n        color : ['#1e90ff','#22bb22','#4b0082','#d2691e'],\n        backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色\n        borderColor: '#ccc',       // 工具箱边框颜色\n        borderWidth: 0,            // 工具箱边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 工具箱内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，\n                                   // 横向布局时为水平间隔，纵向布局时为纵向间隔\n        itemSize: 16,              // 工具箱图形宽度\n        featureImageIcon : {},     // 自定义图片icon\n        featureTitle : {\n            mark : '辅助线开关',\n            markUndo : '删除辅助线',\n            markClear : '清空辅助线',\n            dataZoom : '区域缩放',\n            dataZoomReset : '区域缩放后退',\n            dataView : '数据视图',\n            lineChart : '折线图切换',\n            barChart : '柱形图切换',\n            restore : '还原',\n            saveAsImage : '保存为图片'\n        }\n    },\n\n    // 提示框\n    tooltip: {\n        trigger: 'item',           // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'\n        showDelay: 20,             // 显示延迟，添加显示延迟可以避免频繁切换，单位ms\n        hideDelay: 100,            // 隐藏延迟，单位ms\n        transitionDuration : 0.4,  // 动画变换时间，单位s\n        backgroundColor: 'rgba(0,0,0,0.7)',     // 提示背景颜色，默认为透明度为0.7的黑色\n        borderColor: '#333',       // 提示边框颜色\n        borderRadius: 4,           // 提示边框圆角，单位px，默认为4\n        borderWidth: 0,            // 提示边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 提示内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        axisPointer : {            // 坐标轴指示器，坐标轴触发有效\n            type : 'line',         // 默认为直线，可选为：'line' | 'shadow'\n            lineStyle : {          // 直线指示器样式设置\n                color: '#48b',\n                width: 2,\n                type: 'solid'\n            },\n            shadowStyle : {                       // 阴影指示器样式设置\n                width: 'auto',                   // 阴影大小\n                color: 'rgba(150,150,150,0.3)'  // 阴影颜色\n            }\n        },\n        textStyle: {\n            color: '#fff'\n        }\n    },\n\n    // 区域缩放控制器\n    dataZoom: {\n        orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：\n                                   // 'horizontal' ¦ 'vertical'\n        // x: {number},            // 水平安放位置，默认为根据grid参数适配，可选为：\n                                   // {number}（x坐标，单位px）\n        // y: {number},            // 垂直安放位置，默认为根据grid参数适配，可选为：\n                                   // {number}（y坐标，单位px）\n        // width: {number},        // 指定宽度，横向布局时默认为根据grid参数适配\n        // height: {number},       // 指定高度，纵向布局时默认为根据grid参数适配\n        backgroundColor: 'rgba(0,0,0,0)',       // 背景颜色\n        dataBackgroundColor: '#eee',            // 数据背景颜色\n        fillerColor: 'rgba(144,197,237,0.2)',   // 填充颜色\n        handleColor: 'rgba(70,130,180,0.8)'     // 手柄颜色\n    },\n\n    // 网格\n    grid: {\n        x: 80,\n        y: 60,\n        x2: 80,\n        y2: 60,\n        // width: {totalWidth} - x - x2,\n        // height: {totalHeight} - y - y2,\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderWidth: 1,\n        borderColor: '#ccc'\n    },\n\n    // 类目轴\n    categoryAxis: {\n        position: 'bottom',    // 位置\n        nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'\n        boundaryGap: true,     // 类目起始和结束两端空白策略\n        axisLine: {            // 坐标轴线\n            show: true,        // 默认显示，属性show控制显示与否\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#48b',\n                width: 2,\n                type: 'solid'\n            }\n        },\n        axisTick: {            // 坐标轴小标记\n            show: true,       // 属性show控制显示与否，默认不显示\n            interval: 'auto',\n            // onGap: null,\n            inside : false,    // 控制小标记是否在grid里 \n            length :5,         // 属性length控制线长\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#333',\n                width: 1\n            }\n        },\n        axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel\n            show: true,\n            interval: 'auto',\n            rotate: 0,\n            margin: 8,\n            // formatter: null,\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                color: '#333'\n            }\n        },\n        splitLine: {           // 分隔线\n            show: true,        // 默认显示，属性show控制显示与否\n            // onGap: null,\n            lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        splitArea: {           // 分隔区域\n            show: false,       // 默认不显示，属性show控制显示与否\n            // onGap: null,\n            areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    },\n\n    // 数值型坐标轴默认参数\n    valueAxis: {\n        position: 'left',      // 位置\n        nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'\n        nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式\n        boundaryGap: [0, 0],   // 数值起始和结束两端空白策略\n        splitNumber: 5,        // 分割段数，默认为5\n        axisLine: {            // 坐标轴线\n            show: true,        // 默认显示，属性show控制显示与否\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#48b',\n                width: 2,\n                type: 'solid'\n            }\n        },\n        axisTick: {            // 坐标轴小标记\n            show: false,       // 属性show控制显示与否，默认不显示\n            inside : false,    // 控制小标记是否在grid里 \n            length :5,         // 属性length控制线长\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#333',\n                width: 1\n            }\n        },\n        axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel\n            show: true,\n            rotate: 0,\n            margin: 8,\n            // formatter: null,\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                color: '#333'\n            }\n        },\n        splitLine: {           // 分隔线\n            show: true,        // 默认显示，属性show控制显示与否\n            lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        splitArea: {           // 分隔区域\n            show: false,       // 默认不显示，属性show控制显示与否\n            areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    },\n\n    polar : {\n        center : ['50%', '50%'],    // 默认全局居中\n        radius : '75%',\n        startAngle : 90,\n        splitNumber : 5,\n        name : {\n            show: true,\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                color: '#333'\n            }\n        },\n        axisLine: {            // 坐标轴线\n            show: true,        // 默认显示，属性show控制显示与否\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#ccc',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel\n            show: false,\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                color: '#333'\n            }\n        },\n        splitArea : {\n            show : true,\n            areaStyle : {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        },\n        splitLine : {\n            show : true,\n            lineStyle : {\n                width : 1,\n                color : '#ccc'\n            }\n        }\n    },\n\n    // 柱形图默认参数\n    bar: {\n        barMinHeight: 0,          // 最小高度改为0\n        // barWidth: null,        // 默认自适应\n        barGap: '30%',            // 柱间距离，默认为柱形宽度的30%，可设固定值\n        barCategoryGap : '20%',   // 类目间柱形距离，默认为类目间距的20%，可设固定值\n        itemStyle: {\n            normal: {\n                // color: '各异',\n                barBorderColor: '#fff',       // 柱条边线\n                barBorderRadius: 0,           // 柱条边线圆角，单位px，默认为0\n                barBorderWidth: 1,            // 柱条边线线宽，单位px，默认为1\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            },\n            emphasis: {\n                // color: '各异',\n                barBorderColor: 'rgba(0,0,0,0)',   // 柱条边线\n                barBorderRadius: 0,                // 柱条边线圆角，单位px，默认为0\n                barBorderWidth: 1,                 // 柱条边线线宽，单位px，默认为1\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            }\n        }\n    },\n\n    // 折线图默认参数\n    line: {\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                lineStyle: {\n                    width: 2,\n                    type: 'solid',\n                    shadowColor : 'rgba(0,0,0,0)', //默认透明\n                    shadowBlur: 5,\n                    shadowOffsetX: 3,\n                    shadowOffsetY: 3\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            }\n        },\n        //smooth : false,\n        //symbol: null,         // 拐点图形类型\n        symbolSize: 2,          // 拐点图形大小\n        //symbolRotate : null,  // 拐点图形旋转控制\n        showAllSymbol: false    // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\n    },\n\n    // K线图默认参数\n    k: {\n        // barWidth : null          // 默认自适应\n        // barMaxWidth : null       // 默认自适应 \n        itemStyle: {\n            normal: {\n                color: '#fff',          // 阳线填充颜色\n                color0: '#00aa11',      // 阴线填充颜色\n                lineStyle: {\n                    width: 1,\n                    color: '#ff3200',   // 阳线边框颜色\n                    color0: '#00aa11'   // 阴线边框颜色\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                // color0: 各异\n            }\n        }\n    },\n\n    // 散点图默认参数\n    scatter: {\n        //symbol: null,      // 图形类型\n        symbolSize: 4,       // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\n        //symbolRotate : null,  // 图形旋转控制\n        large: false,        // 大规模散点图\n        largeThreshold: 2000,// 大规模阀值，large为true且数据量>largeThreshold才启用大规模模式\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            },\n            emphasis: {\n                // color: '各异'\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            }\n        }\n    },\n\n    // 雷达图默认参数\n    radar : {\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                label: {\n                    show: false\n                },\n                lineStyle: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                label: {\n                    show: false\n                }\n            }\n        },\n        //symbol: null,         // 拐点图形类型\n        symbolSize: 2           // 可计算特性参数，空数据拖拽提示图形大小\n        //symbolRotate : null,  // 图形旋转控制\n    },\n\n    // 饼图默认参数\n    pie: {\n        center : ['50%', '50%'],    // 默认全局居中\n        radius : [0, '75%'],\n        clockWise : false,          // 默认逆时针\n        startAngle: 90,\n        minAngle: 0,                // 最小角度改为0\n        selectedOffset: 10,         // 选中是扇区偏移量\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                borderColor: '#fff',\n                borderWidth: 1,\n                label: {\n                    show: true,\n                    position: 'outer'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                labelLine: {\n                    show: true,\n                    length: 20,\n                    lineStyle: {\n                        // color: 各异,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                borderColor: 'rgba(0,0,0,0)',\n                borderWidth: 1,\n                label: {\n                    show: false\n                    // position: 'outer'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                labelLine: {\n                    show: false,\n                    length: 20,\n                    lineStyle: {\n                        // color: 各异,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            }\n        }\n    },\n\n    map: {\n        mapType: 'china',   // 各省的mapType暂时都用中文\n        mapLocation: {\n            x : 'center',\n            y : 'center'\n            // width    // 自适应\n            // height   // 自适应\n        },\n        showLegendSymbol : true,       // 显示图例颜色标识（系列标识的小圆点），存在legend时生效\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                borderColor: '#fff',\n                borderWidth: 1,\n                areaStyle: {\n                    color: '#ccc'//rgba(135,206,250,0.8)\n                },\n                label: {\n                    show: false,\n                    textStyle: {\n                        color: 'rgba(139,69,19,1)'\n                    }\n                }\n            },\n            emphasis: {                 // 也是选中样式\n                // color: 各异,\n                borderColor: 'rgba(0,0,0,0)',\n                borderWidth: 1,\n                areaStyle: {\n                    color: 'rgba(255,215,0,0.8)'\n                },\n                label: {\n                    show: false,\n                    textStyle: {\n                        color: 'rgba(139,69,19,1)'\n                    }\n                }\n            }\n        }\n    },\n\n    force : {\n        // 数据map到圆的半径的最小值和最大值\n        minRadius : 10,\n        maxRadius : 20,\n        density : 1.0,\n        attractiveness : 1.0,\n        // 初始化的随机大小位置\n        initSize : 300,\n        // 向心力因子，越大向心力越大\n        centripetal : 1,\n        // 冷却因子\n        coolDown : 0.99,\n        // 分类里如果有样式会覆盖节点默认样式\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                nodeStyle : {\n                    brushType : 'both',\n                    color : '#f08c2e',\n                    strokeColor : '#5182ab'\n                },\n                linkStyle : {\n                    strokeColor : '#5182ab'\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                nodeStyle : {},\n                linkStyle : {}\n            }\n        }\n    },\n\n    chord : {\n        radius : ['65%', '75%'],\n        center : ['50%', '50%'],\n        padding : 2,\n        sort : 'none', // can be 'none', 'ascending', 'descending'\n        sortSub : 'none', // can be 'none', 'ascending', 'descending'\n        startAngle : 90,\n        clockWise : false,\n        showScale : false,\n        showScaleText : false,\n        itemStyle : {\n            normal : {\n                label : {\n                    show : true\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                lineStyle : {\n                    width : 0,\n                    color : '#000'\n                },\n                chordStyle : {\n                    lineStyle : {\n                        width : 1,\n                        color : '#666'\n                    }\n                }\n            },\n            emphasis : {\n                lineStyle : {\n                    width : 0,\n                    color : '#000'\n                },\n                chordStyle : {\n                    lineStyle : {\n                        width : 2,\n                        color : '#333'\n                    }\n                }\n            }\n        }\n    },\n\n    island: {\n        r: 15,\n        calculateStep: 0.1  // 滚轮可计算步长 0.1 = 10%\n    },\n\n    markPoint : {\n        symbol: 'pin',         // 标注类型\n        symbolSize: 10,        // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\n        //symbolRotate : null, // 标注旋转控制\n        itemStyle: {\n            normal: {\n                // color: 各异，\n                // borderColor: 各异,     // 标注边线颜色，优先于color \n                borderWidth: 2,            // 标注边线线宽，单位px，默认为1\n                label: {\n                    show: true,\n                    position: 'inside' // 可选为'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            },\n            emphasis: {\n                // color: 各异\n                label: {\n                    show: true\n                    // position: 'inside'  // 'left'|'right'|'top'|'bottom'\n                    // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            }\n        }\n    },\n\n    markLine : {\n        // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string\n        symbol: ['circle', 'arrow'],  \n        // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\n        symbolSize: [2, 4],\n        // 标线起始和结束的symbol旋转控制\n        //symbolRotate : null,\n        itemStyle: {\n            normal: {\n                // color: 各异,           // 标线主色，线色，symbol主色\n                // borderColor: 随color,     // 标线symbol边框颜色，优先于color \n                borderWidth: 2,          // 标线symbol边框线宽，单位px，默认为2\n                label: {\n                    show: false,\n                    // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom'\n                    position: 'inside',  \n                    textStyle: {         // 默认使用全局文本样式，详见TEXTSTYLE\n                        color: '#333'\n                    }\n                },\n                lineStyle: {\n                    // color: 随borderColor, // 主色，线色，优先级高于borderColor和color\n                    // width: 随borderWidth, // 优先于borderWidth\n                    type: 'solid',\n                    shadowColor : 'rgba(0,0,0,0)', //默认透明\n                    shadowBlur: 5,\n                    shadowOffsetX: 3,\n                    shadowOffsetY: 3\n                }\n            },\n            emphasis: {\n                // color: 各异\n                label: {\n                    show: false\n                    // position: 'inside' // 'left'|'right'|'top'|'bottom'\n                    // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                lineStyle : {}\n            }\n        }\n    },\n\n    textStyle: {\n        decoration: 'none',\n        fontFamily: 'Arial, Verdana, sans-serif',\n        fontFamily2: '微软雅黑',    // IE8- 字体模糊并且不支持不同字体混排，额外指定一份\n        fontSize: 12,\n        fontStyle: 'normal',\n        fontWeight: 'normal'\n    },\n\n    // 默认标志图形类型列表\n    symbolList : [\n      'circle', 'rectangle', 'triangle', 'diamond',\n      'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond'\n    ],\n    loadingText : 'Loading...',\n    // 可计算特性配置，孤岛，提示颜色\n    calculable: false,              // 默认关闭可计算特性\n    calculableColor: 'rgba(255,165,0,0.6)',       // 拖拽提示边框颜色\n    calculableHolderColor: '#ccc', // 可计算占位提示颜色\n    nameConnector: ' & ',\n    valueConnector: ' : ',\n    animation: true,\n    animationThreshold: 2500,       // 动画元素阀值，产生的图形原素超过2500不出动画\n    addDataAnimation: true,         // 动态数据接口是否开启动画效果\n    animationDuration: 2000,\n    animationEasing: 'ExponentialOut'    //BounceOut\n}\n\n```\n\n","tags":["Echarts"]},{"title":"Spring Boot 拦截器","url":"/2019/04/12/Spring-Boot-登录拦截器验证/","content":"\njava里的拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在AOP（Aspect-Oriented Programming）中拦截器用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## HandlerInterceptor 接口介绍:\n\n在HandlerInterceptor 中有三个方法:\n\n```java\ndefault boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    return true;\n}\n\ndefault void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {\n}\n\ndefault void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n}\n```\n\n**preHandle:** 预处理方法,实现处理器的预处理(例如登录状态),handler参数为相应的处理器,返回值:true表示继续流程,false表示流程中断,我们需要通过reponse来产生响应.\n\n**postHandle**：后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。\n\n**afterCompletion**：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。\n\n\n\n## 配置拦截器:\n\n### 创建拦截器类:\n\n```java\npackage caicai.springbootinterceptor1.interceptor;\n\nimport org.springframework.lang.Nullable;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * @author liu\n * @title: LoginInterceptor\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:31\n */\npublic class LoginInterceptor implements HandlerInterceptor{\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        System.out.println(\"preHandle.............................\");\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {\n        System.out.println(\"postHandle.............................\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n        System.out.println(\"afterCompletion.............................\");\n    }\n}\n```\n\n### 创建拦截器配置类:\n\n```java\npackage caicai.springbootinterceptor1.config;\n\nimport caicai.springbootinterceptor1.interceptor.LoginInterceptor;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n/**\n * @author liu\n * @title: LoginInterceptorConfig\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:33\n */\n@Configuration\npublic class LoginInterceptorConfig implements WebMvcConfigurer{\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/login\");\n\n    }\n}\n```\n\naddPathPatterns(\"/**\"):表示拦截所有的url请求;\n\nexcludePathPatterns(\"/login\"):表示排除login\n\n完成了拦截器配置后,在启动springboot项目的时候,除了login以外,其他所有的请求都会经过拦截器处理,我们可以使用preHandle来完成一个登录验证的功能\n\n\n\n## 登录验证实现:\n\n### 效果:\n\n1.有两个界面: 登录界面, 主界面\n\n2:登录界面和主界面都可以通过相应请求跳转到,但是主界面只有登录之后才能查看,否则就跳回登录界面\n\n项目目录:\n\n![](Spring-Boot-登录拦截器验证\\1.png)\n\n### \n\n### index.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<form action=\"/login\">\n    <span>用户名:</span> <input type=\"text\" name=\"username\">\n    <span>密码:</span>  <input type=\"text\" name=\"password\">\n    <button>提交</button>\n</form>\n</body>\n</html>\n```\n\n\n\n### main.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"><head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<h1>这里是主页面</h1>\n当前登录用户:<span th:text=\"${session.username}\"></span>\n</body>\n</html>\n```\n\n如果登录的话 ${session.username}会获取到存贮在session中的用户名\n\n\n\n\n\n### Logininterceptor.java\n\n```java\npackage caicai.springbootinterceptor1.interceptor;\n\nimport org.springframework.lang.Nullable;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * @author liu\n * @title: LoginInterceptor\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:31\n */\npublic class LoginInterceptor implements HandlerInterceptor{\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        /**\n        通过session中的用户名来判断是否登录,因为一旦登录了就会在session中存储用户名\n        **/\n        if(request.getSession().getAttribute(\"username\")!=null){\n            System.out.println(\"登录了\");\n            return true;\n        }else{\n            System.out.println(\"未登录\");\n            response.sendRedirect(request.getContextPath()+\"/index\");\n\n            return false;\n        }\n\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {\n        System.out.println(\"postHandle.............................\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n        System.out.println(\"afterCompletion.............................\");\n    }\n}\n```\n\n\n\n### LoginController\n\n```java\npackage caicai.springbootinterceptor1.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n * @author liu\n * @title: LoginController\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:22\n */\n@Controller\npublic class LoginController {\n\n    /**\n    登录界面的url映射\n    **/\n    @RequestMapping(\"/index\")\n    public String index(){\n        return \"index\";\n    }\n    /**\n    登录,此处直接用字符串是否是admin的方式来模拟数据库查询登录\n    若账号密码正确则跳转到main界面若账号密码错误则继续跳转到登录界面\n    **/\n    @RequestMapping(\"/login\")\n    public String login(String username, String password, HttpServletRequest request){\n        if (username.equals(\"admin\")&& password.equals(\"admin\")){\n            request.getSession().setAttribute(\"username\",username);\n            return \"main\";\n        }else {\n            return \"login\";\n        }\n    }\n    /**\n    主界面的url映射  为了测试不登陆直接进主页面被拦截\n    **/\n    @RequestMapping(\"/main\")\n    public String main(){\n        return \"main\";\n    }\n\n}\n```\n\n### LoginInterceptorConfig.java:\n\n配置文件,配置了拦截器和拦截路径\n\n```java\npackage caicai.springbootinterceptor1.config;\n\nimport caicai.springbootinterceptor1.interceptor.LoginInterceptor;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n/**\n * @author liu\n * @title: LoginInterceptorConfig\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:33\n */\n@Configuration\npublic class LoginInterceptorConfig implements WebMvcConfigurer{\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/login\").excludePathPatterns(\"/index\");\n\n    }\n}\n```\n\n\n\n本实例只是粗略的完成了登录拦截的功能,对于一些细节没有完善,例如错误提示等.","tags":["Spring Boot"]},{"title":"MYSQL随机选择数据","url":"/2019/04/10/MYSQL随机选择数据/","content":"\n最近在做一个在线考试系统,遇到需要随机选择20道选择题的需求.\n\n\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 使用ORDER BY RAND()选择随机记录\n\nMySQL没有内置语句来从数据库表中选择随机记录。为了实现这个目的，可使用`RAND`函数。 以下查询是从数据库表中选择N个随机记录：\n\n```mysql\nSELECT \n    *\nFROM\n    tbl\nORDER BY RAND()\nLIMIT N;\n```\n\n- `RAND（）`函数为表中的每一行生成一个随机值。 \n- [ORDER BY](http://www.studymysql.com/mysql/order-by.html)子句按照`RAND（）`函数生成的随机数对表中的所有行进行排序。 \n\n这种技术非常适合小表。如果在大的表上执行速度是非常缓慢的，因为MySQL必须排序整个表，以挑选随机的行数据。查询的速度还取决于表中的行数。表具有的行越多，MySQL都要为每行生成随机数，所以所需的时间就越多。\n\n\n\n","tags":["MYSQL"]},{"title":"Jpa 自定义查询语句","url":"/2019/04/10/jpa-自定义查询语句/","content":"\n在使用Spring Data Jpa框架时，根据业务需求我们通常需要进行复杂的数据库查询，并返回我们自定义的实体类，而在该框架下，目前仅仅支持返回与数据库映射进行持久化的POJO实体。虽然在框架上我们可以使用@Query注解执行我们自定义的sql语句，但是其返回值为List<Object[]> 类型，即多个Object数组的List集合。\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## @Query()注解\n\n通过使@query注解,可以自定义语句进行sql操作\n\n下例为在数据库中查询10个随机的选择题的自定义查询方法:\n\n```java\npublic interface MultipleChoiceRepository extends JpaRepository<MultipleChoice,Long> {\n    @Query(value = \"select * from choice ORDER BY RAND() limit :num\",nativeQuery = true)\n    public List<MultipleChoice> findByNmber(@Param(\"num\") Integer num);\n}\n```\n\n## 开启mysql语句\n\n```java\n  @Query(value = \"\",nativeQuery = true)  //nativeQuery= true开启mysql\n```\n\n## @Modefying()注解\n\n如果是删除或修改操作，需要加入此注解进行修饰. 以通知 SpringData， 这是一个 UPDATE 或 DELETE 操作 ；默认情况下，是只读，所以查询不需要\n\n# 参数传递:\n\n## @Param()注解\n\n使用@Param注解可以给查询语句中注入参数\n\n```java\n@Param(\"num\") Integer num\n```\n\n在sql语句中使用  :参数名    进行调用\n\n## 使用?占位符\n\n```java\npublic interface MultipleChoiceRepository extends JpaRepository<MultipleChoice,Long> {\n    @Query(value = \"select * from choice ORDER BY RAND() limit ?\",nativeQuery = true)\n\n    public List<MultipleChoice> findByNmber(Integer num);\n\n}\n```\n\nsql语句中也可以使用?占位符的方式进行参数写入","tags":["Spring Boot"]},{"title":"Spring Boot Jpa","url":"/2019/03/31/Spring-Boot-Jpa/","content":"\n  全称Java Persistence API，通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。\n\n​     JPA的出现有两个原因：\n 其一，简化现有Java EE和Java SE应用的对象持久化的开发工作；\n 其二，Sun希望整合对ORM技术，实现持久化领域的统一。\n\n​     JPA提供的技术：\n\n 1）ORM映射元数据：JPA支持XML和JDK 5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中；\n\n 2）JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。\n\n 3）查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## pom.xml中导入依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n   <modelVersion>4.0.0</modelVersion>\n   <parent>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-parent</artifactId>\n      <version>2.1.3.RELEASE</version>\n      <relativePath/> <!-- lookup parent from repository -->\n   </parent>\n   <groupId>com.caicai</groupId>\n   <artifactId>spring-boot-jpa</artifactId>\n   <version>0.0.1-SNAPSHOT</version>\n   <name>spring-boot-jpa</name>\n   <description>Demo project for Spring Boot</description>\n\n   <properties>\n      <java.version>1.8</java.version>\n   </properties>\n\n   <dependencies>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-data-jpa</artifactId>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-jdbc</artifactId>\n      </dependency>\n\n      <dependency>\n         <groupId>mysql</groupId>\n         <artifactId>mysql-connector-java</artifactId>\n         <scope>runtime</scope>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-test</artifactId>\n         <scope>test</scope>\n      </dependency>\n   </dependencies>\n\n   <build>\n      <plugins>\n         <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n         </plugin>\n      </plugins>\n   </build>\n\n</project>\n```\n\n## 创建实体类\n\n```java\npackage com.caicai.springbootjpa.entity;\n\nimport javax.persistence.*;\n\n/**\n * @author liu\n * @title: User\n * @projectName spring-boot-jpa\n * @description: TODO\n * @date 2019/3/3121:14\n */\n\n@Entity\npublic class User {\n    @GeneratedValue(strategy = GenerationType.AUTO)//设置自增长策略\n    @Id\n    private Integer id;\n    @Column(length = 20,nullable = false)  //column可以设置属性\n    private String name;\n    @Column(length = 20,nullable = true)\n    private Integer age;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public User() {\n    }\n\n    public User(String name, Integer age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n\n\n## 创建UserRepository\n\n```java\npackage com.caicai.springbootjpa.repository;\n\nimport com.caicai.springbootjpa.entity.User;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\n/**\n * @author liu\n * @title: UserRepository\n * @projectName spring-boot-jpa\n * @description: TODO\n * @date 2019/3/3121:06\n */\npublic interface UserRepository extends JpaRepository<User,Integer>{\n}\n\n```\n\n## 配置数据源和自动建表:\n\n```xml\nspring:\n  datasource:\n    username: root\n    password: 123456\n    url: jdbc:mysql://localhost:3306/jpa\n    driver-class-name: com.mysql.jdbc.Driver\n  jpa:\n    hibernate:\n      ddl-auto: update\n    show-sql: true\n```\n\n\n\n## 测试类:\n\n```java\npackage com.caicai.springbootjpa;\n\nimport com.caicai.springbootjpa.entity.User;\nimport com.caicai.springbootjpa.repository.UserRepository;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootJpaApplicationTests {\n    @Autowired\n    UserRepository userRepository;\n\t@Test\n\tpublic void test() {\n\t    User user = new User();\n\t    user.setAge(10);\n\t    user.setName(\"caicai\");\n\t    userRepository.save(user);\n\t}\n\n}\n```\n\n","tags":["Spring Boot"]},{"title":"Spring Boot 整合Mybatis(基于注解)","url":"/2019/03/31/Spring-Boot-整合Mybatis-基于注解/","content":"\n基于注解的Spring Boot 整合Mybatis\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 项目结构\n\n![](Spring-Boot-整合Mybatis-基于注解\\1.png)\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.1.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.caicai</groupId>\n\t<artifactId>spring-boot-mybatis-annotation</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>spring-boot-mybatis-annotation</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-jdbc</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.spring.boot</groupId>\n\t\t\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t\t\t<version>2.0.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>mysql</groupId>\n\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t\t<scope>runtime</scope>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n## UserMapper.java\n\n```java\npackage com.caicai.springbootmybatisannotation.mapper;\n\nimport com.caicai.springbootmybatisannotation.pojo.User;\nimport org.apache.ibatis.annotations.Insert;\nimport org.apache.ibatis.annotations.Mapper;\n\n/**\n * @author liu\n * @title: UserMapper\n * @projectName spring-boot-mybatis-annotation\n * @description: TODO\n * @date 2019/3/3120:16\n */\n@Mapper\npublic interface UserMapper {\n    @Insert(\"insert into users(name,age) values(#{name},#{age})\")\n    public void addUser(User user);\n\n}\n```\n\n\n\n## User.java\n\n```java\npackage com.caicai.springbootmybatisannotation.pojo;\n\n/**\n * @author liu\n * @title: User\n * @projectName spring-boot-mybatis-annotation\n * @description: TODO\n * @date 2019/3/3120:16\n */\npublic class User {\n    private Integer id;\n    private String name;\n    private Integer age;\n\n    public User() {\n    }\n\n    public User(Integer id, String name, Integer age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n```\n\n\n\n## application.yml\n\n```xml\nspring:\n  datasource:\n    password: 123456\n    username: root\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm\n```\n\n\n\n## SpringBootMybatisAnnotationApplicationTests.java\n\n```java\npackage com.caicai.springbootmybatisannotation;\n\nimport com.caicai.springbootmybatisannotation.mapper.UserMapper;\nimport com.caicai.springbootmybatisannotation.pojo.User;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootMybatisAnnotationApplicationTests {\n    @Autowired\n    UserMapper userMapper;\n   @Test\n    public void addUser(){\n        User user = new User();\n        user.setAge(10);\n        user.setName(\"caicai\");\n        userMapper.addUser(user);\n    }\n\n}\n```\n\n## 对比xml文件配置\n\n```java\n@Insert(\"insert into users(name,age) values(#{name},#{age})\")\npublic void addUser(User user);\n```\n\n@Insert注解的配置就相当于在UserMapper.xml中配置:","tags":["Spring Boot","Mybatis"]},{"title":"org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)异常处理","url":"/2019/03/31/org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found-异常处理/","content":"\n在SpringBoot整合Mybatis出现org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): 错误\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 报错信息:\n\n```java\norg.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.caicai.springbootspringmvcmybatis.mapper.UsersMapper.insertUser\n\tat org.apache.ibatis.binding.MapperMethod$SqlCommand.<init>(MapperMethod.java:232) ~[mybatis-3.5.0.jar:3.5.0]\n\tat org.apache.ibatis.binding.MapperMethod.<init>(MapperMethod.java:50) ~[mybatis-3.5.0.jar:3.5.0]\n\tat org.apache.ibatis.binding.MapperProxy.lambda$cachedMapperMethod$0(MapperProxy.java:62) ~[mybatis-3.5.0.jar:3.5.0]\n\tat java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1660) ~[na:1.8.0_201]\n\tat org.apache.ibatis.binding.MapperProxy.cachedMapperMethod(MapperProxy.java:62) ~[mybatis-3.5.0.jar:3.5.0]\n\tat org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:57) ~[mybatis-3.5.0.jar:3.5.0]\n\tat com.sun.proxy.$Proxy56.insertUser(Unknown Source) ~[na:na]\n\tat com.caicai.springbootspringmvcmybatis.service.UserServiceImpl.addUser(UserServiceImpl.java:23) ~[classes/:na]\n\tat com.caicai.springbootspringmvcmybatis.service.UserServiceImpl$$FastClassBySpringCGLIB$$3b4656c9.invoke(<generated>) ~[classes/:na]\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:294) ~[spring-tx-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98) ~[spring-tx-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat com.caicai.springbootspringmvcmybatis.service.UserServiceImpl$$EnhancerBySpringCGLIB$$c9ef3195.addUser(<generated>) ~[classes/:na]\n\tat com.caicai.springbootspringmvcmybatis.controller.UserController.addUser(UserController.java:30) ~[classes/:na]\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_201]\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_201]\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_201]\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_201]\n\tat org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:800) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:908) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:660) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_201]\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_201]\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_201]\n```\n\n\n\n## 解决\n\n经过研究,发现UsersMapper.xml文件在com.caicai.springbootspringmvcmybatis.mapper包里不会被编译,所以考虑在resources里创建一个mapper文件夹,并且在application.yml配置mybatis\n\n```xml\nmybatis:\n  type-aliases-package: com.caicai.springbootspringmvcmybatis.pojo\n  mapper-locations: classpath:mapper/*.xml\n\n```\n\n","tags":["Spring Boot","Mybatis"]},{"title":"JDBC连接Mysql8.0驱动版本过低报错","url":"/2019/03/29/JDBC连接Mysql8-0-11版本出现问题/","content":"\nJDBC连接Mysql8.0.11版本出现问题,不停循环报错 错误信息如下:\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 报错信息:\n\n```java\nFri Mar 29 21:39:01 CST 2019 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.\nERROR [Druid-ConnectionPool-Create-2085079540] - create connection SQLException, url: jdbc:mysql://localhost:3306/phone, errorCode 0, state 08001\ncom.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server.\n\tat sun.reflect.GeneratedConstructorAccessor36.newInstance(Unknown Source)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat com.mysql.jdbc.Util.handleNewInstance(Util.java:404)\n\tat com.mysql.jdbc.Util.getInstance(Util.java:387)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:917)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:896)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:885)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:860)\n\tat com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2332)\n\tat com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2085)\n\tat com.mysql.jdbc.ConnectionImpl.<init>(ConnectionImpl.java:795)\n\tat com.mysql.jdbc.JDBC4Connection.<init>(JDBC4Connection.java:44)\n\tat sun.reflect.GeneratedConstructorAccessor27.newInstance(Unknown Source)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat com.mysql.jdbc.Util.handleNewInstance(Util.java:404)\n\tat com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:400)\n\tat com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:327)\n\tat com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1513)\n\tat com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1578)\n\tat com.alibaba.druid.pool.DruidDataSource$CreateConnectionThread.run(DruidDataSource.java:2451)\nCaused by: java.lang.NullPointerException\n\tat com.mysql.jdbc.ConnectionImpl.getServerCharset(ConnectionImpl.java:3005)\n\tat com.mysql.jdbc.MysqlIO.sendConnectionAttributes(MysqlIO.java:1916)\n\tat com.mysql.jdbc.MysqlIO.proceedHandshakeWithPluggableAuthentication(MysqlIO.java:1845)\n\tat com.mysql.jdbc.MysqlIO.doHandshake(MysqlIO.java:1215)\n\tat com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2255)\n\tat com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2286)\n\t... 12 more\n\n```\n\n\n\n## 解决方案:\n\nMysql是8.0版本的 ,但是项目中用的jdbc驱动包5.1.31,将jdbc驱动包改为8.0.13后不再报错","tags":["MYSQL"]},{"title":"Spring Boot 整合mybatis","url":"/2019/03/29/Spring-Boot-整合mybatis/","content":"\n Spring Boot 整合mybatis\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 创建项目   pom.xml中添加依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.1.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.caicai</groupId>\n\t<artifactId>12-spring-boot-springmvc-mybatis</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>12-spring-boot-springmvc-mybatis</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-thymeleaf</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.spring.boot</groupId>\n\t\t\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t\t\t<version>2.0.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>1.1.8</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n## 创建application.yml\n\n```xml\nspring:\n  datasource:\n    driver-class-name: com.mysql.jdbc.Driver\n    username: root\n    password: 123456\n    url: jdbc:mysql://localhost:3306/ssm\n    type: com.alibaba.druid.pool.DruidDataSource\nmybatis:\n  type-aliases-package: com.caicai.springbootspringmvcmybatis.pojo\n  mapper-locations: classpath:mapper/*.xml\n```\n\n## 创建Users类\n\n```java\npackage com.caicai.springbootspringmvcmybatis.pojo;\n\npublic class Users {\n\n    private Integer id;\n    private String name;\n    private Integer age;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n\n```\n\n\n\n## 创建Controller\n\n```java\npackage com.caicai.springbootspringmvcmybatis.controller;\n\nimport com.caicai.springbootspringmvcmybatis.pojo.Users;\nimport com.caicai.springbootspringmvcmybatis.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n/**\n * @author liu\n * @title: Controller\n * @projectName 12-spring-boot-springmvc-mybatis\n * @description: TODO\n * @date 2019/3/3113:01\n */\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n    @Autowired\n    private UserService userService;\n    @RequestMapping(\"/{page}\")\n    public String showPage(@PathVariable String page){\n        return page;\n    }\n    @RequestMapping(\"/addUser\")\n    @ResponseBody\n    public String addUser(Users user){\n        userService.addUser(user);\n        return \"success\";\n    }\n}\n\n```\n\n## 创建 UserMapper接口和UsersMapper.xml(创建路径在resources/mapper下)\n\n```\npackage com.caicai.springbootspringmvcmybatis.mapper;\n\n\nimport com.caicai.springbootspringmvcmybatis.pojo.Users;\n\npublic interface UsersMapper {\n\t\n\tvoid insertUser(Users users);\n}\n\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\nPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.caicai.springbootspringmvcmybatis.mapper.UsersMapper\">\n\t<insert id=\"insertUser\" parameterType=\"users\">\n\t\tinsert into users(name,age) values(#{name},#{age})\n\t</insert>\n</mapper>\n```\n\n## 创建Service\n\n```java\npackage com.caicai.springbootspringmvcmybatis.service;\n\nimport com.caicai.springbootspringmvcmybatis.pojo.Users;\n\n/**\n * @author liu\n * @title: UserService\n * @projectName 12-spring-boot-springmvc-mybatis\n * @description: TODO\n * @date 2019/3/3112:16\n */\npublic interface UserService {\n    void addUser(Users users);\n}\n\n```\n\n```java\npackage com.caicai.springbootspringmvcmybatis.service;\n\nimport com.caicai.springbootspringmvcmybatis.mapper.UsersMapper;\nimport com.caicai.springbootspringmvcmybatis.pojo.Users;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n/**\n * @author liu\n * @title: UserServiceImpl\n * @projectName 12-spring-boot-springmvc-mybatis\n * @description: TODO\n * @date 2019/3/3112:25\n */\n@Service\n@Transactional\npublic class UserServiceImpl implements  UserService{\n    @Autowired\n    private UsersMapper usersMapper;\n    @Override\n    public void addUser(Users users) {\n        this.usersMapper.insertUser(users);\n    }\n}\n\n```\n\n## 创建page.html\n\n```html\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<form th:action=\"@{/users/addUser}\" method=\"post\">\n用户姓名<input type=\"text\" name=\"name\"><br>\n用户年龄<input type=\"text\" name=\"age\"><br>\n<input type=\"submit\" th:value=\"确定\"><br>\n\n</form>\n\n</body>\n</html>\n```\n\n## 创建启动类:\n\n```java\npackage com.caicai.springbootspringmvcmybatis;\n\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n@MapperScan(\"com.caicai.springbootspringmvcmybatis.mapper\")\npublic class Application {\n\n   public static void main(String[] args) {\n      SpringApplication.run(Application.class, args);\n   }\n\n}\n```\n\n\n\n\n\n","tags":["Spring Boot","Mybatis"]},{"title":"thymeleaf的整合和使用","url":"/2019/03/29/thymeleaf基本语法/","content":"\nThymeleaf是用于Web和独立环境的现代服务器端Java模板引擎。Thymeleaf的主要目标是将优雅的自然模板带到您的开发工作流程中—HTML能够在浏览器中正确显示，并且可以作为静态原型，从而在开发团队中实现更强大的协作。Thymeleaf能够处理HTML，XML，JavaScript，CSS甚至纯文本。\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 整合thymeleaf\n\n## 修改pom.xml文件,添加依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.1.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.caicai</groupId>\n\t<artifactId>10-spring-boot-view-thymeleaf</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>10-spring-boot-view-thymeleaf</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-thymeleaf</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n## 编写视图:\n\n在templates/ 下建立 userList2.html:\n\n```html\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\">\n<head>\n    <title>index</title>\n</head>\n<body>\n<table border=\"1\" align=\"center\" width=\"50%\">\n    <tr>\n        <th>ID</th>\n        <th>Name</th>\n        <th>Age</th>\n    </tr>\n\n    <tr th:each=\"user:${list}\">\n        <td th:text=\"${user.userid}\"></td>\n        <td th:text=\"${user.username}\"></td>\n        <td th:text=\"${user.userage}\"></td>\n    </tr>\n\n</table>\n</body>\n</html>\n```\n\n## 创建Controller\n\n```java\npackage com.caicai.springbootviewfreemarker.controller;\n\nimport com.caicai.springbootviewfreemarker.pojo.Users;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author liu\n * @title: UserController\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2820:06\n */\n@Controller\npublic class UserController {\n    @RequestMapping(\"/showuser2\")\n    public String index(Model model){\n        List<Users> list = new ArrayList<>();\n        list.add(new Users(1,\"caicai\",21));\n        list.add(new Users(2,\"honghong\",32));\n        list.add(new Users(3,\"mingming\",43));\n        model.addAttribute(\"list\",list);\n        return \"userList2\";\n    }\n}\n\n```\n\n## 创建Users类:\n\n```java\npackage com.caicai.springbootviewfreemarker.pojo;\n\n/**\n * @author liu\n * @title: Users\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2820:06\n */\npublic class Users {\n    private Integer userid;\n    private String username;\n    private Integer userage;\n\n\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Integer getUserage() {\n        return userage;\n    }\n\n    public void setUserage(Integer userage) {\n        this.userage = userage;\n    }\n\n    public Users() {\n    }\n\n    public Integer getUserid() {\n        return userid;\n    }\n\n    public void setUserid(Integer userid) {\n        this.userid = userid;\n    }\n\n    public Users(Integer userid, String username, Integer userage) {\n        this.userid = userid;\n        this.username = username;\n        this.userage = userage;\n    }\n}\n\n\n```\n\n## 创建启动类\n\n```java\npackage com.caicai.springbootviewfreemarker;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n\n```\n\n\n\n# thymeleaf基本语法:\n\n## 变量输出与字符串操作\n\n### th:text\n\n在页面中输出值\n\n### th:value\n\n可以将一个值放入到 input 标签的 value 中\n\n### 判断字符串是否为空\nThymeleaf 内置对象\n注意语法：\n1，调用内置对象一定要用#\n2，大部分的内置对象都以 s 结尾 strings、numbers、dates\n\n```\n${#strings.isEmpty(key)}\n判断字符串是否为空，如果为空返回 true，否则返回 false\n${#strings.contains(msg,'T')}\n判断字符串是否包含指定的子串，如果包含返回 true，否则返回 false\n${#strings.startsWith(msg,'a')}\n判断当前字符串是否以子串开头，如果是返回 true，否则返回 false\n${#strings.endsWith(msg,'a')}\n判断当前字符串是否以子串结尾，如果是返回 true，否则返回 false\n${#strings.length(msg)}\n返回字符串的长度\n${#strings.indexOf(msg,'h')}\n查找子串的位置，并返回该子串的下标，如果没找到则返回-1\n${#strings.substring(msg,13)}\n${#strings.substring(msg,13,15)}\n截取子串，用户与 jdk String 类下 SubString 方法相同\n${#strings.toUpperCase(msg)}\n${#strings.toLowerCase(msg)}\n字符串转大小写。\n```\n\n\n\n## 日期格式化处理\n\n```\n${#dates.format(key)}\n格式化日期，默认的以浏览器默认语言为格式化标准\n${#dates.format(key,'yyy/MM/dd')}\n按照自定义的格式做日期转换\n${#dates.year(key)}\n${#dates.month(key)}\n${#dates.day(key)}\nyear：取年\nMonth：取月\nDay：取日    \n\n```\n\n## 条件判断\n\n### th:if\n\n```html\n<span th:if=\"${sex} == '男'\">\n    性别男\n</span>\n<span th:if=\"${sex} == '女'\">\n    性别女\n</span>\n```\n\n### th:switch\n\n```html\n<span th:switch=\"${id}\">\n    <span th:case=\"1\">ID 为1</span>\n    <span th:case=\"2\">ID 为2</span>\n    <span th:case=\"2\">ID 为3</span>\n</span>\n```\n\n## 迭代遍历\n\n```html\n<table border=\"1\" align=\"center\" width=\"50%\">\n    <tr>\n        <th>ID</th>\n        <th>Name</th>\n        <th>Age</th>\n    </tr>\n\n    <tr th:each=\"user:${list}\">\n        <td th:text=\"${user.userid}\"></td>\n        <td th:text=\"${user.username}\"></td>\n        <td th:text=\"${user.userage}\"></td>\n    </tr>\n\n</table>\n```\n\n```java\n    @RequestMapping(\"/index\")\n    public String index(Model model){\n        List<Users> list = new ArrayList<>();\n        list.add(new Users(1,\"caicai\",21));\n        list.add(new Users(2,\"honghong\",32));\n        list.add(new Users(3,\"mingming\",43));\n        model.addAttribute(\"list\",list);\n        return \"index\";\n\n    }\n```\n\n状态变量属性\n1,index:当前迭代器的索引 从 0 开始\n2,count:当前迭代对象的计数 从 1 开始\n3,size:被迭代对象的长度\n4,even/odd:布尔值，当前循环是否是偶数/奇数 从 0 开始\n5,first:布尔值，当前循环的是否是第一条，如果是返回 true 否则返回 false\n6,last:布尔值，当前循环的是否是最后一条，如果是则返回 true 否则返回 false\n\n### th:each 迭代Map\n\n```html\n<table border=\"1\">\n    <tr>\n        <th>ID</th>\n        <th>Name</th>\n        <th>Age</th>\n    </tr>\n    <tr th:each=\"maps : ${map}\">\n        <td th:text=\"${maps}\"></td>\n    </tr>\n</table>\n<th/>\n<table border=\"1\">\n    <tr>\n        <th>ID</th>\n        <th>Name</th>\n        <th>Age</th>\n    </tr>\n    <tr th:each=\"maps : ${map}\">\n        <td th:each=\"entry:${maps}\"\n            th:text=\"${entry.value.id}\" ></td>\n        <td th:each=\"entry:${maps}\"\n            th:text=\"${entry.value.name}\"></td>\n        <td th:each=\"entry:${maps}\"\n            th:text=\"${entry.value.age}\"></td>\n    </tr>\n</table>\n```\n\n```java\n\n    @RequestMapping(\"/index3\")\n    public String index3(Model model){\n        Map<String, User> map = new HashMap<>();\n        map.put(\"u1\", new User(1,\"张三\",20));\n        map.put(\"u2\", new User(2,\"李四\",22));\n        map.put(\"u3\", new User(3,\"王五\",24));\n        model.addAttribute(\"map\", map);\n        return \"index3\" ;\n    }\n```\n\n\n\n## 域对象操作\n\n```java\n    @RequestMapping(\"/index4\")\n    public String index4(HttpServletRequest httpServletRequest, Model model){\n        httpServletRequest.setAttribute(\"req\",\"HttpServletRequest\");\n        httpServletRequest.getSession().setAttribute(\"sess\",\"HttpSession\");\n        httpServletRequest.getSession().getServletContext().setAttribute(\"app\",\"Application\");\n        return \"index4\" ;\n    }\n```\n\n```html\n<body>\n<span th:text=\"${#httpServletRequest.getAttribute('req')}\"></span><br>\n<span th:text=\"${session.sess}\"></span><br>\n<span th:text=\"${application.app}\"></span><br>\n</body>\n```\n\n## URL表达式\n\nth:href\nth:src\n\n### URL表达式语法\n\n基本语法：@{}\n\n### URL类型\n\n#### 绝对路径\n\n```html\n<a th:href=\"@{http://www.baidu.com}\">绝对路径</a><br/>\n```\n\n#### 相对路径\n\n1)相对于当前项目的根\n相对于项目的上下文的相对路径\n\n```html\n<a th:href=\"@{/show}\">相对路径</a>\n```\n\n2) 相对于服务器路径的根\n\n```html\n<a th:href=\"@{~/project2/resourcename}\">相对于服务器的根</a>\n```\n\n### 在 url  中实现参数传递\n\n```html\n<a th:href=\"@{/show(id=1,name=zhagnsan)}\">相对路径-传参</a>\n```\n\n###   在 url  中通过 restful  风格进行参数传递\n\n```html\n<a th:href=\"@{/path/{id}/show(id=1,name=zhagnsan)}\"> 相 对 路 径 - 传 参\n-restful</a>\n```\n\n","tags":["Spring Boot","thymeleaf"]},{"title":"Spring Boot 整合Freemarker","url":"/2019/03/28/Spring-Boot-整合Freemarker/","content":"\nFreeMarker 是一个模板引擎，一个基于模板生成文本输出的通用工具，使用纯 Java 编写，FreeMarker 被设计用来生成 HTML Web 页面，特别是基于 MVC 模式的应用程序，虽然 FreeMarker 具有一些编程的能力，但通常由 Java 程序准备要显示的数据，由FreeMarker 生成页面，通过模板显示准备的数据。符合MVC模式，采用哈希表存储，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据\n\n\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 整合Freemarker \n\n## 创建maven项目,添加依赖\n\n```xml\n<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-freemarker</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n```\n\n## 编写视图\n\n在templates/ 下建立 userList.ftl:\n\n```html\n<html>\n\t\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<title>显示用户数据</title>\n\t</head>\n\t<body>\n\t\t<table border=\"1\" align=\"center\" width=\"50%\">\n\t\t\t<tr>\n\t\t\t\t<th>ID</th>\n\t\t\t\t<th>Name</th>\n\t\t\t\t<th>Age</th>\n\t\t\t</tr>\n\n            <#list list as user>\n                <tr>\n                    <td>${user.userid}</td>\n                    <td>${user.username}</td>\n                    <td>${user.userage}</td>\n                </tr>\n            </#list>\n\n\t\t</table>\n\t</body>\n</html>\n\n```\n\n## 创建Controller\n\n```java\npackage com.caicai.springbootviewfreemarker.controller;\n\nimport com.caicai.springbootviewfreemarker.pojo.Users;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author liu\n * @title: UserController\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2820:06\n */\n@Controller\npublic class UserController {\n    /**\n     * 处理请求 产生数据\n     */\n    @RequestMapping(\"/showuser\")\n    public String showUser(Model model){\n        List<Users> list = new ArrayList<>();\n        list.add(new Users(1,\"caicai\",21));\n        list.add(new Users(2,\"honghong\",32));\n        list.add(new Users(3,\"mingming\",43));\n        model.addAttribute(\"list\",list);\n        return \"userList\";\n\n    }\n}\n\n```\n\n## 创建Uesrs类\n\n```java\npackage com.caicai.springbootviewfreemarker.pojo;\n\n/**\n * @author liu\n * @title: Users\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2820:06\n */\npublic class Users {\n    private Integer userid;\n    private String username;\n    private Integer userage;\n\n\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Integer getUserage() {\n        return userage;\n    }\n\n    public void setUserage(Integer userage) {\n        this.userage = userage;\n    }\n\n    public Users() {\n    }\n\n    public Integer getUserid() {\n        return userid;\n    }\n\n    public void setUserid(Integer userid) {\n        this.userid = userid;\n    }\n\n    public Users(Integer userid, String username, Integer userage) {\n        this.userid = userid;\n        this.username = username;\n        this.userage = userage;\n    }\n}\n\n```\n\n## 创建启动类\n\n```java\npackage com.caicai.springbootviewfreemarker;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n\n```\n\n","tags":["Spring Boot"]},{"title":"Spring Boot 整合jsp","url":"/2019/03/28/Spring-Boot-整合jsp/","content":"\n Spring Boot 整合jsp\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 创建maven项目,添加pom依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.1.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.caicai</groupId>\n\t<artifactId>08-spring-boot-view-jsp</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>08-spring-boot-view-jsp</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\n        <!-- tomcat支持 -->\n        <dependency>\n            <groupId>org.apache.tomcat.embed</groupId>\n            <artifactId>tomcat-embed-jasper</artifactId>\n        </dependency>\n        <!-- jstl标签库 -->\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>jstl</artifactId>\n        </dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n\n\n## 创建SpringBoot全局配置\n\napplication.yml:\n\n```xml\nspring:\n  mvc:\n    view:\n      prefix: /WEB-INF/jsp/\n      suffix: .jsp\n```\n\n## 创建Users类\n\n```java\npackage com.caicai.springbootviewjsp.pojo;\n\n/**\n * @author liu\n * @title: Users\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2813:16\n */\npublic class Users {\n    private Integer userid;\n    private String username;\n    private Integer userage;\n\n\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Integer getUserage() {\n        return userage;\n    }\n\n    public void setUserage(Integer userage) {\n        this.userage = userage;\n    }\n\n    public Users() {\n    }\n\n    public Integer getUserid() {\n        return userid;\n    }\n\n    public void setUserid(Integer userid) {\n        this.userid = userid;\n    }\n\n    public Users(Integer userid, String username, Integer userage) {\n        this.userid = userid;\n        this.username = username;\n        this.userage = userage;\n    }\n}\n\n```\n\n\n\n## 创建Controller\n\n```java\npackage com.caicai.springbootviewjsp.controller;\n\nimport com.caicai.springbootviewjsp.pojo.Users;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author liu\n * @title: UserController\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2813:15\n */\n@Controller\npublic class UserController {\n    /**\n     * 处理请求 产生数据\n     */\n    @RequestMapping(\"/showuser\")\n    public String showUser(Model model){\n        List<Users> list = new ArrayList<>();\n        list.add(new Users(1,\"caicai\",21));\n        list.add(new Users(2,\"honghong\",32));\n        list.add(new Users(3,\"mingming\",43));\n        model.addAttribute(\"list\",list);\n        return \"userList\";\n\n    }\n}\n\n```\n\n\n\n## 创建jsp\n\nuserList.jsp:\n\n```xml\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n         pageEncoding=\"UTF-8\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Insert title here</title>\n</head>\n<body>\n    <table border=\"1\" align=\"center\" width=\"50%\">\n        <tr>\n            <th>ID:</th>\n            <th>姓名:</th>\n            <th>年龄</th>\n\n        </tr>\n        <c:forEach items=\"${list}\" var=\"user\">\n        <tr>\n            <td>${user.userid}</td>\n            <td>${user.username}</td>\n            <td>${user.userage}</td>\n        </tr>\n\n\n        </c:forEach>\n    </table>\n</body>\n</html>\n```\n\n\n\n## 创建启动类:\n\n```java\npackage com.caicai.springbootviewjsp;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n\n```\n\n\n\n## 效果图:\n\n![](/Spring-Boot-整合jsp/1.png)","tags":["Spring Boot"]},{"title":"Spring-Boot-文件上传","url":"/2019/03/27/Spring-Boot-文件上传/","content":"\nSpring-Boot-文件上传\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 编写Controller\n\n```java\npackage com.caicai.springbootstaticresources1.controller;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * @author liu\n * @title: FileController\n * @projectName 05-spring-boot-static-resources1\n * @description: TODO\n * @date 2019/3/2719:04\n */\n@RestController\npublic class FileController {\n\n    @RequestMapping(value = \"/fileUploadController\")\n    public String fileUpload(@RequestParam(\"filename\") MultipartFile file){\n        System.out.println(file.getName());\n        try {\n            file.transferTo(new File(\"F:/\"+file.getName()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"success\";\n    }\n}\n\n```\n\n## 编写上传界面\n\n为了方便在static文件夹下建立upload.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>文件上传</title>\n</head>\n<body>\n    <form action=\"fileUploadController\" method=\"post\" enctype=\"multipart/form-data\">\n        上传文件:<input type=\"file\" name=\"filename\">\n        <input type=\"submit\">\n    </form>\n</body>\n</html>\n```\n\n## 设置上传文件大小的默认值\n\n在resources下建立application.yml文件\n\n```xml\nspring:\n  servlet:\n    multipart:\n      max-file-size: 10MB   #设置单个上传文件的大小\n      max-request-size: 100MB  #设置一次请求上传文件的总容量\n      enabled: true\n```\n\n","tags":["Spring Boot"]},{"title":"Spring-Boot 整合Servlet和Filter","url":"/2019/03/27/Spring-Boot-整合Servlet/","content":"\nSpring-Boot 整合Servlet和Filter\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 整合Servlet\n\n## 传统方式配置\n\n```xml\n\n<servlet>\n<servlet-name>FirstServlet</servlet-name>\n<servlet-class>com.caicai.springbootservlet.filter.FirstFilter</servlet-class>\n</servlet>\n\n<servlet-mapping>\n<servlet-name>FirstServlet</servlet-name>\n<url-pattern>/first</url-pattern>\n</servlet-mapping>\n\n```\n\n## 通过注解扫描注册Servlet\n\n使用@WebServlet注解并在启动类上使用@ServletComponentScan注解\n\n```java\n@WebServlet(name = \"FirstServlet\",urlPatterns = \"/first\")\npublic class FirstServlet extends HttpServlet{\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"FirstServlet.....\");\n    }\n}\n```\n\n```java\n@SpringBootApplication\n@ServletComponentScan //在SpringBoot启动时会扫描@WebServlet注解 并将该类实例化\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n```\n\n## 通过方法完成Servlet组件的注册\n\n通过使用@Bean注解的形式注册组件\n\n```java\npublic class SecondServlet extends HttpServlet{\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"SecondServlet.....\");\n    }\n}\n```\n\n```java\n@SpringBootApplication\npublic class App2 {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Bean\n    public ServletRegistrationBean getServletRegistrationBean() {\n        ServletRegistrationBean bean = new ServletRegistrationBean(new SecondServlet());\n        bean.addUrlMappings(\"/second\");//添加url路径\n        return bean;\n    }\n}\n```\n\n\n\n\n\n# 整合Filter\n\n## 传统方式配置\n\n```xml\n<filter>\n<filter-name>FirstFilter</filter-name>\n<filter-class>com.caicai.springbootservlet.filter.FirstFilter</filter-class>\n</filter>\n<filter-mapping>\n<filter-name>FirstFilter</filter-name>\n<url-pattern>/filter1</url-pattern>\n</filter-mapping>\n\n```\n\n\n\n## 通过注解扫描注册Servlet\n\n```java\npackage com.caicai.springbootservlet.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n/**\n * @author liu\n * @title: FirstFilter\n * @projectName 02-spring-boot-servlet\n * @description: TODO\n * @date 2019/3/2718:19\n */\n//@WebFilter(filterName = \"\",urlPatterns ={\"*.do\",\"*.jsp\"})\n@WebFilter(filterName = \"FirstFilter\",urlPatterns =\"/filter1\")\npublic class FirstFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println(\"init.......\");\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"进入filter.......\");\n        filterChain.doFilter(servletRequest,servletResponse);\n        System.out.println(\"离开filter.......\");\n\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(\"destroy.......\");\n\n    }\n}\n\n```\n\n启动类:\n\n````java\npackage com.caicai.springbootservlet;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.web.servlet.ServletComponentScan;\n\n@SpringBootApplication\n@ServletComponentScan //在SpringBoot启动时会扫描@WebServlet注解 并将该类实例化\npublic class App3 {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(App3.class, args);\n\t}\n\n}\n\n````\n\n## 通过方法完成Filter的注册\n\n```java\npackage com.caicai.springbootservlet.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n/**\n * @author liu\n * @title: SecondFilter\n * @projectName 02-spring-boot-servlet\n * @description: TODO\n * @date 2019/3/2718:19\n */\n\npublic class SecondFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println(\"init.......\");\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"进入filter2.......\");\n        filterChain.doFilter(servletRequest,servletResponse);\n        System.out.println(\"离开filter2.......\");\n\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(\"destroy.......\");\n\n    }\n}\n\n```\n\n```java\npackage com.caicai.springbootservlet;\n\nimport com.caicai.springbootservlet.filter.SecondFilter;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\n\n@SpringBootApplication\npublic class App4 {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(App4.class, args);\n\t}\n\n\t@Bean\n\tpublic FilterRegistrationBean filterRegistrationBean(){\n        FilterRegistrationBean bean = new FilterRegistrationBean(new SecondFilter()) ;\n        bean.addUrlPatterns(\"/filter2\");\n        return bean;\n    }\n\n}\n```\n\n","tags":["Spring Boot","Servlet"]},{"title":"String，StringBuilder，StringBuffer三者的区别","url":"/2019/03/26/string相关/","content":"\n最近突然被问起String，StringBuilder，StringBuffer三者的区别,发现自己确实对这方面的知识不是很了解.所以学习了一下做个笔记.\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## String\n\n+ String 类是一个常量，String类本身和其中存储字符的数组都是用final关键字修饰的,所以不能被继承\n\n```java\n    /** The value is used for character storage. */\n    private final char value[];\n```\n\n### String str=\"hello world\"和String str=new String(\"hello world\")的区别\n\n\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        String string1 = \"hello word\";\n        String string2 = new String(\"hello world\");\n        String string3 = \"hello word\";\n        String string4 = new String(\"hello world\");\n        System.out.println(string1 == string2);\n        System.out.println(string1 == string3);\n        System.out.println(string2 == string4);\n    }\n}\n\n```\n\n上面代码的输出结果为:\n\nfalse\n\ntrue\n\nfalse\n\n我们发现 同样都都是\"helllo world\" string1 和 string3 相等.是因为string1 和 string3 都是赋值为一个字面常量\"hello world\",在JVM运行时候,会在常量池里寻找是否已经存在相同的常量,如果存在便直接将引用指向已有常量,否则就创建一个常量,并且将引用指向他,对于string2 和string4来说,两者都是采取了new 来创建的,是两个不同的对象,所以不相等.\n\n## StringBuilder\n\n\n\n在第二点中,我们看到String是一个final类,打开StringBuilder,我们发现StringBuilder类是AbstractStringBuilder的子类,在AbstractStringBuilder类中,我们看到与String不同,StringBuilder存储字符的数组是可变的\n\n```java\n  /**\n     * The value is used for character storage.\n     */\n    char[] value;\n```\n\n## StringBuilder和String 区别\n\n\n\n对于实际应用来说 假设有如下代码\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        String string = \"\";\n        for (int i = 0; i < 1000; i++) {\n            string += \"A\";\n        }\n\n\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i < 1000; i++) {\n            stringBuilder.append(\"A\");\n        }\n    }\n}\n\n```\n\n上述代码进行了一个1000次的循环,每次在字符串string后面追加一个字符A,无论使用的是String,还是StringBuilder,最后的结果都为长度为1000的字符全为A的字符串.而不同的是,如果使用StringBuilder,append操作是在原有的对象基础上进行的,而使用String每次循环都会新建一个StringBuilder对象,进行append操作,通过toString方法返回String对象,如果这些对象没有被回收会浪费大量资源,\n\n## StringBuilder和StringBuffer区别\n\n对比StringBuilder和StringBuffer源码,我们发现在StringBuffer中很多方法都加上了synchronized关键字,所以StringBuffer是线程安全的,不过相应的,在提升了安全的同时对资源的消耗也会增大\n\n```java\n        /**\n         * StringBuffer append方法\n         */\n        @Override\n        public synchronized StringBuffer append (String str){\n            toStringCache = null;\n            super.append(str);\n            return this;\n        }\n        \n        /**\n         * StringBuilder append方法\n         */\n\n        @Override\n        public StringBuilder append (String str){\n            super.append(str);\n            return this;\n        }\n```\n\n## 结论\n\n三个类应当根据不同的情况来进行选择使用：\n\n当字符串相加操作或者改动较少的情况下，建议使用 String str=\"hello\"这种形式\n\n当字符串相加操作较多的情况下，建议使用StringBuilder\n\n如果采用了多线程，则使用StringBuffer。\n\n","tags":["java","String"]},{"title":"swagger2简介","url":"/2019/03/19/swagger2简介/","content":"\nSwagger 是一款RESTFUL接口的、基于YAML、JSON语言的文档在线自动生成、代码自动生成的工具。\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 关于Swagger\n\n\n\nSwagger能成为最受欢迎的REST APIs文档生成工具之一，有以下几个原因：\n\n- Swagger 可以生成一个具有互动性的API控制台，开发者可以用来快速学习和尝试API。\n- Swagger 可以生成客户端SDK代码用于各种不同的平台上的实现。\n- Swagger 文件可以在许多不同的平台上从代码注释中自动生成。\n- Swagger 有一个强大的社区，里面有许多强悍的贡献者。\n\nSwagger 文档提供了一个方法，使我们可以用指定的 JSON 或者 YAML 摘要来描述你的 API，包括了比如 names、order 等 API 信息。\n\n你可以通过一个文本编辑器来编辑 Swagger 文件，或者你也可以从你的代码注释中自动生成。各种工具都可以使用 Swagger 文件来生成互动的 API 文档。\n\n> 注意：用 Swagger 文件生成互动的 API 文档是最精简的，它展示了资源、参数、请求、响应。但是它不会提供你的API如何工作的其他任何一个细节。\n\n## Spring Boot集成使用Swagger\n\n### 创建Spring Boot Web工程并且引入Swagger依赖\n\n所需Swagger依赖可以在[Maven仓库](https://mvnrepository.com/) 中找查询\n\n```xml\n        <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 -->\n        <dependency>\n            <groupId>io.springfox</groupId>\n            <artifactId>springfox-swagger2</artifactId>\n            <version>2.9.2</version>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui -->\n        <dependency>\n            <groupId>io.springfox</groupId>\n            <artifactId>springfox-swagger-ui</artifactId>\n            <version>2.9.2</version>\n        </dependency>\n\n```\n\n### 创建User实体类\n\n```java\npackage com.example.demo.domain;\n\n/**\n * @author liu\n * @title: User\n * @projectName demo\n * @description: TODO\n * @date 2019/3/1821:52\n */\npublic class User {\n    private Long id;\n    private String username;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                '}';\n    }\n}\n\n```\n\n### 在启动类目录创建Swagger2配置类\n\n```java\npackage com.example.demo;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n@Configuration\n@EnableSwagger2\npublic class Swagger2  {\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(\"com.example.demo.controller\"))//扫描controller下的包\n                .paths(PathSelectors.any())\n                .build();\n    }\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                .title(\"Spring Boot中使用Swagger2构建RESTful APIs\")\n                .description(\"swagger2 构建APIS\")\n                .version(\"1.0\")\n                .build();\n    }\n}\n```\n\n### 创建UserController类\n\n```java\npackage com.example.demo.controller;\n\nimport com.example.demo.domain.User;\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiImplicitParam;\nimport io.swagger.annotations.ApiImplicitParams;\nimport io.swagger.annotations.ApiOperation;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author liu\n * @title: HelloController\n * @projectName demo\n * @description: TODO\n * @date 2019/3/1821:48\n */\n@RestController\n@Api(tags = \"用户模块\")\n@RequestMapping(value = \"/user\")\npublic class UserController {\n    /**\n     * 此处为了方便直接用一个Map来模拟数据库进行操作\n     */\n    static Map<Long, User> userMap;\n\n    static {\n        userMap = new HashMap<>();\n        User user = new User();\n        user.setId((long) 10000);\n        user.setUsername(\"admin\");\n        userMap.put((long) 10000,user);\n    }\n\n    @ApiOperation(value = \"获取用户列表\")\n    @RequestMapping(value = \"list\", method = RequestMethod.GET)\n    public List<User> getUserList() {\n\n        return new ArrayList<User>(userMap.values());\n    }\n\n\n    @ApiOperation(value = \"创建用户\")\n    @ApiImplicitParams({@ApiImplicitParam(paramType = \"query\", name = \"id\", dataType = \"Long\", required = true, value = \"用户id\", defaultValue = \"10001\"),\n            @ApiImplicitParam(paramType = \"query\", name = \"username\", dataType = \"String\", required = true, value = \"用户名字\", defaultValue = \"菜菜\")\n    })\n    @RequestMapping(value = \"\", method = RequestMethod.POST)\n    public String postUser(User user) {\n\n        userMap.put(user.getId(),user);\n        return \"添加成功\";\n    }\n\n\n\n    @ApiOperation(value = \"获取用户\")\n    @ApiImplicitParam(paramType = \"query\", required = true, name = \"id\", dataType = \"Long\", value = \"用户id\")\n    @RequestMapping(value = \"\", method = RequestMethod.GET)\n    public User getUser(@RequestParam(\"id\") Long id) {\n        System.out.println(id);\n        return userMap.get(id);\n    }\n\n\n\n    @ApiOperation(value = \"更新用户\")\n    @ApiImplicitParams({@ApiImplicitParam(paramType = \"query\", name = \"id\", dataType = \"Long\", required = true, value = \"用户id\", defaultValue = \"10001\"),\n            @ApiImplicitParam(paramType = \"query\", name = \"username\", dataType = \"String\", required = true, value = \"用户名字\", defaultValue = \"菜菜\")\n    })\n    @RequestMapping(value = \"\", method = RequestMethod.PUT)\n    public String putUser(User user) {\n        userMap.put(user.getId(),user);\n        return \"更新成功\";\n    }\n\n\n    @ApiOperation(value = \"删除用户\")\n    @ApiImplicitParam(paramType = \"query\", required = true, name = \"id\", dataType = \"Long\", value = \"用户id\")\n    @RequestMapping(value = \"\", method = RequestMethod.DELETE)\n    public String deleteUser(@RequestParam(\"id\") Long id) {\n        userMap.remove(id);\n        return \"删除成功\";\n    }\n}\n\n```\n\n### 测试:\n\n主界面:\n\n![主界面](/swagger2简介/1.png)\n\n查询用户列表:\n\n![](/swagger2简介/2.png)\n\n创建用户:\n\n![](/swagger2简介/3.png)\n\n获取用户:\n\n![](/swagger2简介/4.png)\n\n删除用户:\n\n![](/swagger2简介/5.png)\n\n## 使用过程中遇到的问题\n\n(1)java.lang.NumberFormatException: For input string: \"\"\n\n在使用@ApiModelProperty注解在字段上时，如果字段的类型为Long或是int类型，那么程序启动后，访问swagger-ui.html的页面，程序会报错\n\njava.lang.NumberFormatException: For input string: \"\"\n在swagger的官方文档中介绍是一个bug；可以忽略这个错误，如果看着不爽，可以调整日志的级别\n\napplication.yml:\n\n```xml\nlogging:\n  level:\n    io.swagger.models.parameters.AbstractSerializableParameter: error\n```\n\n\n\n(2)@Api()注解中使用tags = \"\"参数才能改变api名字 例如@Api(tags = \"用户模块\")\n\n\n\n(3)requestparam 和pathvariable区别 :\n\n@PathVariable:从路径路去获取变量,也就是把路径名当作变量 例如:\n\n```xml\nhttp://localhost:8080/user?id=5\n```\n\n@RequestParam:从请求里面获取参数,例如:\n\n```xml\nhttp://localhost:8080/user?5\n```\n\n","tags":["Spring Boot","swagger"]},{"title":"mysql的时区错误问题： The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one","url":"/2019/03/18/mysql的时区错误问题：-The-server-time-zone-value-OÐ¹u±e×¼E±¼a-is-unrecognized-or-represents-more-than-one/","content":"\n链接数据库时候出现cexception is org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException:\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n## spring boot 链接数据库的时候报错\n\n```java\ncexception is org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: \n### Error querying database.  Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Connections could not be acquired from the underlying database!\n### The error may exist in com/wj/mapper/UserLoginMapper.xml\n### The error may involve com.wj.mapper.UserLoginMapper.selectByName\n### The error occurred while executing a query\n### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Connections could not be acquired from the underlying database!\n    org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:982)\n    org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872)\n    javax.servlet.http.HttpServlet.service(HttpServlet.java:650)\n    org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)\n    javax.servlet.http.HttpServlet.service(HttpServlet.java:731)\n```\n```java\njava.sql.SQLException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:127)\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:95)\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:87)\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:61)\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:71)\n    com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:76)\n    com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:862)\n    com.mysql.cj.jdbc.ConnectionImpl.<init>(ConnectionImpl.java:444)\n    com.mysql.cj.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:230)\n    com.mysql.cj.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:226)\n    com.mchange.v2.c3p0.DriverManagerDataSource.getConnection(DriverManagerDataSource.java:175)\n    com.mchange.v2.c3p0.WrapperConnectionPoolDataSource.getPooledConnection(WrapperConnectionPoolDataSource.java:220)\n    com.mchange.v2.c3p0.WrapperConnectionPoolDataSource.getPooledConnection(WrapperConnectionPoolDataSource.java:206)\n    com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool$1PooledConnectionResourcePoolManager.acquireResource(C3P0PooledConnectionPool.java:203)\n    com.mchange.v2.resourcepool.BasicResourcePool.doAcquire(BasicResourcePool.java:1138)\n    com.mchange.v2.resourcepool.BasicResourcePool.doAcquireAndDecrementPendingAcquiresWithinLockOnSuccess(BasicResourcePool.java:1125)\n    com.mchange.v2.resourcepool.BasicResourcePool.access$700(BasicResourcePool.java:44)\n    com.mchange.v2.resourcepool.BasicResourcePool$ScatteredAcquireTask.run(BasicResourcePool.java:1870)\n    com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread.run(ThreadPoolAsynchronousRunner.java:696)\n```\n## 解决方案:\n\n据查询是因为电脑的时区和mysql的时区不一样导致的\n用 打开mysql \n\n```sql\nshow variables like '%time_zone%'; //查询mysql的时区\nset global time_zone='+8:00'; //设置时区\n```","tags":["Spring Boot","MYSQL"]},{"title":"navicat 连接 mysql   Client does not support authentication protocol requested by server","url":"/2019/03/18/navicat-连接-mysql-Client-does-not-support-authentication-protocol-requested-by-server/","content":"\nClient does not support authentication protocol requested by server; consider upgrading MySQL client\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 报错信息:\n\n```java\nClient does not support authentication protocol requested by server; consider upgrading MySQL client\n```\n\n## 解决方案:\n\n打开mysql的MySQL Command Line Client 输入:\n```\nUSE mysql;\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';\nFLUSH PRIVILEGES; \n```\n\nlocalhost:本机地址\n123456:要设置的密码","tags":["MYSQL"]},{"title":"hexo 常用命令","url":"/2019/03/18/hexo-常用命令/","content":"\nhexo 的一些常用命令\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## hexo\n\n```\nnpm install hexo -g #安装  \nnpm update hexo -g #升级  \nhexo init #初始化\n```\n\n## 简写\n\n`hexo n \"我的博客\"` == `hexo new \"我的博客\"` #新建文章\n`hexo p` == `hexo publish`\n`hexo g` == `hexo generate`#生成\n`hexo s` == `hexo server` #启动服务预览\n`hexo d` == `hexo deploy`#部署\n\n## 服务器\n\n`hexo server` #Hexo 会监视文件变动并自动更新，您无须重启服务器。\n`hexo server -s` #静态模式\n`hexo server -p 5000` #更改端口\n`hexo server -i 192.168.1.1` #自定义 IP\n\n`hexo clean` #清除缓存 网页正常情况下可以忽略此条命令\n`hexo g` #生成静态网页\n`hexo d` #开始部署\n\n### 监视文件变动\n\n`hexo generate` #使用 Hexo 生成静态文件快速而且简单\n`hexo generate --watch` #监视文件变动\n\n### 完成后部署\n\n> 两个命令的作用是相同的\n> `hexo generate --deploy`\n> `hexo deploy --generate`\n\n```\nhexo deploy -g`\n`hexo server -g\n```\n\n## 草稿\n\n```\nhexo publish [layout] <title>\n```\n\n## 模版\n\n`hexo new \"postName\"` #新建文章\n`hexo new page \"pageName\"` #新建页面\n`hexo generate` #生成静态页面至public目录\n`hexo server` #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n`hexo deploy` #将.deploy目录部署到GitHub\n\n```\nhexo new [layout] <title>`\n`hexo new photo \"My Gallery\"`\n`hexo new \"Hello World\" --lang tw\n```\n\n| 变量   | 描述         |\n| ------ | ------------ |\n| layout | 布局         |\n| title  | 标题         |\n| date   | 文件建立日期 |\n\n```\ntitle: 使用Hexo搭建个人博客\nlayout: post\ndate: 2019-03-18 14:59:30\ncomments: true\ncategories: Blog\ntags: [Hexo]\nkeywords: Hexo, Blog\ndescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。\n```\n\n## 模版（Scaffold）\n\n```\nhexo new photo \"My Gallery\"\n```\n\n| 变量   | 描述         |\n| ------ | ------------ |\n| layout | 布局         |\n| title  | 标题         |\n| date   | 文件建立日期 |\n\n## 设置文章摘要\n\n```\n以上是文章摘要 <!--more--> 以下是余下全文 \n```\n\n## 写作\n\n```\nhexo new page <title>`\n`hexo new post <title>\n```\n\n| 变量     | 描述                       |\n| -------- | -------------------------- |\n| :title   | 标题                       |\n| :year    | 建立的年份（4 位数）       |\n| :month   | 建立的月份（2 位数）       |\n| :i_month | 建立的月份（去掉开头的零） |\n| :day     | 建立的日期（2 位数）       |\n| :i_day   | 建立的日期（去掉开头的零） |\n\n### 推送到服务器上\n\n```\nhexo n` #写文章\n`hexo g` #生成\n`hexo d` #部署 #可与`hexo g`合并为 `hexo d -g\n```\n\n## 报错\n\n### 1.找不到git部署\n\n```\nERROR Deployer not found: git\n```\n\n**解决方法**\n\n```\nnpm install hexo-deployer-git --save\n```\n\n### 3.部署类型设置git\n\nhexo 3.0 部署类型不再是`github`，`_config.yml` 中修改\n\n```\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@***.github.com:***/***.github.io.git\n  branch: master\n```\n\n### 4. xcodebuild\n\nxcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance\n\n```\nnpm install bcrypt\n```\n\n### 5. RSS不显示\n\n#### 安装RSS插件\n\n```\nnpm install hexo-generator-feed --save\n```\n\n#### 开启RSS功能\n\n编辑hexo/_config.yml，添加如下代码：\n\n```\nrss: /atom.xml #rss地址  默认即可\n```","tags":["hexo"]}]