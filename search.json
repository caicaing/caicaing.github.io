[{"title":"Java创建多线程的四种方式","url":"/2020/04/20/Java创建多线程的四种方式/","content":"\n介绍Java创建多线程的四种方式。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# Java创建多线程的四种方式\n\n## 继承Thread\n\nThread类本质上是实现了Runnable接口的一个实例。我们通过继承Thread类的方式，并重写run方法，可以创建自己的线程。调用start()方法可以启动线程。并不推荐使用继承Thread类的方式来创建线程对象：\n\n1、Java是单继承，继承了Thread类后不能再继承其他的类。\n\n2、通过继承的方式数据是线程独享的。\n\n```java\npackage com.caicai.threaddemo;\n\n/**\n * @Author: caicai\n * @Date: 2020/4/20\n * @Description:\n */\npublic class MyThreadTest1 {\n    public static void main(String[] args) {\n        Thread t1 = new Mythread1();\n        t1.start();\n\n    }\n\n}\nclass Mythread1 extends Thread{\n    @Override\n    public void run() {\n        System.out.println(\"继承Thread创建多线程\");\n    }\n}\n\n\n```\n\n\n\n## 实现Runnable接口\n\n相比于继承Thread类，使用Runnable更加灵活，即使是类已经继承了其他的父类，仍然可以通过实现Runnable来支持多线程。只需实现Runnable接口即可。\n\n```java\npackage com.caicai.threaddemo;\n\n/**\n * @Author: caicai\n * @Date: 2020/4/20\n * @Description:\n */\npublic class MyThreadTest2 {\n    public static void main(String[] args) {\n        Thread t2 = new Thread(new Mythread2());\n        t2.start();\n\n    }\n\n}\n\nclass Mythread2 implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"实现Runnable创建线程\");\n    }\n}\n\n\n```\n\n通过构造方法，将Thread类中的target对象赋值，并且在执行的时候调用target的run方法。\n\n```java\npublic Thread(Runnable target) {\n    this(null, target, \"Thread-\" + nextThreadNum(), 0);\n}\n```\n\n```java\n@Override\npublic void run() {\n    if (target != null) {\n        target.run();\n    }\n}\n```\n\n## 实现Callable接口\n\n在jdk1.5之后增加了Callable接口。Callable相对于Runnable有更强大的功能：\n\n+ 相比run方法，可以有返回值\n+ 方法可以抛出异常\n+ 支持泛型\n\n实现Callable接口的方式不再像前面两种创建Thread对象调用start方法进行执行，而是需要借助FutureTask的run方法来执行。同时调用FutureTask对象的get方法可以获取到线程执行时候的返回值。\n\n```java\npackage com.caicai.threaddemo;\n\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\n/**\n * @Author: caicai\n * @Date: 2020/4/20\n * @Description:\n */\npublic class MyThreadTest3 {\n    public static void main(String[] args) {\n        FutureTask<String> futureTask = new FutureTask(new Mythread3());\n        futureTask.run();\n        String s = null;\n        try {\n            s = futureTask.get();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n        System.out.println(s);\n    }\n\n}\n\nclass Mythread3 implements Callable<String> {\n    @Override\n    public String call() throws Exception {\n        System.out.println(\"实现Callable创建线程并返回一个值\");\n        return \"hello world\";\n    }\n}\n```\n\n\t## 创建线程池\n\nExecutors.newFixedThreadPool方法创建线程池。对于经常创建、销毁、使用量特别大的资源使用线程池可以很大的提升性能。线程池的基本思路为提前创建好多个线程，放入线程池中，使用的时候直接从线程池里获取，使用完再放回线程池中。使用的优势在于：\n\n+ 可以避免频繁的创建、销毁线程时对资源的浪费，提升响应速度，降低资源的消耗\n+ 便于线程的管理，可以通过设置参数来管理线程池中的线程\n\n《阿里巴巴java开发手册》中提到线程池不使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n\nExecutors 返回的线程池对象的弊端如下：\n\n+ FixedThreadPool 和 SingleThreadPool : 允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。\n\n+ CachedThreadPool 和 ScheduledThreadPool : 允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。\n\n```java\npackage com.caicai.threaddemo;\nimport java.util.concurrent.*;\n\n/**\n * @Author: caicai\n * @Date: 2020/4/20\n * @Description:\n */\npublic class MyThreadTest4 {\n    public static void main(String[] args) {\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(3, 7, 10, TimeUnit.SECONDS, new LinkedBlockingDeque<>(10));\n        threadPoolExecutor.execute(new Mythread4());\n    }\n\n}\n\nclass Mythread4 implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"使用线程池创建线程\");\n    }\n}\n\n```\n\nThreadPoolExecutor的构造方法如下\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n```\n\n| 名称            | 类型                     | 含义             |\n| --------------- | ------------------------ | ---------------- |\n| corePoolSize    | int                      | 核心线程池大小   |\n| maximumPoolSize | int                      | 最大线程数       |\n| keepAliveTime   | long                     | 线程最大空闲时间 |\n| unit            | TImeUnit                 | 时间单位         |\n| workQueue       | BlockingQueue<Runnable>  | 线程等待队列     |\n| threadFactory   | ThreadFactory            | 线程创建工厂     |\n| handler         | RejectedExecutionHandler | 拒绝策略         |\n\n","tags":["Java","多线程"]},{"title":"Java ArrayList","url":"/2020/03/15/Java-ArrayList/","content":"\nJava ArrayList\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# ArrayList\n\n## ArrayList简介\n\nArrayList就是动态数组，是Array的复杂版本。List 接口的大小可变数组的实现，位于API文档的java.util.ArrayList<E>。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。（此类大致上等同于 Vector 类，除了此类是不同步的）。\n\n## ArrayList 变量\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n```\n\nArrayList继承了AbstractList类，并且实现了一系列的接口。\n\n### DEFAULT_CAPACITY\n\n```java\nprivate static final int DEFAULT_CAPACITY = 10;\n```\n\n数组初始默认容量\n\n### EMPTY_ELEMENTDATA\n\n```java\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\n```\n\n用于空实例的共享空数组实例。\n\n### DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n\n```java\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n```\n\n默认数组初始化状态。\n\n### elementData\n\n```java\ntransient Object[] elementData; // non-private to simplify nested class access\n```\n\n数据的存储数组\n\n### size\n\n```javaj a\nprivate int size;\n```\n\n列表中实际存在的元素个数\n\n## ArrayList方法\n\n### 构造方法\n\n```java\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n```\n\n默认的构造方法，把存放数据的数组初始华为默认的数组，DEFAULTCAPACITY_EMPTY_ELEMENTDATA默认为空。\n\n```java\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n```\n\n此构造方法中，若传入的值合法，则将存放数据的数组长度设置为传入的值。\n\n```java\npublic ArrayList(Collection<? extends E> c) {\n    elementData = c.toArray();\n    if ((size = elementData.length) != 0) {\n        // defend against c.toArray (incorrectly) not returning Object[]\n        // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)\n        if (elementData.getClass() != Object[].class)\n            elementData = Arrays.copyOf(elementData, size, Object[].class);\n    } else {\n        // replace with empty array.\n        this.elementData = EMPTY_ELEMENTDATA;\n    }\n}\n```\n\n传入一个集合，把集合中的所有数据都拷贝到ArrayList的存储数组中。\n\n### contains(Object o)\n\n```java\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\n```\n\n判断List中是否包含某个对象，本质上是调用了indexOf方法\n\n### indexOf(Object o)\n\n```java\npublic int indexOf(Object o) {\n    return indexOfRange(o, 0, size);\n}\n```\n\n```java\nint indexOfRange(Object o, int start, int end) {\n    Object[] es = elementData;\n    if (o == null) {\n        for (int i = start; i < end; i++) {\n            if (es[i] == null) {\n                return i;\n            }\n        }\n    } else {\n        for (int i = start; i < end; i++) {//对象不为空，遍历存储数组，找到返回索引，否则-1\n            if (o.equals(es[i])) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n```\n\n\n\n### lastIndexOf(Object o)\n\n```java\npublic int lastIndexOf(Object o) {\n    return lastIndexOfRange(o, 0, size);\n}\n```\n\n从后往前寻找第一次出现的元素，本质上是反向遍历存储数组\n\n```java\nint lastIndexOfRange(Object o, int start, int end) {\n    Object[] es = elementData;\n    if (o == null) {\n        for (int i = end - 1; i >= start; i--) {\n            if (es[i] == null) {\n                return i;\n            }\n        }\n    } else {\n        for (int i = end - 1; i >= start; i--) {\n            if (o.equals(es[i])) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n```\n\n\n\n### clone() \n\n```java\npublic Object clone() {\n    try {\n        ArrayList<?> v = (ArrayList<?>) super.clone();\n        v.elementData = Arrays.copyOf(elementData, size);\n        v.modCount = 0;\n        return v;\n    } catch (CloneNotSupportedException e) {\n        // this shouldn't happen, since we are Cloneable\n        throw new InternalError(e);\n    }\n}\n```\n\n获得一个与当前链表一样的副本，深拷贝。\n\n### toArray()\n\n```java\npublic Object[] toArray() {\n    return Arrays.copyOf(elementData, size);\n}\n```\n\n将list转化为Object类型的数组\n\n```java\npublic <T> T[] toArray(T[] a) {\n    if (a.length < size)\n        // Make a new array of a's runtime type, but my contents:\n        return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n    System.arraycopy(elementData, 0, a, 0, size);\n    if (a.length > size)\n        a[size] = null;\n    return a;\n}\n```\n\n将list转化为传入类型的数组，当传入的数组长度小于链表数据长度时候，会返回一个新的数组，a不发生改变，当传入的数组长度大于等于链表数据长度时候，会直接将数据拷贝到a中并返回a。\n\n  System.arraycopy和Arrays.copyOf的区别：\n\n1. System.arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置\n2. Arrays.copyOf()是系统自动在内部新建一个数组，调用arraycopy()将original内容复制到copy中去，并且长度为newLength。返回copy; 即将原数组拷贝到一个长度为newLength的新数组中，并返回该数组。\n\nArray.copyOf()可以看作是受限的System.arraycopy(),它主要是用来将原数组全部拷贝到一个新长度的数组，适用于数组扩容。\n\n\n\n### get(int index) \n\n```java\npublic E get(int index) {\n    Objects.checkIndex(index, size); //判断index 是否越界\n    return elementData(index);\n\n```\n\n\n\n### set(int index, E element)\n\n```java\npublic E set(int index, E element) {\n    Objects.checkIndex(index, size);\n    E oldValue = elementData(index);\n    elementData[index] = element;\n    return oldValue;\n}\n```\n\nSet 方法将index位置的对象设置为传入的对象，并且返回原来的对象\n\n### add(E e)\n\n```java\npublic boolean add(E e) {\n    modCount++;//增加修改次数\n    add(e, elementData, size);\n    return true;\n}\n```\n\n```java\nprivate void add(E e, Object[] elementData, int s) {\n    if (s == elementData.length)\n        elementData = grow(); //数组空间满了 进行扩容\n    elementData[s] = e;\n    size = s + 1;\n}\n\n```\n\n扩容函数如下：\n\n```java\nprivate Object[] grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        int newCapacity = ArraysSupport.newLength(oldCapacity,\n                minCapacity - oldCapacity, /* minimum growth */\n                oldCapacity >> 1           /* preferred growth */);\n        return elementData = Arrays.copyOf(elementData, newCapacity);\n    } else {\n        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];\n    }\n}\n```\n\n### remove(int index) \n\n```java\npublic E remove(int index) {\n    Objects.checkIndex(index, size);//判断是否越界\n    final Object[] es = elementData;\n\n    @SuppressWarnings(\"unchecked\") E oldValue = (E) es[index];\n    fastRemove(es, index);\n    return oldValue;\n\n  \n```\n\n```java\nprivate void fastRemove(Object[] es, int i) {\n    modCount++;\n    final int newSize;\n    if ((newSize = size - 1) > i)\n        System.arraycopy(es, i + 1, es, i, newSize - i);//把i+1后的元素全部向前覆盖一个位置\n    es[size = newSize] = null;\n}\n```\n\n### size()\n\n\n\n```java\npublic int size() {\n    return size;\n}\n```\n\n获得List的长度\n\n### isEmpty()\n\n```java\npublic boolean isEmpty() {\n    return size == 0;\n}\n```\n\n判断List是否为空\n\n### trimToSize() \n\n```java\npublic void trimToSize() {\n    modCount++;\n    if (size < elementData.length) {\n        elementData = (size == 0)\n          ? EMPTY_ELEMENTDATA\n          : Arrays.copyOf(elementData, size);\n    }\n}\n```\n\n把数组长度改变为当前实际存在数据的大小。\n\n## ArrayList遍历\n\n```java\nprivate static void method04(ArrayList<Integer> arrayList) {\n    arrayList.forEach((i)->{\n        System.out.println(i);\n    });\n}\n\n\nprivate static void method03(ArrayList<Integer> arrayList) {\n    for (Integer integer : arrayList){\n        System.out.println(integer);\n    }\n}\n\nprivate static void method02(ArrayList<Integer> arrayList) {\n\n    Iterator<Integer> iterator = arrayList.iterator();\n    while (iterator.hasNext()){\n        Integer next = iterator.next();\n        System.out.println(next);\n    }\n}\n\nprivate static void method01(ArrayList<Integer> arrayList) {\n    for(int i = 0; i < arrayList.size(); i++){\n        System.out.println(arrayList.get(i));\n    }\n}\n```\n\n\n\n","tags":["Java","List"]},{"title":"HashMap源码分析","url":"/2020/03/10/HashMap源码分析/","content":"\nJava HashMap 源码分析 本文所使用jdk为jdk13\n\n<!-- more -->\n\n<The rest of contents | 余下全文>\n\n# HashMap源码分析\n\n\n\n## HashMap简介\n\n基于[哈希表](https://baike.baidu.com/item/哈希表/5981869)的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）\n\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable {}\n```\n\n从类的定义可以看到HashMap继承了AbstractMap类，并且实现了Map、Cloneable、Serializable接口\n\n## HashMap数据结构\n\n### 存储数组\n\n```java\nNode<K,V>[] table;\n```\n\n在java8后，使用Node类型的数组来存储键值对数据。Node是一个实现了Map.Entry接口的自定义类。\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {}\n```\n\nNode的主要参数有\n\n```java\nfinal int hash;\t//哈希值\nfinal K key;\t//键\nV value;\t//值\nNode<K,V> next;\t//连接的下一个节点\n```\n\n\n\n### 存储方式\n\n在java8之前，HashMap的存储方式为数组+链表，数组是HashMap的主体，链表（拉链法）是为了解决哈希碰撞（两个对象在经过哈希计算后得到的索引值相同）的情况。java8后HashMap的存储方式为数组+链表+红黑树。当HashMap中链表的长度大于8并且当前数组的长度大约64，则把索引位置上的链表转化为红黑树存储数据。提高了大量数据下的查找效率。\n\n## 重要参数\n\n\n\n### 默认初始容量\n\n```java\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n```\n\n默认的初始容量为16，规定了默认的初始容量为2的幂。\n\n### 最大容量\n\n```java\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n```\n\n最大容量为节点数组所能开辟的最大个数，如果指定了更大的值则使用最大容量的值。\n\n### 默认负载因子\n\n```java\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n```\n\n在构造函数中如果没有显式的指定负载因子的值则使用默认的负载因子值：0.75\n\n负载因子决定了HashMap的数据密度。负载因子越大数组装填的越满，发生碰撞的几率就会越高，负载因子越小，越容易触发扩容，经常扩容会影响程序性能。之所以选择0.75作为负载因子的默认值，根据源码中注释中所解释：\n\n在理想情况下，使用随机哈希吗，节点出现的频率在hash桶中遵循泊松分布，并且阈值为0.75，同时给出了桶中元素的个数和概率的对照表。\n\n```\n0:    0.60653066\n1:    0.30326533\n2:    0.07581633\n3:    0.01263606\n4:    0.00157952\n5:    0.00015795\n6:    0.00001316\n7:    0.00000094\n8:    0.00000006\n```\n\n\n\n### 将链表转为红黑树的节点数量阈值\n\n```java\nstatic final int TREEIFY_THRESHOLD = 8;\n```\n\n从上文桶中元素的个数和概率的对照表中可以看到，当桶中元素到达8个的时候，概率已经变得非常小，当链表的长度大于了8，并且数组长度大于64，为了查找效率就会把链表转化为红黑树。\n\n### 将红黑树转为链表的节点数量阈值\n\n```java\nstatic final int UNTREEIFY_THRESHOLD = 6;\n```\n\n当红黑树的节点个数小于6时，会把红黑树转化为链表存储\n\n### 可以对容器进行红黑树化处理的最小表容量\n\n```java\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n```\n\n### 键值对数量\n\n```java\ntransient int size;\n```\n\n表示HashMap中键值对的数量\n\n### 修改次数\n\n```java\ntransient int modCount;\n```\n\nmodCount是指改变HashMap中映射的数量或修改其内部结构(例如，重新散列)的次数。\n\n\n\n## 主要方法\n\n### 构造方法\n\njava8在构造方法中不再初始化Node数组的长度，而是在第一次put时初始化Node数组长度\n\n#### HashMap()\n\n```java\npublic HashMap() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n}\n```\n\n在默认构造方法中，将负载因子初始化为默认的值--0.75\n\n#### HashMap(int initialCapacity)\n\n```java\npublic HashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n```\n\n显式的定义了HashMap的存储数组的长度，并且使用默认的负载因子。但是此处并不是直接就将存储数组的长度设置为传入的initialCapacity值，而是经过一系列操作将长度设置为大于等于传入值，最接近传入值的2的指数幂。详细过程见下面一个构造函数\n\n#### HashMap(int initialCapacity, float loadFactor) \n\n```java\npublic HashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                           loadFactor);\n    this.loadFactor = loadFactor;\n    this.threshold = tableSizeFor(initialCapacity);\n}\n```\n\n在此构造函数中，首先判断传入的数组长度是否小于0，若小于0的抛出异常，若大于数组的最大长度则将其设置为最大长度。继而判断负载因子是否小于等于0或是否是一个非法的小数。经过了上述判断后将负载因子设置为传入的负载因子，之后执行tableSizeFor(initialCapacity)，tableSizeFor()方法如下：\n\n```java\nstatic final int tableSizeFor(int cap) {\n    int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n```\n\n在tableSizeFor()中执行了Integer.numberOfLeadingZeros()方法，Integer.numberOfLeadingZeros()方法如下：\n\n```java\npublic static int numberOfLeadingZeros(int i) {\n    // HD, Count leading 0's\n    if (i <= 0)\n        return i == 0 ? 32 : 0;\n    int n = 31;\n    if (i >= 1 << 16) { n -= 16; i >>>= 16; }\n    if (i >= 1 <<  8) { n -=  8; i >>>=  8; }\n    if (i >= 1 <<  4) { n -=  4; i >>>=  4; }\n    if (i >= 1 <<  2) { n -=  2; i >>>=  2; }\n    return n - (i >>> 1);\n}\n```\n\nnumberOfLeadingZeros方法的作用是返回无符号整型i的最高非零位前面的0的个数，包括符号位在内,如果i为负数，这个方法将会返回0，符号位为1。例如，\n\n10的二进制表示为 0000 0000 0000 0000 0000 0000 0000 1010\n\n那么这个方法返回的就是28。\n\ntableSizeFor()中\n\n```java\nint n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);\n```\n\ncap为传入的数组长度，假设cap = 11，那么Integer.numberOfLeadingZeros(cap - 1)的值为28。那么n相当于-1向右无符号移动28位\n\n```java\nint n = -1 >>> 28;\n```\n\n我们知道-1 的二进制为\n\n1111 1111 1111 1111 1111 1111 1111 1111\n\n向右移动28位后变成\n\n0000 0000 0000 0000 0000 0000 0000 1111\n\n则n = 15\n\n最后函数在return时候经过判断返回n+1即16。相当于把自定义的数组长度11变成了比11大的、最接近11的2的幂，即16。\n\n这里存在两个需要注意的点：\n\n1）Integer.numberOfLeadingZeros(cap - 1)中为什么传入的参数为cap-1?\n\n这是为了防止cap已经是2的幂，如果cap已经是2的幂，又没有执行减1的操作，则执行完一系列操作后返回的值会是cap值的两倍。\n\n2）为什么数组长度一定要是2的幂？\n\n因为在计算索引的时候 使用的是**(n - 1) & hash**来决定索引，当n为2次幂时，会满足一个公式：**(n - 1) & hash = hash % n**，在计算机中，位运算要比%取模要快，用位运算可以提高运算的效率。\n\n### resize() \n\nresize是HashMap中的扩容方法，为方便理解加了部分注释，resize()代码如下：\n\n```java\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;//保存扩容前table的引用\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;//保存老数组长度\n    int oldThr = threshold;//老数组存储阈值(容量*负载因子)\n    int newCap, newThr = 0;//定义新的数组大小、存储阈值大小\n    if (oldCap > 0) {\n      //当数组长度已大于最大数组长度，则返回原数组，并且将存储阈值设置为Integer的最大值\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n          //数组长度乘2后仍然小于最大数组长度，并且当前数组长度大于等于默认的数组长度则可扩容，将容量扩大为原来的两倍\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) \n        newCap = oldThr;\n    else {       // 当初始数组长度和初始存储阈值都为0时候，将他们赋值为默认值\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    if (newThr == 0) {//当只满足老阈值大于0的条件时，新阈值等于新容量*默认扩容因子\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];//创建新数组\n    table = newTab;\n  /**\n  ---------------------上述为扩容数组部分，下面为复制数据部分-----------------------\n  **/\n    if (oldTab != null) {\n        for (int j = 0; j < oldCap; ++j) {//遍历原来数组中的值\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;//把原来数组对应序号的值赋值为空 便于内存回收\n                if (e.next == null) //若当前节点没有下一个节点就证明是一个单独的数据直接计算新的位置赋值\n                    newTab[e.hash & (newCap - 1)] = e;//e.hash & (newCap - 1)的值为新的索引位置\n                else if (e instanceof TreeNode)//如果是红黑树，则按照红黑树进行操作 暂略\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // 当前位置是个链表\n                    Node<K,V> loHead = null, loTail = null; //保存不位移的链表\n                    Node<K,V> hiHead = null, hiTail = null; //保存位移的链表\n                    Node<K,V> next;\n                    do {//遍历\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {//此时oldCap已经是原来的两倍，如果与的结果为0，表示索引不位移\n                            if (loTail == null) // 如果索引对应位置为空直接赋值，\n                                loHead = e;\n                            else   // 否则连接到链表末尾\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {// 位移的节点\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {//把不移位的结点添加到对应的链表数组中去\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {//把移位的结点添加到对应的链表数组中去 \n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n总结：\n\n如果是第一次进行put元素时进行扩容会将数组的长度和存储阈值设置为默认值。扩容时首先判断数组长度翻倍后是否仍然在最大范围之内，若超过最大值则设置为最大值，然后创建新的数组，将原来数组中的元素重新根据新的数组的长度计算索引值，在进行索引计算的时候每个元素只有两种情况，在原来的位置上或者在原来的位置，例子如下：\n\n```\n假设原来的数组长度n=8。\n8的二进制编码为：\n0000 0000 0000 1000\n计算数组索引的公式为(n-1) & hash，假设存在两个哈希值为别为6和14\n扩容前 n = 8\n6的索引计算：\n0000 0000 0000 0111  ->> n-1 (7)\n0000 0000 0000 0110  ->> 6\n--------------------\n0000 0000 0000 0110  ->> 6\n14的索引计算：\n0000 0000 0000 0111  ->> n-1 (7)\n0000 0000 0000 1110  ->> 14\n0000 0000 0000 0110  ->> 6\n可以看到 6 和14 的索引都是6\n\n进行扩容以后 n = 16\n6的索引计算：\n0000 0000 0000 1111  ->> n-1 (15)\n0000 0000 0000 0110  ->> 6\n--------------------\n0000 0000 0000 0110  ->> 6\n14的索引计算：\n0000 0000 0000 1111  ->> n-1 (7)\n0000 0000 0000 1110  ->> 14\n0000 0000 0000 1110  ->> 14\n可以看到6的索引值不变 还是6，但是14的索引值发生改变，改变为原来的索引+原来的数组长度。\n```\n\n最后根据对应的索引值把元素放入新数组之中。\n\n### put(K key, V value)\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n```\n\nput方法调用了putVal方法，为方便理解加了部分注释，代码如下：\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n  \t//定义了临时变量\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    if ((tab = table) == null || (n = tab.length) == 0)//如果存储数组为空或长度为0则进行扩容\n        n = (tab = resize()).length;//扩容 详见resize方法解释\n    if ((p = tab[i = (n - 1) & hash]) == null) // 计算索引并查看是否为索引位置为空\n        tab[i] = newNode(hash, key, value, null);//索引位置为空，直接把元素放进去\n    else {//索引位置不空\n        Node<K,V> e; K k;\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))//键相同，直接覆盖\n            e = p;\n        else if (p instanceof TreeNode) // 判断为空黑树，使用红黑树插入方法插入 详情暂略\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {//链表\n            for (int binCount = 0; ; ++binCount) {//遍历元素\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // 若长度达到阈值，转换为红黑树\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))//键相等，直接覆盖\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)//onlyIfAbsent为true:不覆盖，false：覆盖。\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;//增加修改次数\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n### remove(Object key)\n\n```java\npublic V remove(Object key) {\n    Node<K,V> e;\n    return (e = removeNode(hash(key), key, null, false, true)) == null ?\n        null : e.value;\n}\n```\n\nremove方法中调用removeNode方法进行删除。\n\n```java\nfinal Node<K,V> removeNode(int hash, Object key, Object value,\n                           boolean matchValue, boolean movable) {\n    Node<K,V>[] tab; Node<K,V> p; int n, index;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (p = tab[index = (n - 1) & hash]) != null) { // 判断是否存储数组为空或者存储数组长度为0\n        Node<K,V> node = null, e; K k; V v;\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k)))) //判断索引位置key是否与要删除的key相等\n            node = p;\n        else if ((e = p.next) != null) { // next不为空，则索引位置为链表或红黑树\n            if (p instanceof TreeNode) // 红黑树\n                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);  //红黑树中找到key相等的元素\n            else { // 链表\n                do {//遍历链表找到key相等的元素\n                    if (e.hash == hash &&\n                        ((k = e.key) == key ||\n                         (key != null && key.equals(k)))) {\n                        node = e;\n                        break;\n                    }\n                    p = e;\n                } while ((e = e.next) != null);\n            }\n        }\n        if (node != null && (!matchValue || (v = node.value) == value ||\n                             (value != null && value.equals(v)))) {//matchValue为是否匹配值\n          \n            if (node instanceof TreeNode)\n                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);//红黑树删除节点\n            else if (node == p)\n                tab[index] = node.next; //单一节点直接删除\n            else\n                p.next = node.next;//链表删除节点\n            ++modCount; //增加操作次数\n            --size; //减少数组实际存储元素个数\n            afterNodeRemoval(node);\n            return node;\n        }\n    }\n    return null;\n}\n```\n\n\n\n### get(Object key)\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n```\n\nget方法中调用getNode方法获取元素。\n\n```java\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {// 判断是否存储数组为空或者存储数组长度为0\n        if (first.hash == hash && // 判断第一个节点\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        if ((e = first.next) != null) {\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key); //红黑树查找\n            do {//链表遍历查找\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n## HashMap的遍历\n\n```java\n//获取key集合遍历key集合再进行取值（需要二次取值效率低）\nprivate static void method04(Map<String, Integer> map) {\n    for (String s : map.keySet()) {\n        System.out.println(s + \"----\" + map.get(s));\n\n    }\n}\n//使用Map.entrySet遍历\"\nprivate static void method03(Map<String, Integer> map) {\n    for (Map.Entry<String, Integer> entry : map.entrySet()) {\n        System.out.println(entry.getKey() + \"----\" + entry.getValue());\n    }\n}\n//使用迭代器进行遍历\nprivate static void method02(Map<String, Integer> map) {\n    Iterator<Map.Entry<String, Integer>> iterator = map.entrySet().iterator();\n    while ((iterator.hasNext())){\n        Map.Entry<String, Integer> mapEntry = iterator.next();\n        System.out.println(mapEntry.getKey() + \"----\" + mapEntry.getValue());\n\n    }\n}\n\n//使用forEach 进行遍历\nprivate static void method01(Map<String, Integer> map) {\n    map.forEach(( key,  value) -> {\n        System.out.println(key + \"----\" + value);\n    });\n}\n```","tags":["java","HashMap"]},{"title":"java多线程(一)","url":"/2020/02/02/java多线程-一/","content":"\n线程、进程概念、Thread和Runnable的基本使用。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n# 进程和多线程的概念以及线程的优点\n\n## 什么是进程\n\n进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是[操作系统](https://baike.baidu.com/item/操作系统)结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 [1]\n\n## 什么是线程\n\n**线程**（英语：thread）是[操作系统](https://baike.baidu.com/item/操作系统)能够进行运算[调度](https://baike.baidu.com/item/调度)的最小单位。它被包含在[进程](https://baike.baidu.com/item/进程)之中，是[进程](https://baike.baidu.com/item/进程)中的实际运作单位。一条线程指的是[进程](https://baike.baidu.com/item/进程)中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及[SunOS](https://baike.baidu.com/item/SunOS)中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。\n\n线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如[Win32](https://baike.baidu.com/item/Win32)线程；由用户进程自行调度的用户线程，如[Linux](https://baike.baidu.com/item/Linux/27050)平台的[POSIX](https://baike.baidu.com/item/POSIX/3792413) Thread；或者由[内核](https://baike.baidu.com/item/内核)与用户进程，如[Windows 7](https://baike.baidu.com/item/Windows 7)的线程，进行混合调度。\n\n同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，[文件描述符](https://baike.baidu.com/item/文件描述符)和[信号处理](https://baike.baidu.com/item/信号处理)等等。但同一进程中的多个线程有各自的[调用栈](https://baike.baidu.com/item/调用栈)（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。\n\n一个进程可以有很多线程，每条线程并行执行不同的任务。\n\n在多核或多[CPU](https://baike.baidu.com/item/CPU/120556)，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。\n\n# 使用多线程\n\n一个进程正在运行时至少会有一个线程在运行，这种情况在Java中也是存在的。这些线程在后台默默地执行，比如调用public static void main() 方法的线程就是这样的，而且它是由JVM创建的。\n\n## 继承Thread 类\n\n在Java的JDK开发包中，已经自带了对多线程技术的支持，可以很方便的进行多线程编程。实现多线程编程的方式主要有两种：\n\n+ 继承Thread类\n+ 实现Runnable接口。\n\n在创建新的线程前，先来看看Thread类的接口，如下：\n\n```java\npublic class Thread implements Runnable\n```\n\n从上面的源代码中可以发现，Thread类实现了Runnable接口，它们之间具有多态的关系。使用Thread类的方式创建新线程时，最大的局限就是不支持多继承，因为iJava语言的特点就是单根继承，所以为了支持多继承，完全可以实现Runnable接口的方式，一边实现一边继承。但是使用这两种方式创建的线程在工作时的性质是一样的，没有本质的区别。\n\n首先来看一下第一种方法。创建MyThread类，继承Thread类并且重写run方法。MyThread类代码如下：\n\n```java\npackage com.caicai;\n\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        System.out.println(\"MyThread\");\n    }\n}\n\n```\n\n运行类代码如下：\n\n```java\npackage com.caicai;\n\npublic class Run {\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        System.out.println(\"运行结束\");\n    }\n\n}\n\n```\n\n运行结果如下：\n\n```java\n运行结束\nMyThread\n\nProcess finished with exit code 0\n```\n\n从运行结果来看，MyThread.java类中的run方法执行的时间比较晚，这也说明在使用多线程技术时，代码的运行结果与代码的执行顺序和调用顺序是无关的。\n\n线程是一个子任务，cpu以不确定的方式，或者说是以随机的事件来调用线程中的run方法，所以就会出现先打印“运行结束”后输出“MyThread”这样的结果了。\n\n如果多次调用start()方法，则会出现异常Excaption in thread \"main\" java.lang.IllegalThreadStateExcetion。\n\n上面介绍了线程的调用的随机性，下面演示线程的随机性。\n\n创建运行类Test.java，代码如下：\n\n```java\npackage com.caicai;\n\npublic class Test {\n    public static void main(String[] args) {\n        MyThread1 myThread1 = new MyThread1();\n        myThread1.setName(\"myThread01\");\n\n        myThread1.start();\n        for (int i = 0; i < 10; i++) {\n            int time = (int) (Math.random() * 1000);\n            try {\n                Thread.sleep(time);\n                System.out.println(\"main=\" + Thread.currentThread().getName());\n\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n```\n\n创建自定义线程类MyThread1.java，代码如下：\n\n```java\npackage com.caicai;\n\npublic class MyThread1 extends Thread {\n    @Override\n    public void run() {\n        try {\n            for (int i = 0; i < 10; i++) {\n                int time = (int) (Math.random() * 1000);\n                Thread.sleep(time);\n                System.out.println(\"run = \" + Thread.currentThread().getName());\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n```\n\n运行结果如下：\n\n```java\nmain=main\nmain=main\nrun = myThread01\nmain=main\nmain=main\nrun = myThread01\nrun = myThread01\nrun = myThread01\nrun = myThread01\nmain=main\nmain=main\nrun = myThread01\nmain=main\nrun = myThread01\nmain=main\n\nProcess finished with exit code 130 (interrupted by signal 2: SIGINT)\n\n```\n\n\n\n在代码中，为了展现出线程具有随机特性，所以使用随机数的形式来使线程得到挂起的效果，从而表现出CPU执行的哪个线程具有不确定性。\n\n另外，执行start方法的顺序不代表线程启动的顺序。创建类MyThread2.java，代码如下：\n\n```java\npackage com.caicai;\n\npublic class MyThread2 extends Thread {\n    private int i;\n\n    public MyThread2(int i) {\n        this.i = i;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(i);\n    }\n}\n\n```\n\n运行类Test.java代码如下：\n\n```java\npackage com.caicai;\n\npublic class Test2 {\n    public static void main(String[] args) {\n        MyThread2 t1 = new MyThread2(1);\n        MyThread2 t2 = new MyThread2(2);\n        MyThread2 t3 = new MyThread2(3);\n        MyThread2 t4 = new MyThread2(4);\n        MyThread2 t5 = new MyThread2(5);\n        MyThread2 t6 = new MyThread2(6);\n        MyThread2 t7 = new MyThread2(7);\n        MyThread2 t8 = new MyThread2(8);\n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n        t6.start();\n        t7.start();\n        t8.start();\n    }\n}\n\n```\n\n运行结果如下所示：\n\n```java\n1\n5\n4\n3\n2\n7\n6\n8\n\nProcess finished with exit code 0\n\n```\n\n## 实现Runnable接口\n\n如果欲创建的线程类已经有一个父类了，就不能再继承Thread类了，所以需要实现Runnable接口来应对这样的情况。\n\n创建MyRunnable，实现MyRunnable，代码如下：\n\n```java\npackage com.caicai.myrunnable;\n\npublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"运行中\");\n    }\n}\n\n```\n\n```java\npackage com.caicai.myrunnable;\n\npublic class Run {\n    public static void main(String[] args) {\n        Runnable runnable = new MyRunnable();\n        Thread thread = new Thread(runnable);\n        thread.start();\n        System.out.println(\"运行结束\");\n    }\n\n}\n\n```\n\n在上述代码中，把一个实现了Runnable的接口当做参数传入Thread的构造函数中创建了一个新的线程类。需要另外说明的是Thread.java类也实现了Runnable接口，这意味着构造函数Thread(Runnable target)不光可以传入Runnable接口对象，还可以传入一个Thread类对象，这样做完全可以将一个Thread对象中的run方法教给其他线程进行调用。\n\n## 实例变量与线程安全\n\n自定义线程类中的实例变量针对其他线程有可共享与不可共享之分。\n\n（1）不共享数据的情况\n\n创建MyThread.java，代码如下：\n\n```java\npackage com.caicai.t3;\n\npublic class MyThread extends  Thread {\n    private int count = 5;\n\n    public MyThread(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run() {\n        super.run();\n        while (count > 0) {\n            count--;\n            System.out.println(\"由\" + Thread.currentThread().getName() + \"计算，count = \" + count );\n\n        }\n    }\n}\n\n```\n\n运行类Run.java，代码如下：\n\n```java\npackage com.caicai.t3;\n\npublic class Run {\n    public static void main(String[] args) {\n        MyThread a = new MyThread(\"A\");\n        MyThread b = new MyThread(\"B\");\n        MyThread c = new MyThread(\"C\");\n        a.start();\n        b.start();\n        c.start();\n    }\n}\n\n```\n\n运行结果如下：\n\n```java\n由A计算，count = 4\n由C计算，count = 4\n由B计算，count = 4\n由C计算，count = 3\n由A计算，count = 3\n由C计算，count = 2\n由B计算，count = 3\n由C计算，count = 1\n由A计算，count = 2\n由C计算，count = 0\n由B计算，count = 2\n由A计算，count = 1\n由B计算，count = 1\n由A计算，count = 0\n由B计算，count = 0\n\nProcess finished with exit code 0\n```\n\n可以看到 一共创建了三个线程 每个线程都有各自的count变量，自己减少自己的count变量的值。这样的情况就是变量不共享，此实例不存在多个线程访问同一个实例变量的情况。\n\n（2）共享数据的情况\n\n共享数据的情况就是多个线程可以访问同一个变量，比如在实现投票功能的软件时，多个线程可以同时处理同一个人的票数。\n\n下面通过一个实例来看下数据共享的情况。\n\n创建MyThread.java类，代码如下：\n\n```java\npackage t4;\n\npublic class MyThread extends Thread {\n    private int count = 5;\n\n    @Override\n    public void run() {\n        super.run();\n        count--;\n        System.out.println(\"由\" + Thread.currentThread().getName() + \"计算 count = \" + count);\n    }\n}\n\n```\n\n \t创建运行类Run.java，代码如下：\n\n```java\npackage t4;\n\npublic class Run {\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        Thread a = new Thread(myThread, \"A\");\n        Thread b = new Thread(myThread, \"B\");\n        Thread c = new Thread(myThread, \"C\");\n        Thread d = new Thread(myThread, \"D\");\n        Thread e = new Thread(myThread, \"E\");\n        a.start();\n        b.start();\n        c.start();\n        d.start();\n        e.start();\n    }\n}\n```\n\n运行结果如下：\n\n```\n由A计算 count = 3\n由D计算 count = 1\n由B计算 count = 3\n由E计算 count = 0\n由C计算 count = 2\n\nProcess finished with exit code 0\n```\n\n可以看到，线程A和线程B打印出的都是count值都是3，说明A和B同时对count\n\n进行处理，产生了“非线程安全”问题。而我们想要得到的打印结果却不是重复的，而是依次递减的。\n\n在某些JVM中，i--的操作要分成如下三步：\n\n1）取得原有的i值。\n\n2）计算i-1。\n\n3）对i进行赋值。\n\n在这三个步骤中，如果有多个线程进行访问，那么一定会出现非线程安全的问题。\n\n这个示例就是典型的销售场景：火车剩五个座位对应五张车票，每当卖出一张票总的票数就会减一，每次得到的剩余票数都是不同的。这时就要使多个线程之间同步，也就是用按顺序排队的方式进行减一操作。更改代码如下：\n\n```java\npackage t4;\n\npublic class MyThread extends Thread {\n    private int count = 5;\n\n    @Override\n    synchronized public void run() {\n        super.run();\n        count--;\n        System.out.println(\"由\" + Thread.currentThread().getName() + \"计算 count = \" + count);\n    }\n}\n```\n\n重新运行程序，就不会出现值一样的情况了。通过在run方法前加入synchronized关键字，使多个线程在执行run方法时，以排队的方式进行处理。当一个线程调用run前，先判断run方法有没有被上锁，如果上锁，说明有其他线程正在调用run犯法，必须等到其他线程对run方法调用结束后才可以执行run方法。这也就实现了排队调用run方法的目的。synchronized可以在任意对象和方法上枷锁，而加锁的这段代码成为“互斥区”或“临界区”。\n\n当一个线程想要执行同步方法里面的代码时，线程首先尝试去拿这把锁，如果能够拿到这把锁，那么这个线程可以执行代码，如果不能拿到线程锁那么这个线程会不断地尝试拿这把锁，直到能够拿到为止，而且是有多个线程同时去争抢这把锁。\n\n## currentThread()方法\n\ncurrentThread()方法可以返回代码段正在被哪个线程调用的信息。下面通过一个示例说明。\n\n创建MyThread.java类，代码如下：\n\n```java\npackage com.caicai.t5;\n\npublic class MyThread extends Thread {\n    public MyThread() {\n        System.out.println(\"构造方法打印:\" + Thread.currentThread().getName());\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"run 方法的打印：\" + Thread.currentThread().getName());\n    }\n}\n```\n\n创建Run2.java类，代码如下：\n\n```java\npackage com.caicai.t5;\n\npublic class Run2 {\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        myThread.start();\n//        myThread.run();\n    }\n\n}\n```\n\n运行结果如下：\n\n```java\n构造方法打印:main\nrun 方法的打印：Thread-0\n\n```\n\n可以看到MyThread.java的构造函数是被main线程调用的，而run方法是被名称Thread-0的线程调用的，run方法是自动调用的方法。\n\nRun2.java代码更改如下：\n\n```java\npackage com.caicai.t5;\n\npublic class Run2 {\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n//        myThread.start();\n        myThread.run();\n    }\n\n}\n```\n\n```\n构造方法打印:main\nrun 方法的打印：main\n```\n\n构造方法和run方法都是main线程调用的。\n\n## isAlive()方法\n\n方法isAlive()的功能是判断当前的线程是否处于活动状态。\n\n创建MyThread.java类，代码如下：\n\n```java\npackage com.caicai.t7;\n\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"run == \" + this.isAlive());\n\n    }\n}\n```\n\n创建Run.java类，代码如下：\n\n```java\npackage com.caicai.t7;\n\npublic class Run {\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        System.out.println(\"begin==\" + myThread.isAlive());\n        myThread.start();\n        System.out.println(\"end==\" + myThread.isAlive());\n    }\n}\n```\n\n运行结果如下：\n\n```\nbegin==false\nend==true\nrun == true\n```\n\n方法isAlive()的作用是测试线程是否处在活动状态。线程处于正在运行或准备开始运行的状态就认为线程是存活的。需要说明的是\n\n```java\nSystem.out.println(\"end==\" + myThread.isAlive());\n```\n\n虽然示例中打印的是true，但是此值是不确定的。打印true值是因为mythread线程还未执行完毕，所以输出true。\n\n## sleep()方法\n\n方法sleep()的作用是在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)。这个“正在执行的线程”是指this.currentThread()返回的线程。\n\n通过一个示例来进行说明。\n\n创建MyThread1.java类，代码如下：\n\n```java\npackage com.caicai.t8;\n\npublic class MyThread1 extends Thread {\n    @Override\n    public void run() {\n        try{\n            System.out.println(\"run threadName= \" + Thread.currentThread().getName() + \"begin \");\n            Thread.sleep(2000);\n            System.out.println(\"run threadName= \" + Thread.currentThread().getName() + \"end \");\n\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n创建Run1.java类，代码如下：\n\n```java\npackage com.caicai.t8;\n\nimport org.w3c.dom.ls.LSOutput;\n\npublic class Run1 {\n    public static void main(String[] args) {\n        MyThread1 myThread1 = new MyThread1();\n        System.out.println(\"begin = \" + System.currentTimeMillis());\n        myThread1.start();\n        System.out.println(\"end = \" + System.currentTimeMillis());\n    }\n}\n```\n\n直接调用run方法运行结果如下：\n\n```\nbegin = 1580819435402\nrun threadName= mainbegin \nrun threadName= mainend \nend = 1580819437421\n\n```\n\n把Run1改为如下：\n\n```java\npackage com.caicai.t8;\n\n\npublic class Run1 {\n    public static void main(String[] args) {\n        MyThread1 myThread1 = new MyThread1();\n        System.out.println(\"begin = \" + System.currentTimeMillis());\n        myThread1.start();\n        System.out.println(\"end = \" + System.currentTimeMillis());\n    }\n}\n```\n\n调用start方法运行结果如下：\n\n```\nbegin = 1580819522188\nend = 1580819522196\nrun threadName= Thread-0begin \nrun threadName= Thread-0end \n```\n\n由于main线程与MyThread2线程是异步执行的，所以首先打印的信息为begin和end。而MyThread2线程是随后执行的，在最后两行打印run begin和run end相关信息。\n\n## getId()方法\n\ngetId()方法的作用是取得线程的唯一标识。\n\n创建Test.java类，代码如下：\n\n```java\npackage com.caicai.t9;\n\npublic class Test {\n    public static void main(String[] args) {\n        Thread runThread = Thread.currentThread();\n        System.out.println(runThread.getName() + \"  \" + runThread.getId());\n    }\n}\n```\n\n运行结果如下:\n\n```\nmain  1\n```\n\n","tags":["多线程","thread"]},{"title":"MAC 键盘快捷键","url":"/2020/01/30/MAC-键盘快捷键/","content":"\nMAC快捷键\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# MAC 键盘快捷键\n\n\n\n剪切、拷贝、粘贴和其他常用快捷键\nCommand-X：剪切所选项并拷贝到剪贴板。\nCommand-C：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。\nCommand-V：将剪贴板的内容粘贴到当前文稿或 App 中。这同样适用于“访达”中的文件。\nCommand-Z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些 App 中，您可以撤销和重做多个命令。\nCommand-A：全选各项。\nCommand-F：查找文稿中的项目或打开“查找”窗口。\nCommand-G：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。\nCommand-H：隐藏最前面的 App 的窗口。要查看最前面的 App 但隐藏所有其他 App，请按 Option-Command-H。\nCommand-M：将最前面的窗口最小化至“程序坞”。要最小化最前面的 App 的所有窗口，请按 Option-Command-M。\nCommand-O：打开所选项，或打开一个对话框以选择要打开的文件。\nCommand-P：打印当前文稿。\nCommand-S：存储当前文稿。\nCommand-T：打开新标签页。\nCommand-W：关闭最前面的窗口。要关闭 App 的所有窗口，请按下 Option-Command-W。\nOption-Command-Esc：强制退出 App。\nCommand–空格键：显示或隐藏“聚焦”搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。（如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何更改冲突的键盘快捷键。）\nControl-Command–空格键：显示字符检视器，您可以从中选择表情符号和其他符号。\nControl-Command-F：全屏使用 App（如果 App 支持）。\n空格键：使用快速查看来预览所选项。\nCommand-Tab：在打开的 App 中切换到下一个最近使用的 App。 \nShift-Command-5：在 macOS Mojave 或更高版本中，拍摄截屏或录制屏幕。也可以使用 Shift-Command-3 或 Shift-Command-4 来拍摄截屏。进一步了解截屏。\nShift-Command-N：在“访达”中创建一个新文件夹。\nCommand-逗号 (,)：打开最前面的 App 的偏好设置。\n\n\n睡眠、退出登录和关机快捷键\n在这些快捷键中，您可能需要按住其中一些快捷键稍长时间。这样有助于避免无意中启用快捷键。\n\n电源按钮：按下可将 Mac 开机或将 Mac 从睡眠状态唤醒。按住这个按钮 1.5 秒可使 Mac 进入睡眠状态。*继续按住则会强制您的 Mac 关机。\nOption–Command–电源按钮*或 Option–Command–Media Eject（Option–Command–介质推出键）：将您的 Mac 置于睡眠状态。\nControl–Shift–电源按钮*或 Control–Shift–Media Eject（Control–Shift–介质推出键）：将显示器置于睡眠状态。\nControl–电源按钮* 或 Control–介质推出键 ：显示一个对话框，询问您是要重新启动、睡眠还是关机。\nControl–Command–电源按钮*：强制 Mac 重新启动，系统不会提示是否要存储任何打开且未存储的文稿。\nControl–Command–Media Eject（Control–Command–介质推出键）：退出所有 App，然后重新启动您的 Mac。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。\nControl–Option–Command–电源按钮* 或 Control–Option–Command–介质推出键 ：退出所有 App，然后将您的 Mac 关机。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。\nControl-Command-Q：立即锁定屏幕。\nShift–Command–Q：退出登录您的 macOS 用户帐户。系统将提示您确认。要在不确认的情况下立即退出登录，请按下 Option-Shift-Command-Q。\n* 不适用于触控 ID 传感器。\n\n\n\n访达和系统快捷键\nCommand-D：复制所选文件。\nCommand-E：推出所选磁盘或宗卷。\nCommand-F：在“访达”窗口中开始“聚焦”搜索。\nCommand-I：显示所选文件的“显示简介”窗口。\nCommand-R：(1) 如果在“访达”中选择了某个别名：显示所选别名对应的原始文件。(2) 在某些 App（如“日历”或 Safari 浏览器）中，刷新或重新载入页面。(3) 在“软件更新”偏好设置中，再次检查有没有软件更新。\nShift-Command-C：打开“电脑”窗口。\nShift-Command-D：打开“桌面”文件夹。\nShift-Command-F：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。\nShift-Command-G：打开“前往文件夹”窗口。\nShift-Command-H：打开当前 macOS 用户帐户的个人文件夹。\nShift-Command-I：打开 iCloud 云盘。\nShift-Command-K：打开“网络”窗口。\nOption-Command-L：打开“下载”文件夹。\nShift-Command-N：新建文件夹。\nShift-Command-O：打开“文稿”文件夹。\nShift-Command-P：在“访达”窗口中显示或隐藏预览面板。\nShift-Command-R：打开“隔空投送”窗口。\nShift-Command-T：显示或隐藏“访达”窗口中的标签页栏。 \nCtrl-Shift-Command-T：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本）\nShift-Command-U：打开“实用工具”文件夹。\nOption-Command-D：显示或隐藏“程序坞”。 \nControl-Command-T：将所选项添加到边栏（OS X Mavericks 或更高版本）。\nOption-Command-P：隐藏或显示“访达”窗口中的路径栏。\nOption-Command-S：隐藏或显示“访达”窗口中的边栏。\nCommand–斜线 (/)：隐藏或显示“访达”窗口中的状态栏。\nCommand-J：显示“显示”选项。\nCommand-K：打开“连接服务器”窗口。\nCommand-L：为所选项制作替身。\nCommand-N：打开一个新的“访达”窗口。\nOption-Command-N：新建智能文件夹。\nCommand-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。\nOption-Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。\nOption-Command-V：移动：将剪贴板中的文件从原始位置移动到当前位置。\nCommand-Y：使用“快速查看”预览所选文件。\nOption-Command-Y：显示所选文件的快速查看幻灯片显示。\nCommand-1：以图标方式显示“访达”窗口中的项目。\nCommand-2：以列表方式显示“访达”窗口中的项目。\nCommand-3：以分栏方式显示“访达”窗口中的项目。 \nCommand-4：以画廊方式显示“访达”窗口中的项目。\nCommand–左中括号 ([)：前往上一文件夹。\nCommand–右中括号 (])：前往下一个文件夹。\nCommand–上箭头：打开包含当前文件夹的文件夹。\nCommand–Control–上箭头：在新窗口中打开包含当前文件夹的文件夹。\nCommand–下箭头：打开所选项。\n右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。\n左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。\nCommand-Delete：将所选项移到废纸篓。\nShift-Command-Delete：清倒废纸篓。\nOption-Shift-Command-Delete：清倒废纸篓而不显示确认对话框。\nCommand–调高亮度：打开或关闭目标显示器模式。\nCommand–调低亮度：当您的 Mac 连接到多台显示器时，打开或关闭视频镜像。\nOption–调高亮度：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。\nControl–调高亮度或 Control–调低亮度：更改外部显示器的亮度（如果显示器支持）。\nOption-Shift–调高亮度或 Option-Shift–调低亮度：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。\nOption–“调度中心”：打开“调度中心”偏好设置。\nCommand–调度中心：显示桌面。 \nControl–下箭头：显示最前面的 App 的所有窗口。\nOption–调高音量：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。\nOption-Shift–调高音量或 Option-Shift–调低音量：以较小的步幅调节音量。\nOption–键盘调高亮度：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。\nOption-Shift–键盘调高亮度或 Option-Shift–键盘调低亮度：以较小的步幅调节键盘亮度。\n连按 Option 键：在单独的窗口中打开项目，然后关闭原始窗口。\n连按 Command 键：在单独的标签页或窗口中打开文件夹。\n按住 Command 键拖移到另一个宗卷：将拖移的项目移到另一个宗卷，而不是拷贝它。 \n按住 Option 键拖移：拷贝托移的项目。拖移项目时指针会随之变化。\n拖移时按住 Option-Command：为拖移的项目制作替身。拖移项目时指针会随之变化。\n按住 Option 键点按开合三角：打开所选文件夹内的所有文件夹。这个快捷键仅在列表视图中有效。\n按住 Command 键点按窗口标题：查看包含当前文件夹的文件夹。\n了解如何使用 Command 或 Shift 在“访达”中选择多个项目。 \n点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。\n\n\n文稿快捷键\n这些快捷键的行为可能因您使用的 App 而异。\n\nCommand-B：以粗体显示所选文本，或者打开或关闭粗体显示功能。 \nCommand-I：以斜体显示所选文本，或者打开或关闭斜体显示功能。\nCommand-K：添加网页链接。\nCommand-U：对所选文本加下划线，或者打开或关闭加下划线功能。\nCommand-T：显示或隐藏“字体”窗口。\nCommand-D：从“打开”对话框或“存储”对话框内选择“桌面”文件夹。\nControl-Command-D：显示或隐藏所选字词的定义。\nShift-Command–冒号 (:)：显示“拼写和语法”窗口。\nCommand–分号 (;)：查找文稿中拼写错误的字词。\nOption-Delete：删除插入点左边的字词。\nControl-H：删除插入点左边的字符。也可以使用 Delete 键。\nControl-D：删除插入点右边的字符。也可以使用 Fn-Delete。\nFn-Delete：在没有向前删除   键的键盘上向前删除。也可以使用 Control-D。\nControl-K：删除插入点与行或段落末尾处之间的文本。\nFn–上箭头：Page Up：向上滚动一页。 \nFn–下箭头：Page Down：向下滚动一页。\nFn–左箭头：Home：滚动到文稿开头。\nFn–右箭头：End：滚动到文稿末尾。\nCommand–上箭头：将插入点移至文稿开头。\nCommand–下箭头：将插入点移至文稿末尾。\nCommand–左箭头：将插入点移至当前行的行首。\nCommand–右箭头：将插入点移至当前行的行尾。\nOption–左箭头：将插入点移至上一字词的词首。\nOption–右箭头：将插入点移至下一字词的词尾。\nShift-Command–上箭头：选中插入点与文稿开头之间的文本。\nShift-Command–下箭头：选中插入点与文稿末尾之间的文本。\nShift-Command–左箭头：选中插入点与当前行行首之间的文本。\nShift-Command–右箭头：选中插入点与当前行行尾之间的文本。\nShift–上箭头：将文本选择范围扩展到上一行相同水平位置的最近字符处。\nShift–下箭头：将文本选择范围扩展到下一行相同水平位置的最近字符处。\nShift–左箭头：将文本选择范围向左扩展一个字符。\nShift–右箭头：将文本选择范围向右扩展一个字符。\nOption–Shift–上箭头：将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。\nOption–Shift–下箭头：将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。\nOption–Shift–左箭头：将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。\nOption–Shift–左箭头：将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。\nControl–A：移至行或段落的开头。\nControl–E：移至行或段落的末尾。\nControl–F：向前移动一个字符。\nControl–B：向后移动一个字符。\nControl–L：将光标或所选内容置于可见区域中央。\nControl–P：上移一行。\nControl–N：下移一行。\nControl–O：在插入点后新插入一行。\nControl–T：将插入点后面的字符与插入点前面的字符交换。\nCommand–左花括号 ({)：左对齐。\nCommand–右花括号 (})：右对齐。\nShift-Command–竖线 (|)：居中对齐。\nOption-Command-F：前往搜索栏。 \nOption-Command-T：显示或隐藏 App 中的工具栏。\nOption-Command-C：拷贝样式：将所选项的格式设置拷贝到剪贴板。\nOption-Command-V：粘贴样式：将拷贝的样式应用到所选项。\nOption-Shift-Command-V：粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。\nOption-Command-I：显示或隐藏检查器窗口。\nShift-Command-P：页面设置：显示用于选择文稿设置的窗口。\nShift-Command-S：显示“存储为”对话框或复制当前文稿。\nShift-Command-减号 (-)：缩小所选项。\nShift-Command-加号 (+)：放大所选项。Command–等号 (=) 可实现相同的功能。\nShift-Command–问号 (?)：打开“帮助”菜单。","tags":["MAC"]},{"title":"LeetCode 热题HOT100","url":"/2019/12/02/LeetCode-热题HOT100/","content":"\nLeetCode热题HOT100题解\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 1.两数之和\n\n```\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例:\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n```\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int [] result = new int[2];\n        for(int i = 0; i < nums.length ; i++){\n            for(int j = i+1; j < nums.length; j++){\n                if(nums[i] + nums[j] == target){\n                    result[0] = i;\n                    result[1] = j;\n                }\n            }\n        }\n        return result;\n    }\n}\n```\n\n\n\n# 2.两数相加\n\n```\n给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n示例：\n\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n\n```\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode node = new ListNode(0);\n        //是否进位\n        Boolean flag = false;\n        ListNode mid = node;\n        while (true){\n            if(l1 == null || l2 == null) {\n                break;\n            }\n            int result = l1.val + l2.val;\n            if(flag){\n                result++;\n                flag = false;\n            }\n            if(result >= 10){\n                flag = true;\n            }\n            ListNode temp = new ListNode(result % 10);\n            mid.next = temp;\n            mid = temp;\n            l1 = l1.next;\n            l2 = l2.next;\n        }\n        while(l1 != null){\n            int result = l1.val;\n            if(flag){\n                result++;\n                flag = false;\n            }\n            if(result >= 10){\n                flag = true;\n            }\n            ListNode temp = new ListNode(result % 10);\n            mid.next = temp;\n            mid = temp;\n            l1 = l1.next;\n        }\n\n        while(l2!= null){\n            int  result = l2.val;\n            if(flag){\n                result++;\n                flag = false;\n            }\n            if(result >= 10){\n                flag = true;\n            }\n            ListNode temp = new ListNode(result % 10);\n            mid.next = temp;\n            mid = temp;\n            l2 = l2.next;\n        }\n        if(flag){\n            ListNode temp = new ListNode(1);\n            mid.next = temp;\n            mid = temp;\n        }\n        if(node.next == null){\n            return new ListNode(0);\n        }\n        return node.next;\n    }\n}\n```\n\n# 3.无重复字符的最长字串\n\n```\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n示例 1:\n\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n示例 2:\n\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n示例 3:\n\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n\n```\n\n```java\nclass Solution {\n public int lengthOfLongestSubstring(String s) {\n        int maxlength = 0;\n        char[] chars = s.toCharArray();\n        String str = \"\";\n        for (int i = 0; i < s.length(); i++) {\n            System.out.println(str);\n//            if((chars[i] >= 'a' && chars[i] <= 'z') || chars[i] == ' ' ){\n                int index = str.indexOf(chars[i]);\n                if (index == -1) {\n                    str += chars[i];\n                    if (str.length() > maxlength) {\n                        maxlength = str.length();\n                    }\n                } else {\n                    str = str.substring(index+1);\n                    str += chars[i];\n                }\n//            }\n        }\n        return maxlength;\n    }\n}\n```\n\n\n\n# 4.寻找两个有序数组的中位数\n\n```\n给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n\n你可以假设 nums1 和 nums2 不会同时为空。\n\n示例 1:\n\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n示例 2:\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n\n```\n\n```\n\n```\n\n","tags":["LeetCode"]},{"title":"JSR-303校验API","url":"/2019/12/01/JSR-303校验API/","content":"\nJSR-303\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# JSR-303\n\n从Spring3.0开始，在SpringMVC中提供了对Java校验API的支持。在SpringMVC中要使用Java校验API的话，并不需要什么额外的配置。只要保证在类路径下包含这个JavaAPI的实现即可。\n\nJava校验API定义了多个注解，这些注解可以放到属性上，从而限制这些属性的值。所有的注解都位于javax.validation.constraints包中。下表列出了这些注解\n\n| 注解         | 描述                                                         |\n| :----------- | :----------------------------------------------------------- |\n| @AssertFalse | 所注解的元素必须是Boolean类型，并且值为false                 |\n| @AssertTrue  | 所注解的元素必须是Boolean类型，并且值为true                  |\n| @DecimalMax  | 所注解的元素必须是数字，并且他的值要小于或者等于给定的BigDecimalString值 |\n| @DecimalMin  | 所注解的元素必须是数字，并且他的值要大于或等于给定的BigDecimalString值 |\n| @Digits      | 所注解的元素必须是数字，并且他的值必须有指定位数             |\n| @Future      | 所注解的元素必须是一个将来的日期                             |\n| @Max         | 所注解的元素必须是数字，并且它的值要小于或等于给定的值       |\n| @Min         | 所注解的元素必须是数字，并且它的值要大于或等于给定的值       |\n| @NotNull     | 所注解的元素的值必须不能为null                               |\n| @Null        | 所注解的元素的值必须为null                                   |\n| @Past        | 所注解的元素必须是一个过去的日期                             |\n| @Pattern     | 所注解的元素的值必须匹配给定的正则表达式                     |\n| @Size        | 所注解的元素的值必须是String、集合或数组，并且它的长度要符合给定的范围 |\n\n除了上表中的注解，Java校验API的实现可能还会提供额外的校验注解。同时也可以定义自己的限制条件。\n\n```java\npackage caicai;\n\nimport javax.validation.constraints.NotNull;\nimport javax.validation.constraints.Size;\n\npublic class Spitter {\n\n    private Long id;\n\n    @NotNull\n    @Size(min = 5, max = 16)\n    private String username;\n\n    @NotNull\n    @Size(min = 5, max = 25)\n    private String password;\n\n    @NotNull\n    @Size(min = 2, max = 30)\n    private String firstName;\n\n    @NotNull\n    @Size(min = 2, max = 30)\n    private String lastName;\n}\n\n```\n\n现在所有的属性都加上了NotNull注解，以确保他们的值不会为null。类似的，属性上也添加了@Size注解以限制他们的长度在最大值和最小值之间。\n\n我们接下来要修改processRegistration()方法来应用校验功能。启用校验功能的processRegistration()如下所示：\n\n```java\n    @RequestMapping(value = \"/register\",method = RequestMethod.POST)\n    public String processRegistration(@Valid Spitter spitter, Errors errors){\n        if(errors.hasErrors()){\n            return \"registerForm\";\n        }\n        return \"redirect:/spitter/\" + spitter.getUsername();\n    }\n```\n\nSpitter参数添加了@Valid注解，这会告知Spring，需要确保这个对象满足校验限制。在Spitter属性上添加校验限制并不能阻止表单提交。即便用户没有填写某个域所给定的值超出了最大长度，processRegistration()方法依然会被调用。这样，我们就需要处理校验的错误，就像在processRegistration()方法中所看到的那样。\n\n如果有校验出现错误的话，那么这些错误可以通过Errors对象进行访问，现在这个对象以作为processRegistration()方法的参数。（很重要一点需要注意，Errors参数要紧跟在带有@Valid注解的参数后面，@Valid注解所标注的就是要检验的参数。）processRegistration()方法所做的第一件事就是调用Errors.hasErrors()来检查是否有错误。\n\n如果又称错误的话，Errors.hasErrors()将会返回到registerForm,也就是注册表单的视图，这能够让用户的浏览器重新回到注册表单页面，所以他们能够修正错误，然后重新尝试提交。现在，会显示空的表单，但是在下一章中，我们将在表单中显示最初提交的值并将校验错误反馈给用户。\n\n","tags":["JSR-303","Spring"]},{"title":"Spring Web","url":"/2019/11/27/Spring-Web/","content":"\nSpring Web\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 构建SpringWeb应用程序\n\n## Spring MVC起步\n\n每当用户在Web浏览器中点击链接或提交表单的时候，请求就开始工作了。下图展示了请求使用SpringMVC所经历的所有站点。\n\n![](Spring-Web/1.png)\n\n在请求离开浏览器时(①)会将带有用户所请求内容的信息，至少会包含请求的URL，但是还可能带有其他的信息，例如用户提交的表单信息。 \n\n请求的第一站是Spring的DispatcherServlet。与大多数基于Java的Web框架一样，SpringMVC所请求都会通过一个前端控制器Servlet。前端控制器是常用的Web应用程序模式，在这里一个单例的Servlet将请求委托给应用程序的其他组件来执行实际的处理。在SpringMVC中，DispatcherServlet就是前端控制器。\n\nDispatcherServlet的任务是将请求发送给SpringMVC控制器（Controller）。控制器是一个用于处理请求的Spring组件。在典型的应用程序中可能会有多个控制器，DispatcherServlet需要知道应该将请求发送给哪个控制器。所以DispatcherServlet以会查询一个或多个处理器映射（handler mapping）②来确定请求的下一站在哪里。处理器映射会根据请求所携带的url信息进行决策。\n\n一旦选择了合适的控制器，DispatcherServlet会将请求发送给选中的控制器③。到了控制器，请求会卸下其负载（用户提交的信息）并耐心等待控制器处理这些信息。（实际上，设计良好的控制器本身只处理很少甚至不处理工作，而是将业务逻辑委托给一个或多个服务对象进行处理。）\n\n控制器在完成逻辑处理后，通常会产生一些信息，这些信息需要返回给用户并在浏览器上显示。这些信息被称为模型（model）。仅仅给用户返回原始的信息是不够的——这些信息需要以有好的方式进行格式化，一般会是HTML。所以，信息需要发送给一个视图（view），通常会是JSP。控制器所做的最后一件事就是将模型数据打包，并且标出用于渲染输出的视图名。他接下来会将请求连通模型和视图名发送回DispatcherServlet④。\n\n这样，控制器就不会与特定的视图相耦合，传递给DispatcherServlet的视图名不直接表示某个特定的JSP。实际上，它甚至并不能确定视图就是JSP。相反，它仅仅传递了一个逻辑名称，这个名字将会用来查找产生结果的真正视图。DispatcherServlet将会使用视图解析器（view resolver）⑤来讲逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是JSP。\n\n既然DispatcherServlet已经知道由哪个视图渲染结果，那请求的任务基本上也就完成了。它的最后一站是视图的实现（可能是JSP）⑥，在这里他交付模型数据。请求的任务就完成了。试图将使用模型数据渲染输出，这个输出会通过响应对象传递给客户端。\n\n## 搭建Spring MVC\n\n### 配置DispatcherServlet\n\n\n\n```java\npackage caicai.config;\n\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\npublic class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n    //加载容器\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class<?>[] { RootConfig.class };\n    }\n    //加载webapp容器\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { WebConfig.class };\n    }\n    //设置DispatcherServlet的拦截规则  / 代表拦截所有但是不包括jsp\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { \"/\" };\n    }\n}\n\n\n```\n\n要理解上述代码如何工作，我们可能只需要知道扩延AbstractAnnotationConfigDispatcherServletInitializer的任意类都会自动地配置DispatcherServlet和Spring应用上下文，Spring的应用上下文会位于应用程序的Servlet上下文之中。\n\nAbstractAnnotationConfigDispatcherServletInitializer剖析：\n\n在Servlet3.0环境中，容器会在类路径中查找实现java.servlet.ServletContainerInitializer接口的类，如果能发现的话，就会用它配置Servlet容器类。\n\nSpring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给他们来完成。Spring3.2引入了一个便利的WebApplicationInitializer的基础实现，也就是AbstractAnnotationConfigDispatcherServletInitializer。因为我们的SpittrWebAppInitializer扩展了AbstractAnnotationConfig DispatcherServletInitializer（同时也就实现了WebApplicationInitializer)，因此当部署到Servlet3.0容器中的时候，容器会自动发现它，并用它来配置Servlet上下文。\n\n尽管它的名字很长，但是AbstractAnnotationConfigDispatcherServletInitializer使用起来很简便。SpittrWebAppInitializer中重写了三个方法。第一个方法是getServletMappings() ，它会将一个或多个路径映射到DispatcherServlet上。在本例中，它映射的是“/”，这表示他会是应用的默认Servlet。他会处理进入应用的所有请求。\n\n为了理解其他两个方法，我们首先要理解DispatcherServlet和一个Servlet监听器（也就是ContextLoaderListener）的关系。\n\n### 两个应用上下文之间的故事\n\n当DispatcherServlet启动的时候，他会创建Spring应用上下文，并加载配置文件或配置类中所声明的bean。在getServletConfigClasses（）方法中，我们要求DispatcherServlet加载应用上下文时，使用定义在WebConfig配置类（使用Java配置）中的bean。\n\n但是在SpringWeb应用中，通常还有另外一个应用上下文。另外的这个应用上下文是由ContextLoaderListener创建的。我们希望DispatcherServlet加载包含Web组件的bean，如控制器、视图解析器以及处理器映射，而ContextLoaderListener要加载应用中的其他bean。这些bean通常是驱动应用后端的中间层和数据层组件。\n\n实际上，AbstractAnnotationConfigDispatcherrServletInitializer会同时创建DispatcherServlet和ContextLoaderListener。GetServletConfigClasses（）方法返回的带有@Configuration注解的类加ing会用来定义DispatcherServlet应用上下文中的bean。\n\n在本例中，根据配置定义在RootConfig中，DispatcherServlet的配置声明在WebConfig中。\n\n### 启用Spring MVC\n\n启用SpringMVC组件的方法不仅一种。以前，Spring是使用XML进行配置的，可以使用\\<mvc:annotation-driven>注解启用注解驱动的SpringMVC。现在我们能创建的最简单的SpringMVC配置就是一个带有@EnableWebMvc注解的类：\n\n```java\npackage com.caicai.springmvc.spittr.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\n@Configuration\n@EnableWebMvc\npublic class WebConfig {\n}\n\n```\n\n这可以运行起来，它的确能够启用SpringMVC，但还有不少的问题需要解决：\n\n+ 没有配置视图解析器。这样的话，Spring默认会使用BeanNameView-Resolver，这个视图解析器会查找ID与视图名称匹配的bean，并且查找的bean要实现View接口，他以这样的方式来解析试图。\n+ 没有启用组件扫描。这样的结果就是Spring只能找到显式声明在配置类中的控制器。\n+ 这样配置的话，DispatcherServlet会映射为应用默认Servlet，所以他会处理所有请求，包括对静态资源的请求，如图片和样式表。\n\n因此，我们需要在WebConfig这个最小的SpringMVC配置上再加一些内容，从而让他们变得真正有用。\n\n```java\npackage caicai.config;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.ViewResolverRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n\n/**\n * Springweb应用的配置 相当于配置文件SpringMVC.xml\n *\n */\n@Configuration\n@EnableWebMvc\n//配置只会扫描Controller注解\n@ComponentScan(value = {\"caicai\"},includeFilters={@ComponentScan.Filter(type= FilterType.ANNOTATION,value={Controller.class})},useDefaultFilters = false)\npublic class WebConfig extends WebMvcConfigurerAdapter {\n\n    //配置视图解析器\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        //默认前缀 /WEB-INF/   后缀.jsp\n        registry.jsp();\n    }\n\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n        configurer.enable();\n    }\n}\n\n\n```\n\n在上述代码中第一件需要注意的事情是WebConfig现在添加了@Component-Scan注解。接下来我们设置了视图的默认前缀和后缀。最后，新的WebConfig类还扩展了WebMvcConfigurerAdapter并重写了其configureDefaultServletHandling()方法。通过调用DefaultServlet-HandlerConfigurer的enable（）方法，我们要求DispatcherServlet将对静态资源的请求转发到Servlet容器默认的Servlet上，而不是使用DispatcherServlet本身来处理此类请求。\n\nWebConfig配置已经就绪，我们需要再配置RootConfig：\n\n```java\npackage caicai.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType;\nimport org.springframework.stereotype.Controller;\n\n/**\n * 这个是跟容器，相当于ApplicationContxt.xml,包扫描的时候要排除@Controller注解，避免重复扫描\n */\n@ComponentScan(value ={\"caicai\"},\n        excludeFilters={@ComponentScan.Filter(type = FilterType.ANNOTATION,value = {Controller.class})})\n@Configuration//声明这是一个配置类\npublic class RootConfig {\n}\n\n\n```\n\n\n\n## 编写基本的控制器\n\n在SpringMVC中，控制器试试方法添加了@RequestMapping注解的类，这个注解声明了他们所要处理的请求。我们声明一个最简单的SpringMVC控制类：\n\n```java\npackage caicai.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n@Controller\npublic class HomeController {\n    @RequestMapping(value = \"/\", method = RequestMethod.GET)\n    public String home() {\n        return \"home\";\n    }\n\n}\n\n```\n\n你可能注意到的一件事就是HomeController带有@Controller注解。很显然这个注解是用来声明控制器的，但实际上这个注解对SpringMVC本身的影响并不大。\n\nHomeController是一个构造型（stereotype）的注解，它基于@Compont注解。在这里，他的目的就是辅助实现组件扫描。因为HomeController带有@Controller注解，因此组件扫描器会自动找到HomeController，并将其声明为Spring应用上下文中的一个bean。\n\n其实也可以让HomeController带有@Component注解，他所实现的效果是一样的，但是在表意性上可能会差一点，无法确定HomeController是什么组件类型。\n\nHomeController唯一的一个方法就是home（）方法，带有@RequestMapping注解。他的value属性制定了这个方法所要处理的请求路径，method属性细化了她所处理的HTTP方法。在本例中，当收到对/的HTTP GET请求时，就会调用home（）方法。home（）方法其实并没有做太多事：它返回了一个String类型的“home”。这个String将会把SpringMVC解读为要渲染的视图名称。DispatcherServlet会要求视图解析器将这个逻辑名解析为实际的视图。\n\n鉴于我们配置InternalResourceViewResolver的方式，视图名“home”将会解析为“/WEB-INF/home.jsp”路径的JSP。\n\nhome.jsp代码如下：\n\n```jsp\n<%--\n  Created by IntelliJ IDEA.\n  User: 1\n  Date: 2019/11/30\n  Time: 14:53\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>hello</title>\n</head>\n<body>\n\n</body>\n</html>\n\n```\n\n### 定义类级别的请求处理\n\n```java\npackage caicai.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n\n@Controller\n@RequestMapping(\"/\")\npublic class HomeController {\n    @RequestMapping(method = RequestMethod.GET)\n    public String home() {\n        return \"home\";\n    }\n\n}\n```\n\n在这个新版本的HomeController中，路径现在被转移到类级别的@RequestMapping上，而HTTP方法易染映射在方法级别上。当控制器在类级别上添加@RequestMapping注解时，这个注解会应用到控制器的所有处理器方法上。处理器方法上的@RequestMapping注解会对类级别上的@RequestMapping的声明进行补充。\n\n就HomeController而言，这里只有一个控制器方法。与类级别的@RequestMapping合并后，这个方法的@RequestMapping表明home()将会处理对\"/\"路径的GET请求。\n\n换言之，我们没有改变任何功能，只是将一些代码换了个地方，HomeController所做的事情和以前是一样的。\n\n### 传递模型数据到视图中\n\n到现在为止，就编写超级简单的控制器来说，HomeController已经是一个不错的样例了。但是大多数的控制器不是这么简单。在应用中，我们需要有一个页面展现最近提交的列表。因此，我们需要一个新的方法来 处理这个界面。\n\n首先，需要定义一个数据访问的Repository。为了实现解耦以及避免陷入数据库访问的细节之中，我们将Repository定义为一个接口。我们只需要一个能够获取列表的Repository，如下所示的SpittleRepository功能已经足够了：\n\n```java\npackage caicai.data;\nimport java.util.List;\n\npublic interface SpittleRepository {\n    List<Spittle> findSpittles(long max, int count);\n\n}\n\n```\n\n\n\n```java\npackage caicai.data;\n\nimport java.util.Date;\npublic class Spittle {\n    private final Long id;\n    private final String message;\n    private final Date time;\n    private Double latitude;\n    private Double longitude;\n\n    public Spittle(String message, Date time) {\n        this(message, time, null, null);\n    }\n    public Spittle(String message, Date time, Double longitude, Double latitude) {\n        this.id = null;\n        this.message = message;\n        this.time = time;\n        this.longitude = longitude;\n        this.latitude = latitude;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public Date getTime() {\n        return time;\n    }\n\n    public Double getLatitude() {\n        return latitude;\n    }\n\n    public Double getLongitude() {\n        return longitude;\n    }\n\n}\n\n```\n\n## \n\n​              ","tags":["Spring"]},{"title":"Spring面向切面编程","url":"/2019/11/21/Spring面向切面编程/","content":"\nSpring面向切面编程\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# Spring面向切面编程\n\n## AOP术语\n\n通常切面的常用术语有通知(advice)、切点(pointcut)和连接点(joinpoint)。\n\n### 通知(Advice)\n\nSpring切面可以应用5种类型的通知：\n\n+ 前置通知(Before):在目标方法被调用之前调用通知功能\n+ 后置通知(After):在目标方法完成之后调用通知,此时不会关心方法的输出是什么\n+ 返回通知(After-returning):在目标方法成功执行之后调用通知\n+ 异常通知(After-throwing):在目标方法抛出异常后调用通知\n+ 环绕通知(Around):通知包裹了被通知的方法,在被统治的方法调用之前和调用之后执行自定义的行为\n\n### 连接点(Join Point)\n\n连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时，甚至是修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。\n\n### 切点(Poincut)\n\n如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个节点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。\n\n### 切面(Aspect)\n\n切面时通知和切点的集合。通知和切点共同定义了切面的全部内容——他是什么，何时何处完成。\n\n### 引入(Introduction)\n\n引入允许我们向现有的类添加新的方法和属性。例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让他们具有新的行为和状态。\n\n### 织入(Weaving)\n\n织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：\n\n+ 编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。\n+ 类加载器：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader)，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入(load-time weaving ,LTW)就支持这种方式织入切面。\n+ 运行期：切面在应用运行时的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。\n\n## Spring对AOP的支持\n\n并不是所有的AOP框架都是相同的，他们在连接点模型上可能有强弱之分。有些允许在字段修饰符级别应用通知，而另一些只支持与方法调用相关的连接点。他们织入切面的方式和时机也有所不同。但是无论如何，创建切点来定义切面所织入的连接点是AOP框架的基本功能。\n\nSpring提供了4中类型的AOP支持：\n\n+ 基于代理的经典Spring AOP\n+ 纯POJO切面\n+ @AspectJ注解驱动的切面\n+ 注入式AspectJ切面（适用于Speing各版本）\n\n前三种都是Spring AOP实现的变体，Spring AOP构建在动态代理基础之上，因此，Spring对AOP的支持局限方法拦截。\n\n## 通过切点来选择连接点\n\n在Spring AOP中，要使用AspectJ的切点表达式语言来定义切点\n\n| AspectJ指示器 | 描述                                                         |\n| ------------- | ------------------------------------------------------------ |\n| arg()         | 限制连接点匹配参数为指定类型的执行方法                       |\n| @args()       | 限制连接点匹配参数由指定注解标注的执行方法                   |\n| execution()   | 用于匹配是连接点的执行方法                                   |\n| this()        | 限制连接点匹配AOP代理的bean引用为指定类型的类                |\n| target        | 限制连接点匹配目标对象为指定的类                             |\n| @target()     | 限制连接点匹配特顶的执行对象，这些对象对应的类要具有指定类型的注解 |\n| within()      | 限制连接点匹配指定的类型                                     |\n| @within()     | 限制连接点匹配指定注解所标注的类型                           |\n| @annotation   | 限定匹配带有指定注解的连接点                                 |\n\n在Spring中常识使用AspectJ其他指示器时，将会抛出IllegalArgumentException异常。\n\n当我们查看如上所展示的那些Spring指示的指示器时，注意只有execution指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器。在此基础上，我们能使用其他指示器来限制所匹配的切点。\n\n## 使用注解创建切面\n\n使用注解创建切面是AspectJ5所引入的关键特性。AspectJ5之前，编写AspectJ切面需要学习一种java语言的扩展，但是AspectJ面向注解的模型可以非常渐变地通过少量注解把任意类型转变变为切面。\n\n首先我们要定义一个Performance接口，它是切面中切点的目标对象。\n\n```java\npublic interface Performance {\n    public void perform();\n}\n\n```\n\n### 定义切面\n\n如果一场演出没有观众的话，那不能称之为演出。从演出的角度来看，观众是非常重要的，但是对演出的本身功能来讲，他并不是核心，这是一个单独的关注点。因此，将观众定义为一个切面，并将其应用到演出上就是较为明智的做法。\n\n```java\n\nimport org.aspectj.lang.annotation.AfterReturning;\nimport org.aspectj.lang.annotation.AfterThrowing;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\n@Aspect\npublic class Audience {\n\n    @Before(\"execution(* com.example.demo.Performance.perform(..))\")\n    public void silenceCellPhones() {\n        System.out.println(\"Silencing cell phones\");\n    }\n\n    @Before(\"execution(* com.example.demo.Performance.perform(..))\")\n    public void takeSeats() {\n        System.out.println(\"Taking seats\");\n    }\n\n    @AfterReturning(\"execution(* com.example.demo.Performance.perform(..))\")\n    public void applause() {\n        System.out.println(\"CLAP CLAP CLAP!!!\");\n\n    }\n\n    @AfterThrowing(\"execution(* com.example.demo.Performance.perform(..))\")\n    public void demandRefund() {\n        System.out.println(\"Demanding a refund\");\n    }\n}\n```\n\nAudience类使用@AspectJ注解进行了标注。该注解表明Audience不仅仅是一个POJO，还是一个切面。Audience类中的方法都是用注解来定义切面的具体行为。\n\nAudience有四个方法，定义了一个观众在观看演出时可能会做的事情。在演出之前，观众要就做(takeSeats())并将手机调至静音状态(silenceCellPhones())。如果演出很精彩的话，观众应该会鼓掌喝彩(applause())。不过如果演出没有达到观众预期的话，观众会要求退款(demandRefundd())。\n\nAspectJ提供了五个注解来定义通知：\n\n|      注解       |                   通知                   |\n| :-------------: | :--------------------------------------: |\n|     @After      | 通知方法会在目标方法返回或抛出异常后调用 |\n| @AfterReturning |      通知方法会在目标方法返回后调用      |\n| @AfterThrowing  |    通知方法会在目标方法抛出异常后调用    |\n|     @Around     |       通知方法会将目标方法封装起来       |\n|     @Before     |     通知方法会在目标方法调用之前运行     |\n\n\n\nAudience使用到了前面五个注解中的三个。takeSeats()和silence CellPhones()方法都用到了@Before注解，表明他们应该在演出开始之前调用。applause()方法使用了AfterReturning注解，他会在演出成功返回后调用。de'man'd'Refund()方法上添加了@AfterThrowing注解，这表明他会在抛出异常以后执行。\n\n在上述代码中，相同的一个切点表达式我们重复了四边，我们完全可以这样做：@Pointcut注解能够在一个@AspectJ切面内定义可重用的切点。接下来的程序清单4.2展现了新的Audience，现在它使用了@Pointcut。\n\n```java\nimport org.aspectj.lang.annotation.*;\n@Aspect\npublic class Audience1 {\n    @Pointcut(\"execution(* com.example.demo.Performance.perform(..)))\")\n    public void performance() {\n    }\n\n\n    @Before(\"performance()\")\n    public void silenceCellPhones() {\n        System.out.println(\"Silencing cell phones\");\n    }\n\n    @Before(\"performance()\")\n    public void takeSeats() {\n        System.out.println(\"Taking seats\");\n    }\n\n    @AfterReturning(\"performance()\")\n    public void applause() {\n        System.out.println(\"CLAP CLAP CLAP!!!\");\n\n    }\n\n    @AfterThrowing(\"performance()\")\n    public void demandRefund() {\n        System.out.println(\"Demanding a refund\");\n    }\n\n}\n\n```\n\n在Audience中，performance()方法使用了@Pointcut注解。为@Pointcut注解设置的值是一个切点表达式，就像之前在通知注解上所设置的那样。通过在performance()方法上添加@Pointcut注解，我么恩实际上扩展了切点表达式语言。这样就可以在任何的且地点表达式中使用performance()了，如果不这样做的话，你需要在这些地方使用那个更长的切点表达式。我们现在把所有通知注解中的长表达式都换成了performance()。\n\nperformance()方法的实际内容并不重要，在这里它实际上因嘎嘎i是空的。其实该方法本身只是一个表示，供@pointcut注解依附。\n\n需要注意的是，除了注解和没有实际操作的呃performance()方法，Audience类依然是一个POJO。我们能够像使用其他的java类那样调用它的方法，他的方法也能独立的进行单元测试，这与其他的Java类并没有什么区别。Audience只是一个Java类，只不过它通过注解表明会作为切面使用而已。\n\n像其他java类一样，他可以装配为Spring中的bean：\n\n```java\n@Bean\npublic Audience audience() {\n\treturn new Audience();\n}\n```\n\n如果就此止步的话，Audience只会是Spring容器中的一个bean。即便使用了AspectJ注解，但他并不会被视为切面，这些注解不会解析，也不会创建将其转换为切面的代理。\n\n如果使用JavaConfig的话，可以在配置类的类级别上通过使用@EnableAspectJ-AutoProxy注解启用自动代理功能\n\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\n\n@Configuration\n@EnableAspectJAutoProxy\n@ComponentScan\npublic class ConcertConfig {\n    @Bean\n    public Audience audience() {\n        return new Audience();\n    }\n}\n\n```\n\n### 创建环绕通知\n\n环绕通知是最为强大的通知类型。他能够让你所编写的逻辑将被统治的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。\n\n为了阐述环绕通知，我们重写Audience切面。这次我们使用一个环绕通知来代替之前多个不同的前置通知和后置通知。\n\n```java\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\n@Aspect\npublic class Audience2 {\n    @Pointcut(\"execution(* com.example.demo.Performance.perform(..))\")\n    public void performance() {\n    }\n    \n    @Around(\"performance()\")\n    public void watchPerformance(ProceedingJoinPoint jp) {\n        try {\n            System.out.println(\"Silencing cell phones\");\n            System.out.println(\"Taking seats\");\n            jp.proceed();\n            System.out.println(\"CLAP CLAP CLAP!!!\");\n        } catch (Throwable e) {\n            System.out.println(\"Demanding a refund\");\n        }\n    }\n\n}\n\n```\n\n在这里，@Around注解表明watchPerformance()方法会作为performance()切点的环绕通知。在这个通知中，观众在演出之前会将手机调至静音并就做，演出结束后会鼓掌喝彩，如果演出失败的话，观众会要求退款。可以看到，这个通知所达到的效果与之前的前置通知和后置通知是一样的。但是，现在他们位于同一个方法中，不像之前那样分散在四个不同的方法里。\n\n关于这个新的通知方法，你首先注意到的可能是它接收ProceedingJoinPoint作为参数。这个对象是必须要有的，因为你要在通知中通过它来调用被统治的方法。通知方法中可以做任何事情，当要将控制权交给被通知的方法是，他需要调用ProceedingJoinPoint的proceed()方法。\n\n\n\n## 小结\n\nAOP是面向对象编程的一个强大补充。通过AspectJ，我们现在可以把之前分散在应用各处的行为放入可重用的模块中。我们显示地声明在何处如何应用该行为。这有效减少了代码冗余，并让我们的类关注自身的主要功能。\n\nSpring提供了一个AOP框架，让我们把切面插入到方法执行的周围。关于在Spring应用中如何使用切面，我们可以有多种选择。通过使用@AspectJ注解和简化的配置命名空间，在Spring中装配通知和切点变得非常简单。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Spring"]},{"title":"Spring 运行时注入","url":"/2019/11/19/Spring-运行时注入/","content":"\nSpring运行时注入\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n# 运行时注入\n\n当讨论依赖注入时候，我们通常所讨论的时将一个bean注入到另一个bean的属性或者构造器参数中。它通常来讲是指将一个对象与另一个对象进行关联。\n\n但是bean装配的另外一个方面指的是将一个值注入到bean的属性或者构造器参数中。有时候硬编码是可以的，但是有的时候，我们可能会希望避免硬编码值，而是想让这些值在运行的时候再确定，为了实现这些功能，Spring提供了两种再运行时求值的方式：\n\n+ 属性占位符（Property placeholder）\n+ Spring表达式语言（SpEL）\n\n这两种技术的用法是类似的，不过他们的目的和行为是有所差别的。\n\n## 注入外部的值\n\n在Spring中，处理外部值的最简单方式就是声明属性源并通过Spring的Environment来检索属性。\n\n```java\n@Configuration\n@PropertySource(\"classpath:/application.properties\")\npublic class ExpressiveConfig {\n\n    @Autowired\n    Environment environment;\n\n    @Bean\n    public BlackDisc disc(){\n        return new BlackDisc(environment.getProperty(\"disc.title\"),environment.getProperty(\"disc.artist\"));\n    }\n}\n\n```\n\n```java\npublic class BlackDisc {\n    private String title;\n    private String artist;\n\n    @Override\n    public String toString() {\n        return \"BlackDisc{\" +\n                \"title='\" + title + '\\'' +\n                \", artist='\" + artist + '\\'' +\n                '}';\n    }\n\n    public BlackDisc(String title, String artist) {\n        this.title = title;\n        this.artist = artist;\n    }\n}\n\n```\n\n\n\n本例中@PropertySource引用了类路径中一个名为application.properties的文件，内容大致如下所示：\n\n```\ndisc.title = Sgt. Peppers Lonely Hearts Clud Band\ndisc.artist = The Beatles\n```\n\n这个属性文件会加载到Spring的Environment中，稍后可以从这里检索属性。\n\n### 深入学习Spring的Environment\n\nEnvironment中getProperty（）方法中有四个重载的变种形式：\n\n+ String getProperty(String key)\n+ String getProperty(String key, String defaultValue)\n+ T getProperty(String key, Class<T> type)\n+ T getProperty(String key, Class<T> type, T defaultValue)\n\n前两种形式的getProperty返回的是String类型的值， 第二种比第一种增加了一个默认值，如果指定属性不存在的时候就会使用这个默认值。剩下的两种可以返回对象类型。如果我们从属性文件中得到的是一个String类型的值，并且在使用之前需要将其转换为Integer类型，如果使用第三四中方式可以非常方便的解决这个问题：\n\n```java\nint connectionCount = environment.getProperty(\"db.connection.count\", Integer.class, 30)\n```\n\n当在使用getProperty()方法时没有指定默认值，并且属性没有定义的话，获取到的是null，如果希望属性必须要定义，那么可以使用getRequiredProperty（）方法，如下所示：\n\n```java\n    @Bean\n    public BlackDisc disc() {\n        return new BlackDisc(environment.getRequiredProperty(\"disc.title\"), environment.getRequiredProperty(\"disc.artist\"));\n    }\n```\n\n如果disc.title或disc.artist属性没有定义的话，将会抛出IllegalStateException异常。\n\n如果想检查某个属性是否存在，可以调用Environment的containsProperty（）方法。\n\n```java\n        boolean titleExists = environment.containsProperty(\"disc.title\");\n```\n\n### 解析占位符\n\nSpring 一直支持将属性定义到外部的属性文件中，并使用占位符值将其插入到Spring bean中。在Spring装配中，占位符的形式为使用${...} 包装的属性名称。配合@Value注解BlankDisc可以改成如下所示\n\n```java\npublic class BlackDisc {\n    @Value(\"${disc.title}\")\n    private String title;\n    @Value(\"${disc.artist}\")\n    private String artist;\n\n    @Override\n    public String toString() {\n        return \"BlackDisc{\" +\n                \"title='\" + title + '\\'' +\n                \", artist='\" + artist + '\\'' +\n                '}';\n    }\n}\n```\n\n为了使用占位符，我们需要配置一个PropertySourcesPlaceholderConfigurer，如下的@Bean方法在java中配置了PropertySourcesPlaceholderConfigurer：\n\n```java\n    @Bean\n    public PropertySourcesPlaceholderConfigurer placeholderConfigurer() {\n        return new PropertySourcesPlaceholderConfigurer();\n    }\n```\n\n\n\n## 使用Spring表达式语言进行装配 \n\nSpring3引入了Spring表达式语言（Spring Expression Language SpEL)，他能够以一种强大和简洁的方式将值装配到bean属性装配到bean属性和构造器参数中，在这个过程中所使用的表达式会在运行时计算得到值。\n\nSpEL有很多特性：\n\n+ 使用bean的ID来引用bean\n+ 调用方法和访问对象的属性\n+ 对值进行算数、关系和逻辑运算\n+ 正则表达式匹配\n+ 集合操作\n\n### SpEL样例\n\n#{1} 除去#{} 标记后，剩下的就是SpEL的表达式体了，也就是一个数字常量。\n\n#（T(System).currentTimeMillins())} 他的最终结果是计算表达式得到那一刻当前时间的毫秒数。T()表达式会将java.lang.System视为java中对应的类型 ，因此可以调用其static修饰的currentTimeMillis()方法。\n\nSpEL表达式也可以引用qitabean 或其他bean 打的属性。例如\n\n#{sgtPeppers.artist}\n\n我们使用SpEL来表达式来重新修改BlankDisc：\n\n\n\n```java\npublic class BlackDisc {\n    @Value(\"#{systemProperties['disc.title']}\")\n    private String title;\n    @Value(\"#{systemProperties['disc.artist']}\")\n    private String artist;\n\n    @Override\n    public String toString() {\n        return \"BlackDisc{\" +\n                \"title='\" + title + '\\'' +\n                \", artist='\" + artist + '\\'' +\n                '}';\n    }\n}\n```\n\n### 标识字面值\n\n下面的SpEL表达式表示的是浮点值：\n\n#{3.14159}\n\n数值还可以用科学计数法的方式进行表示：\n\n#{9.87E4}\n\nSpEL表达式也可以用来计算String类型的字面值，如:\n\n#{'hello'}\n\n最后字面值true和false的计算结果就是他们对应的Boolean类型的值，例如：\n\n#{false}\n\n\n\n### 引用bean、属性和方法\n\nSpEL所能做的另外一件事就是通过ID引用其他的bean。例如，你可以使用SpEL将一个bean装配到另外一个bean属性中，此时要使用beanID作为SpEL表达式，例如：\n\n#{sgtPeppers}\n\n现在 假设我们想在一个表达式中引用sgtPeppers的artist属性：\n\n#{sgtPeppers.artis}\n\n除了引用属性，我们还可以调用bean上的方法，例如：\n\n#{artistSelector.selectArtist()}\n\n对于被调用方法的返回值来说，我们同样可以调用它的方法，例如，如果selectArtist()方法返回的是一个String，那么可以调用toUpperCase()将整个字符串变为大写。\n\n#{artistSelector.selectArtist().toUpperCase()}\n\n为了避免selectArtist()返回值是null我们可以使用类型安全的运算符：\n\n#{artistSelector.selectArtist()?.toUpperCase()}\n\n与之前只是使用点号(.)不同，我们使用(?.)运算符，这个运算符能够在访问他右边的内容之前，确保他所对应的元素不是null。所以如果selectArtist()返回的值是null，那么SpEL将不会调用toUpperCase()方法。表达式的返回值会是null。\n\n### 在表达式中使用类型\n\n如果要在SpEL中访问类作用域的方法和常量的话，要以来T()这个关键的运算符。例如，为了在SpEL中表达Java的Math类，需要按照如下的方式使用T()运算符：\n\nT(java.lang.Math)\n\n这里所示的T()运算符的结果是一个Class对象，代表了java.lang.Math。如果需要的话，我们甚至可以将其装配到一个class类型的bean属性中。但是T()运算符的真正价值在于它能够访问目标类型的静态方法和常量。例如要将PI的值装配到bean属性中。使用如下SpEL就能完成任务\n\nT(java.lang.Math).PI\n\n### SpEL运算符\n\nSpEL提供了多个运算符，这些运算符可以用在SpEL表达式上\n\n| 运算符类型 |                  运算符                  |\n| :--------: | :--------------------------------------: |\n|  算数运算  |             +、-、*、/、%、^             |\n|  比较运算  | <、>、 == 、 <= 、>=、lt、gt、eq、le、ge |\n|  逻辑运算  |             and、or、not、\\|             |\n|  条件运算  |         ?: (ternary)、?:(Elvis)          |\n| 正则表达式 |                 matches                  |\n\n\n\n### 计算集合\n\nSpEL中可以引用列表中的一个元素，例如：\n\n#{jukebox.songs[4].title}\n\n这个表达式会计算songs集合中第五个元素的title属性，这个集合来源于id为jukebox bean\n\n\"[]\"运算符除了可以从集合或数组按照索引获取元素，实际上，它还可以从String中获取一个字符。比如：\n\n#{'This is a test'[3]}\n\n这个表达式引用了String中的第四个字符，也就是“s”\n\nSpEL还提供了查询运算符(.?[])，他会对集合进行过滤，得到集合的一个子集。例如：\n\n#{jukebox.songs.?[artist eq 'Aerosmith']}\n\n这样就得到了Aerosmith的所有歌曲。当SpEL迭代歌曲列表时候，会对歌曲集合中的每一个条目计算这个表达式。如果表达式的计算结果是true的话，那么条目会放到新的集合中。否则，他就不会放到新的集合中。\n\nSpEL还提供了另外两个查询运算符：\".^[]\" 和\".$[]\",他们分别用来在集合中查询第一个匹配项和最后一个匹配项。最后，SpEL还提供了投影运算符(.![])，他会从集合的每个成员中选择特顶的属性放到另外一个集合中。                                                        ","tags":["Spring"]},{"title":"Spring bean的作用域","url":"/2019/11/19/Spring-bean的作用域/","content":"\nSpring bean的作用域\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## bean 的作用域\n\n默认情况下，Spring应用上下文中所有的bean都是作为以单例创建的的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。在大多数情况下，单例bean是很理想的方案，但是有时候所用的类是易变的，他们会保持一些状态，所以重用是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了，因为对象会被污染，稍后重用的时候会发生意想不到的问题。\n\nSpring定义了多种作用域，可以基于这些作用域创建bean，包括：\n\n+ 单例（Singleton）：在整个应用中，只创建一个bean的一个实例。\n+ 原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候都会创建一个新的bean实例。\n+ 会话（Session）：在web应用中，为每个会话创建一个bean实例。\n+ 请求（Request）；在web应用中，为每个请求创建一个bean实例。 \n\n单例是默认的作用域，但是正如之前所述对于易变的类型，这并不合适。如果选择其他的作用域，要使用@Scope注解，它可以与@Component注解和@Bean一起使用。\n\n例如如果使用组件扫描来发现和声明bean，那么可以在bean的类上使用@Scope注解，将其声明为原型的bean：\n\n```java\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class Notepad {\n}\n```\n\n这里使用ConfigurableBeanFactory的SCOPE_PROTOTYPE常量设置了原型作用域，当然也可以使用@Scope（\"prototype\")，但是使用常量更加安全且不容易出错。\n\n同样，如果使用xml来配置bean，可以使用bean标签的scope属性来设置作用域：\n\n```xml\n<bean id = \"noteped\" class = \"com.myapp.Notepad\" scope = \"protorype\" />\n```\n\n不管使用哪种方式来声明原型作用域，每次注入或从Spring应用上下文中检索该bean的时候都会创建新的实例。\n\n\n\n### 使用会话和请求作用域\n\n在web应用中如果能够实例化在会话和请求范围内共享的bean，那将是非常有价值的事情。例如，在典型的电子商务应用中，可能会有一个bean代表用户的购物车。如果购物车是单例的话，那么将会导致所有打的用户都会向同一个购物车中添加商品，在应用的另一个地方可能就不可用了，因为这里注入的是另外一个原型作用域的购物车。\n\n就购物车bean来说，会话作用域是最为合适的因为他与给定的用户关联性最大。要制定会话作用域，我们可以使用@Scope注解，他的使用方式和原型作用域是相同的\n\n ```java\n@Component\n@Scope(value = WebApplicationContext.SCOPE_SESSION ,\nproxyMode = ScopedProxyMode.INTERFACES)\npublic class ShoppingCart {\n}\n\n ```\n\n 这里我们将value设置成了WebApplicationContext.SCOPE_SESSION常量（它的值是session）。这回告诉Spring为Web应用中的每个会话创建一个ShoppingCart。这会创建多个ShoppingCart bean的实例，但是对于给定的会话只会创建一个实例，在当前会话相关的操作中，这个bean实际上相当于单例的。\n\n@Scope同时还有一个proxyMode属性，他被设置成了ScopedProxyMode.INTERFACES。这个属性解决了将对话或请求作用域的bean注入到单例bean中所遇到的问题。我们先来看一下proxyMode所解决问题的场景。\n\n假设我们要将ShoppingCart bean注入到单例storeService bean的Setter方法中，如下所示：\n\n```java\n@Component\npublic class StoreService {\n    private ShoppingCart shoppingCart;\n\n    @Autowired\n    public void setShoppingCart(ShoppingCart shoppingCart) {\n        this.shoppingCart = shoppingCart;\n    }\n}\n```\n\n因为StoreService是一个单例的bean，会在Spring应用上下文加载的时候创建。当它创建的时候，Spring会试图将ShoppingCart bean注入到setShoppingCart()方法中。但是shoppingCart bean 是会话作用域，此时并不存在，直到某个用户进入系统，创建了会话之后，才会出现ShoppingCart实例。\n\n另外，系统中将会有多个ShoppingCart实例：每个用户一个。我们并不想让Spring注入某个固定的ShoppingCart 实例到StoreService中。我们希望的是当StoreService处理购物车功能时，它所使用的ShoppingCart实例刚好是当前会话所对应的那个。\n\nSpring并不会将实际的ShoppingCart bean 注入到StoreService中，Spring会注入一个到ShoppingCart bean 的代理，这个代理会暴露与ShoppingCart相同的方法，所以StoreService会认为啊就是一个购物车。但是，当StoreService嗲啊用ShoppingCart的方法时，代理会对其进行懒解析并且将调用委托给会话作用域内的真正的ShoppingCart bean。\n\n如配置所示，proxyMode属性被设置为了ScopedProxyMode.INTERFACES，这表明这个代理要实现ShoppingCart接口，并且调用委托给实现bean。\n\n如果ShoppingCart是接口而不是类的话，这是可以的。但如果ShoppingCart是一个具体的二类的话，Sping就没有办法创建基于接口的代理了。所以，如果bean类型是具体类的话，我们必须要将proxyMode属性设置为ScopedProxyMode.TARGET_CLASS，以此来表明要以生成目标扩展的方式创建代理。\n\n","tags":["Spring"]},{"title":"设计模式-命令模式","url":"/2019/11/07/设计模式-命令模式/","content":"\n设计模式之命令模式\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 命令模式\n\n ## 定义\n\n命令模式讲请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。\n\n一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。要达到这一点，命令对象将动作和接收者包进对象中。这个对象只暴露出一个execute()方法，当此方法呗调用的时候，接收者就会进行这些动作。从外面来看，其他对象不知道究竟哪个接收者进行了哪些动作，只知道如果调用execute（）方法，请求的目的就能达到。\n\n\n\n## 简单命令模式代码示例\n\n\n\n```java\npackage restaurant;\n\n/**\n * @ClassName: Command\n * @Author: 1\n * @Description:\n * @Version: 1.0\n */\npublic interface Command {\n    public void execute();\n}\n\n```\n\n```java\npackage restaurant;\n\n/**\n * @ClassName: Light\n * @Author: 1\n * @Description:\n * @Version: 1.0\n */\npublic class Light {\n    public void on() {\n        System.out.println(\"light on\");\n    }\n}\n\n```\n\n```java\npackage restaurant;\n\n/**\n * @ClassName: LightOnCommand\n * @Author: 1\n * @Description:\n * @Version: 1.0\n */\npublic class LightOnCommand implements Command {\n    Light light;\n\n    public LightOnCommand(Light light) {\n        this.light = light;\n    }\n\n    @Override\n    public void execute() {\n        light.on();\n\n    }\n}\n\n```\n\n```java\npackage restaurant;\n\n/**\n * @ClassName: SimpleRemoteControl\n * @Author: 1\n * @Description:\n * @Version: 1.0\n */\npublic class SimpleRemoteControl {\n    Command command;\n\n    public SimpleRemoteControl() {\n    }\n\n    public void setCommand(Command command) {\n        this.command = command;\n    }\n\n    public void buttonWasPressed() {\n        command.execute();\n    }\n}\n\n```\n\n```java\npackage restaurant;\n\n/**\n * @ClassName: RemoteControlTest\n * @Author: 1\n * @Description:\n * @Version: 1.0\n */\npublic class RemoteControlTest {\n    public static void main(String [] args) {\n        SimpleRemoteControl remote = new SimpleRemoteControl();\n        Light light = new Light();\n        LightOnCommand lightOn = new LightOnCommand(light);\n        remote.setCommand(lightOn);\n        remote.buttonWasPressed();\n    }\n}\n```\n\n通过运行RemoteControlTest的Main函数得到运行结果\n\n```java\nlight on\n\n```\n\n## 遥控器实现\n\n遥控器有多个按钮，每个按钮对应不同的操作。我们打算将遥控器的每个按钮对应到一个命令，这样就可以让遥控器变成调用者，当按下按钮时，相应命令对象的execute()方法就会被i调用，结果就是接收者的动作被调用。\n\n\n\n```java\npackage remote;\n\n\n\n/**\n * @ClassName: RemoteControl\n * @Author: 1\n * @Description:\n * @Version: 1.0\n */\npublic class RemoteControl {\n    Command[] onCommands;\n    Command[] offCommands;\n\n    public RemoteControl() {\n        onCommands = new Command[7];\n        offCommands = new Command[7];\n\n        Command noCommand = new NoCommand();\n        for (int i = 0; i < 7; i++) {\n            onCommands[i] = noCommand;\n            offCommands[i] = noCommand;\n        }\n    }\n\n    public void setCommand(int slot, Command onCommand, Command offCommand) {\n        onCommands[slot] = onCommand;\n        offCommands[slot] = offCommand;\n    }\n\n    public void onButtonWasPushed(int slot) {\n        onCommands[slot].execute();\n    }\n\n    public void offButtonWasPushed(int slot) {\n        offCommands[slot].execute();\n    }\n\n    @Override\n    public String toString() {\n        StringBuffer stringBuffer = new StringBuffer();\n        stringBuffer.append(\"\\n ---------Remote Control --------\\n\");\n        for (int i = 0; i < onCommands.length; i++) {\n            stringBuffer.append(\"[slot\" + i + \"] \" + onCommands.getClass().getName() +\n                    \" \" + offCommands[i].getClass().getName() + \"\\n\");\n\n        }\n        return stringBuffer.toString();\n    }\n\n}\n\n```\n\n\n\n```java\npackage remote;\n\n/**\n * @ClassName: NoCommand\n * @Author: 1\n * @Description:\n * @Version: 1.0\n */\npublic class NoCommand implements Command {\n    @Override\n    public void execute() {\n\n    }\n}\n\n```\n\n\n\n```java\npackage remote;\n/**\n * @ClassName: RemoteLoader\n * @Author: 1\n * @Description:\n * @Version: 1.0\n */\npublic class RemoteLoader {\n    public static void main(String[] args) {\n        RemoteControl remoteControl = new RemoteControl();\n        Light light = new Light();\n\n        Command lightOnCommand = new LightOnCommand(light);\n        Command lightOffCommand = new LightOffCommand(light);\n\n        remoteControl.setCommand(0,lightOnCommand,lightOffCommand);\n        remoteControl.onButtonWasPushed(0);\n        remoteControl.offButtonWasPushed(0);\n    }\n}\n\n```\n\nRemoteLoader中，将命令对象通过setCommand方法为每个插槽的按钮绑定事件。通过调用\n\nonButtonWasPushed和offButtonWasPushed来控制第几个按钮的开和关动作。上述代码中，为了不想每次都检查某个插槽是否加载了命令，比如在onButtonWasPushed()方法中我们需要添加验证是否是空\n\n```java\n    public void onButtonWasPushed(int slot) {\n    if ( onCommands[slot] != null){\n          onCommands[slot].execute();\n    }\n    }\n```\n\n为了避免上述做法，我们实现了一个不做任何事情的命令，这么一来在RemoteControl构造器中，我们将每个插槽都预先指定NoCommand对象，以便确定每个插槽永远都有对象。所以在测试的输出中，没有被明确指定命令的插槽，其命令将是默认的NoCommand对象。举例来说，遥控器不可能一出厂就设置了有意义的命令对象，所以提供了NoCommand对象作为代用品，当调用他的execute（）方法时，这种对象什么事情都不做。在组多设计模式中，都会看到空对象的使用。甚至有些时候，空对象本身也被视为是一种设计模式。\n\n最后我们需要添加对撤销按钮的支持。撤销按钮会将上一个动作取消，例如电灯是关闭的当你按下开启按钮后打开，继续按下撤销按钮时，开启操作应该被撤销，灯应该回到熄灭状态。我们首先将Command接口添加一个撤回的方法\n\n```java\npublic interface Command {\n    public void execute();\n\n    public void undo();\n}\n```\n\n之后在各个命令中实现undo方法，对于撤销来说也就是应该执行与当前命令相反的命令，关闭灯的撤销命令就应该开启灯。\n\n```java\npublic class LightOffCommand implements Command {\n    Light light;\n\n    public LightOffCommand(Light light) {\n        this.light = light;\n    }\n\n    @Override\n    public void execute() {\n        light.off();\n\n    }\n\n    @Override\n    public void undo() {\n        light.on();\n    }\n}\n\n```\n\n```java\npackage remote;\n\n\n\n/**\n * @ClassName: LightOnCommand\n * @Author: 1\n * @Description:\n * @Version: 1.0\n */\npublic class LightOnCommand implements Command {\n    Light light;\n\n    public LightOnCommand(Light light) {\n        this.light = light;\n    }\n\n    @Override\n    public void execute() {\n        light.on();\n\n    }\n\n    @Override\n    public void undo() {\n        light.off();\n    }\n}\n\n```\n\n最后我们要对遥控器做一些小修改。能够让他追踪最后被调用的命令，不管何时撤销按钮被按下我们都可以取出这个命令并调用它的undo方法。\n\n```java\npackage remote;\n\n\n/**\n * @ClassName: RemoteControl\n * @Author: 1\n * @Description:\n * @Version: 1.0\n */\npublic class RemoteControlWithUndo {\n    Command[] onCommands;\n    Command[] offCommands;\n    // 记录上一次操作的命令变量\n    Command undoCommand;\n\n    public RemoteControlWithUndo() {\n        onCommands = new Command[7];\n        offCommands = new Command[7];\n\n        Command noCommand = new NoCommand();\n        for (int i = 0; i < 7; i++) {\n            onCommands[i] = noCommand;\n            offCommands[i] = noCommand;\n        }\n        undoCommand = noCommand;\n    }\n\n    public void setCommand(int slot, Command onCommand, Command offCommand) {\n        onCommands[slot] = onCommand;\n        offCommands[slot] = offCommand;\n    }\n\n    public void onButtonWasPushed(int slot) {\n        onCommands[slot].execute();\n        // 每次执行命令的时候都赋值给undoCommand\n        undoCommand = onCommands[slot];\n    }\n\n    public void offButtonWasPushed(int slot) {\n        offCommands[slot].execute();\n        undoCommand = offCommands[slot];\n    }\n\n    public void undoButtonWasPushed() {\n        undoCommand.undo();\n    }\n\n    @Override\n    public String toString() {\n        StringBuffer stringBuffer = new StringBuffer();\n        stringBuffer.append(\"\\n ---------Remote Control --------\\n\");\n        for (int i = 0; i < onCommands.length; i++) {\n            stringBuffer.append(\"[slot\" + i + \"] \" + onCommands.getClass().getName() +\n                    \" \" + offCommands[i].getClass().getName() + \"\\n\");\n\n        }\n        return stringBuffer.toString();\n    }\n\n}\n\n```\n\n## 要点\n\n+ 命令模式将发出请求的对象和执行请求的对象解耦。\n+ 在被解耦的两者之间是通过命令对象进行沟通的，命令对象封装了接收者和一个或一组动作。\n+ 调用者通过调用命令对象的execute（）发出请求，这会使得接受者的动作被调用。\n+ 调用者可以接受命令当作参数，甚至在运行时动态的进行。\n+ 命令可以支持撤销，做法是实现一个undo（）方法来回到execute（）被执行的状态。","tags":["设计模式"]},{"title":"设计模式--单例模式","url":"/2019/10/13/设计模式-单例模式/","content":"\n设计模式之单例模式\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 单例模式\n\n单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n\n下面直接上代码：\n\n```java\npackage singleton;\n\n/**\n * @ClassName: Singleton\n * @Author: 1\n * @Description:\n * @Version: 1.0\n */\npublic class Singleton {\n\n    private static Singleton uniqueInstance;\n\n    private Singleton() {\n\n    }\n\n    public static Singleton getInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n\n}\n\n```\n\n通过构造方法私有化，使用getInstance来获取实例，如果刚开始uniqueInstance为空则new一个实例出来。\n\n","tags":["设计模式"]},{"title":"设计模式--装饰者模式","url":"/2019/10/12/设计模式-装饰者模式/","content":"\n设计模式之装饰者模式\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 装饰者模式\n\n装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。\n\n拿一个很常见的事来举例：吃火锅。我们吃火锅的时候首先需要点锅底，锅底有很多种，如清汤，牛油，番茄，鸳鸯等。点完锅底之后我们需要点菜品。那么我们如何来设计一个火锅类来表示一个火锅里到底有什么菜品？比较容易想到的事建立一个火锅类，然后在类中设置不同的布尔变量来标记火锅中是否有某种菜品。这样是可行的，但是却存在一些缺点，当我们需要去扩展代码时候，例如火锅店又推出了几款新的菜品或者删除了几款菜品，我们都需要在火锅类的代码里进行增加或者删除代码。我们违反了一个设计模式中的重要原则：类应该对扩展开放，对修改关闭。我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。具体设计如下：\n\n1.建立火锅的超类(被装饰对象超类)：\n\n```java\npublic abstract class HuoGuo {\n    public abstract float cost();\n\n    public abstract String name();\n}\n\n```\n\n\n\n2.定义具体锅底（具体被装饰对象）：\n\n```java\npublic class FanQieGuo extends HuoGuo {\n    @Override\n    public float cost() {\n        return 66.6f;\n    }\n\n    @Override\n    public String name() {\n        return \"番茄锅底\";\n    }\n}\n\npublic class NiuYouGuo extends CaiPin {\n\n    @Override\n    public float cost() {\n        return 88.8f;\n    }\n\n    @Override\n    public String name() {\n        return \"牛油锅低\";\n    }\n}\n\n```\n\n3.定义菜品抽象类（装饰者超类）：\n\n```java\npublic abstract class CaiPin extends HuoGuo {\n    HuoGuo guoDi;\n}\n\n```\n\n4.定义具体菜品（具体的装饰者）：\n\n```java\npublic class FeiNiu extends CaiPin {\n\n    public FeiNiu(HuoGuo guoDi) {\n        this.guoDi = guoDi;\n\n    }\n\n    @Override\n    public float cost() {\n        return guoDi.cost() + 50f;\n    }\n\n    @Override\n    public String name() {\n        return guoDi.name() + \" + 肥牛\";\n    }\n}\n\npublic class MaoDu extends CaiPin {\n\n    public MaoDu(HuoGuo guoDi) {\n        this.guoDi = guoDi;\n    }\n\n    @Override\n    public float cost() {\n        return guoDi.cost() + 40f;\n    }\n\n    @Override\n    public String name() {\n        return guoDi.name() + \" + 毛肚\";\n    }\n}\n```\n\n5.测试\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        HuoGuo huoGuo = new FanQieGuo();\n        huoGuo = new FeiNiu(huoGuo);\n        huoGuo = new MaoDu(huoGuo);\n        System.out.println(huoGuo.name() + \" 共计 \" + huoGuo.cost() + \"元\");\n\n    }\n}\n\n```\n\n","tags":["设计模式"]},{"title":"设计模式--工厂模式","url":"/2019/10/10/设计模式-工厂模式/","content":"\n设计模式之工厂模式。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 工厂模式\n\n## 简单工厂\n\n简单工厂的定义：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类。\n\n假如有一个披萨店，当下订单的时候代码可能是这样写的：\n\n```java\nPizza orderPizza() {\n\tPizza pizza = new Pizza();\n\tpizza.prepare();\n\tpizza.bake();\n\tpizza.cut();\n\tpizza.box();\n\treturn pizza;\n}\n```\n\n我们发现在上述代码中实例化对象的时候使用了 new Object()的形式。但对于披萨来说，有很多类型。所以为了能够按照用户下单时所选择的类型进行制作披萨，必须增加一些代码。\n\n```java\nPizza orderPizza() {\n\tPizza pizza;\n\t/**\n\t * 根据pizza的类型来实例化具体的类，然后赋值给pizza变量。值得注意的是，这里的任何披萨都必须实现Pizza接口\n\t */\n\tif (type.equals(\"cheese\")) {\n\t\tpizza = new CheesePizza();\n\t} else if (type.equals(\"pepperoni\")) {\n\t\tpizza = new PepperoniPizza();\n\t} else if (type.equals(\"clam\")) {\n\t\tpizza = new ClamPizza();\n\t} else if (type.equals(\"veggie\")) {\n\t\tpizza = new VeggiePizza();\n\t}\n\tpizza.prepare();\n\tpizza.bake();\n\tpizza.cut();\n\tpizza.box();\n\treturn pizza;\n}\n```\n\n但是在经营过程中，可能有的一些新口味的披萨开始流行需要加入到菜单中，或是有的口味的披萨由于销售量太低想从菜单中去除。随着时间的变化，对应的代码就必须一改再改。而对于pizza的制作过程来说是不易改变的。考虑到已经知道哪些会改变，哪些不会改变，该是使用封装的时候了。我们应该将披萨对象的创建移动到orderPizza()之外，把创建披萨的代码移动到另外一个对象中，让这个新对象专职创建披萨。我们称这个新对象就为“工厂”。\n\n将披萨的生成交给工厂后，orderPizza()方法便不在需要关心生成披萨的细节问题，只关心从工厂得到了一个披萨，并且这个披萨实现了Pizza接口，所以它可以调用prepare(),bake(),cut(),box()来进行准备、烘烤 、切片、装盒。具体实现代码如下：\n\n```java\npackage pizzas;\n\npublic class SimplePizzaFactory {\n\t/**\n\t * 创建pizza对象的工厂方法\n\t */\n\tpublic Pizza createPizza(String type) {\n\t\tPizza pizza = null;\n\n\t\tif (type.equals(\"cheese\")) {\n\t\t\tpizza = new CheesePizza();\n\t\t} else if (type.equals(\"pepperoni\")) {\n\t\t\tpizza = new PepperoniPizza();\n\t\t} else if (type.equals(\"clam\")) {\n\t\t\tpizza = new ClamPizza();\n\t\t} else if (type.equals(\"veggie\")) {\n\t\t\tpizza = new VeggiePizza();\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n```\n\n\n\n```java\npackage pizzas;\n\npublic class PizzaStore {\n\tSimplePizzaFactory factory;\n \n\tpublic PizzaStore(SimplePizzaFactory factory) { \n\t\tthis.factory = factory;\n\t}\n \n\tpublic Pizza orderPizza(String type) {\n\t\tPizza pizza;\n \t\t//把new一个对象替换为用工厂对象创建对象，不再使用具体实例化。\n\t\tpizza = factory.createPizza(type);\n \n\t\tpizza.prepare();\n\t\tpizza.bake();\n\t\tpizza.cut();\n\t\tpizza.box();\n\n\t\treturn pizza;\n\t}\n\n}\n\n```\n\n\n\n## 工厂方法\n\n工厂方法模式是对简单工厂模式进一步的解耦，因为在工厂方法模式中是一个子类对应一个工厂类，而这些工厂类都实现于一个抽象接口。这相当于是把原本会因为业务代码而庞大的简单工厂类，拆分成了一个个的工厂类，这样代码就不会都耦合在同一个类里了。\n\n还是拿披萨店来举例子，当披萨店的经济效益越来越好，大家都希望披萨店能够有更多的加盟店。但是不同区域的加盟店提供的披萨口味可能存在差异。如果利用简单工厂写出几种不同的工厂来对应不同区域的确可以解决披萨口味不同的问题。但是对于其他部分却限制不够，各地的加盟店可以对制作流程进行改变，有的店可能会选择不将披萨切片，或者使用其他厂商的包装盒。但是作为一种品牌的加盟，希望的是能够有统一的标准，所以品牌会希望建立一个框架，能够把加盟店和创建披萨捆绑在一起，并且还能保持一定的弹性。\n\n有个做法可以让披萨制作活动局限于PizzaStore类，而同时又能让这些加盟店依然可以自由的制作该地区的口味。我们将createPizza()方法放回到PizzaStore中并且将它设置成抽象方法，然后为每个区域口味来创建一个PizzaStore的子类。\n\n```java\npackage pizzafm;\n\npublic abstract class PizzaStore {\n \n\tabstract Pizza createPizza(String item);\n \n\tpublic Pizza orderPizza(String type) {\n\t\tPizza pizza = createPizza(type);\n\t\tSystem.out.println(\"--- Making a \" + pizza.getName() + \" ---\");\n\t\tpizza.prepare();\n\t\tpizza.bake();\n\t\tpizza.cut();\n\t\tpizza.box();\n\t\treturn pizza;\n\t}\n}\n```\n\n现在有了一个PizzaStore作为超类，让每个区域类型都继承这个超类，然后自己决定如何制造披萨。\n\n对于披萨本身来说，我们也需要一个超类，让不同类别的披萨能够继承这个超类。\n\n```java\npackage pizzafm;\n\nimport java.util.ArrayList;\n\npublic abstract class Pizza {\n    String name;\n    String dough;\n    String sauce;\n    ArrayList<String> toppings = new ArrayList<String>();\n\n    void prepare() {\n        System.out.println(\"Prepare \" + name);\n        System.out.println(\"Tossing dough...\");\n        System.out.println(\"Adding sauce...\");\n        System.out.println(\"Adding toppings: \");\n        for (String topping : toppings) {\n            System.out.println(\"   \" + topping);\n        }\n    }\n\n    void bake() {\n        System.out.println(\"Bake for 25 minutes at 350\");\n    }\n\n    void cut() {\n        System.out.println(\"Cut the pizza into diagonal slices\");\n    }\n\n    void box() {\n        System.out.println(\"Place pizza in official PizzaStore box\");\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public String toString() {\n        StringBuffer display = new StringBuffer();\n        display.append(\"---- \" + name + \" ----\\n\");\n        display.append(dough + \"\\n\");\n        display.append(sauce + \"\\n\");\n        for (String topping : toppings) {\n            display.append(topping + \"\\n\");\n        }\n        return display.toString();\n    }\n}\n```\n\n现在我们已经创建了披萨和商店的超类，接下来是他们的实现类\n\n```java\npackage pizzafm;\n\npublic class ChicagoStyleCheesePizza extends Pizza {\n\n\tpublic ChicagoStyleCheesePizza() { \n\t\tname = \"Chicago Style Deep Dish Cheese Pizza\";\n\t\tdough = \"Extra Thick Crust Dough\";\n\t\tsauce = \"Plum Tomato Sauce\";\n \n\t\ttoppings.add(\"Shredded Mozzarella Cheese\");\n\t}\n \n\t@Override\n\tvoid cut() {\n\t\tSystem.out.println(\"Cutting the pizza into square slices\");\n\t}\n}\n\n```\n\n```java\npackage pizzafm;\n\npublic class ChicagoStyleClamPizza extends Pizza {\n\tpublic ChicagoStyleClamPizza() {\n\t\tname = \"Chicago Style Clam Pizza\";\n\t\tdough = \"Extra Thick Crust Dough\";\n\t\tsauce = \"Plum Tomato Sauce\";\n \n\t\ttoppings.add(\"Shredded Mozzarella Cheese\");\n\t\ttoppings.add(\"Frozen Clams from Chesapeake Bay\");\n\t}\n \n\t@Override\n\tvoid cut() {\n\t\tSystem.out.println(\"Cutting the pizza into square slices\");\n\t}\n}\n\n```\n\n```java\npackage pizzafm;\n\npublic class ChicagoStylePepperoniPizza extends Pizza {\n\tpublic ChicagoStylePepperoniPizza() {\n\t\tname = \"Chicago Style Pepperoni Pizza\";\n\t\tdough = \"Extra Thick Crust Dough\";\n\t\tsauce = \"Plum Tomato Sauce\";\n \n\t\ttoppings.add(\"Shredded Mozzarella Cheese\");\n\t\ttoppings.add(\"Black Olives\");\n\t\ttoppings.add(\"Spinach\");\n\t\ttoppings.add(\"Eggplant\");\n\t\ttoppings.add(\"Sliced Pepperoni\");\n\t}\n \n\t@Override\n\tvoid cut() {\n\t\tSystem.out.println(\"Cutting the pizza into square slices\");\n\t}\n}\n\n```\n\n```java\npackage pizzafm;\n\npublic class ChicagoStyleVeggiePizza extends Pizza {\n\tpublic ChicagoStyleVeggiePizza() {\n\t\tname = \"Chicago Deep Dish Veggie Pizza\";\n\t\tdough = \"Extra Thick Crust Dough\";\n\t\tsauce = \"Plum Tomato Sauce\";\n \n\t\ttoppings.add(\"Shredded Mozzarella Cheese\");\n\t\ttoppings.add(\"Black Olives\");\n\t\ttoppings.add(\"Spinach\");\n\t\ttoppings.add(\"Eggplant\");\n\t}\n \n\t@Override\n\tvoid cut() {\n\t\tSystem.out.println(\"Cutting the pizza into square slices\");\n\t}\n}\n\n```\n\n```java\npackage pizzafm;\n\npublic class NYStyleCheesePizza extends Pizza {\n\n\tpublic NYStyleCheesePizza() { \n\t\tname = \"NY Style Sauce and Cheese Pizza\";\n\t\tdough = \"Thin Crust Dough\";\n\t\tsauce = \"Marinara Sauce\";\n \n\t\ttoppings.add(\"Grated Reggiano Cheese\");\n\t}\n}\n\n```\n\n```java\npackage pizzafm;\n\npublic class NYStyleClamPizza extends Pizza {\n\n\tpublic NYStyleClamPizza() {\n\t\tname = \"NY Style Clam Pizza\";\n\t\tdough = \"Thin Crust Dough\";\n\t\tsauce = \"Marinara Sauce\";\n \n\t\ttoppings.add(\"Grated Reggiano Cheese\");\n\t\ttoppings.add(\"Fresh Clams from Long Island Sound\");\n\t}\n}\n\n```\n\n```java\npackage pizzafm;\n\npublic class NYStylePepperoniPizza extends Pizza {\n\n\tpublic NYStylePepperoniPizza() {\n\t\tname = \"NY Style Pepperoni Pizza\";\n\t\tdough = \"Thin Crust Dough\";\n\t\tsauce = \"Marinara Sauce\";\n \n\t\ttoppings.add(\"Grated Reggiano Cheese\");\n\t\ttoppings.add(\"Sliced Pepperoni\");\n\t\ttoppings.add(\"Garlic\");\n\t\ttoppings.add(\"Onion\");\n\t\ttoppings.add(\"Mushrooms\");\n\t\ttoppings.add(\"Red Pepper\");\n\t}\n}\n\n```\n\n```java\npackage pizzafm;\n\npublic class NYStyleVeggiePizza extends Pizza {\n\n\tpublic NYStyleVeggiePizza() {\n\t\tname = \"NY Style Veggie Pizza\";\n\t\tdough = \"Thin Crust Dough\";\n\t\tsauce = \"Marinara Sauce\";\n \n\t\ttoppings.add(\"Grated Reggiano Cheese\");\n\t\ttoppings.add(\"Garlic\");\n\t\ttoppings.add(\"Onion\");\n\t\ttoppings.add(\"Mushrooms\");\n\t\ttoppings.add(\"Red Pepper\");\n\t}\n}\n\n```\n\n```java\npackage pizzafm;\n\npublic class ChicagoPizzaStore extends PizzaStore {\n\n    @Override\n    Pizza createPizza(String item) {\n        if (item.equals(\"cheese\")) {\n            return new ChicagoStyleCheesePizza();\n        } else if (item.equals(\"veggie\")) {\n            return new ChicagoStyleVeggiePizza();\n        } else if (item.equals(\"clam\")) {\n            return new ChicagoStyleClamPizza();\n        } else if (item.equals(\"pepperoni\")) {\n            return new ChicagoStylePepperoniPizza();\n        } else {\n            return null;\n        }\n    }\n}\n\n```\n\n```java\npackage pizzafm;\n\npublic class NYPizzaStore extends PizzaStore {\n\n    @Override\n    Pizza createPizza(String item) {\n        if (item.equals(\"cheese\")) {\n            return new NYStyleCheesePizza();\n        } else if (item.equals(\"veggie\")) {\n            return new NYStyleVeggiePizza();\n        } else if (item.equals(\"clam\")) {\n            return new NYStyleClamPizza();\n        } else if (item.equals(\"pepperoni\")) {\n            return new NYStylePepperoniPizza();\n        } else {\n            return null;\n        }\n    }\n}\n\n```\n\n\n\n最后创建测试类：\n\n```java\npackage pizzafm;\n\npublic class PizzaTestDrive {\n \n\tpublic static void main(String[] args) {\n\t\tPizzaStore nyStore = new NYPizzaStore();\n\t\tPizzaStore chicagoStore = new ChicagoPizzaStore();\n \n\t\tPizza pizza = nyStore.orderPizza(\"cheese\");\n\t\tSystem.out.println(\"Ethan ordered a \" + pizza.getName() + \"\\n\");\n \n\t\tpizza = chicagoStore.orderPizza(\"cheese\");\n\t\tSystem.out.println(\"Joel ordered a \" + pizza.getName() + \"\\n\");\n\n\t\tpizza = nyStore.orderPizza(\"clam\");\n\t\tSystem.out.println(\"Ethan ordered a \" + pizza.getName() + \"\\n\");\n\n\t\tpizza = chicagoStore.orderPizza(\"clam\");\n\t\tSystem.out.println(\"Joel ordered a \" + pizza.getName() + \"\\n\");\n\n\t\tpizza = nyStore.orderPizza(\"pepperoni\");\n\t\tSystem.out.println(\"Ethan ordered a \" + pizza.getName() + \"\\n\");\n\n\t\tpizza = chicagoStore.orderPizza(\"pepperoni\");\n\t\tSystem.out.println(\"Joel ordered a \" + pizza.getName() + \"\\n\");\n\n\t\tpizza = nyStore.orderPizza(\"veggie\");\n\t\tSystem.out.println(\"Ethan ordered a \" + pizza.getName() + \"\\n\");\n\n\t\tpizza = chicagoStore.orderPizza(\"veggie\");\n\t\tSystem.out.println(\"Joel ordered a \" + pizza.getName() + \"\\n\");\n\t}\n}\n\n```\n\n\n\n## 抽象工厂\n\n在上述的例子中，比萨店的设计已经变得很棒：具有弹性的框架，而且遵循设计原则。现在，比萨店的成功关键在于新鲜高质量的原料。而且通过导入新的框架，加盟店将遵循你的流程，但是有一些加盟店使用低价的原料来增加利润。如何确保每家加盟店使用高质量的原料变成了一个问题。\n\n为了解决原料的问题，我们要建一个工厂来生产原料，这个工厂负责创建原料家族中的每一种原料。我们需要做的事：\n\n1.为工厂定义一个接口，这个接口负责创建所有的原料\n\n2.为每个区域建造一个工厂。需要创建一个继承自PizzaIngredientFactory的子类来实现每一个创建方法\n\n3.实现一组原料类供工厂使用，这些类可以在合适的区域间共享\n\n4.然后最后将一切组织起来，将新的原料工厂整合进久得PizzaStore代码中\n\n\n\n在创建披萨的时候通过工厂的形式来创建原材料\n\n```java\n\t\tPizzaIngredientFactory ingredientFactory = \n\t\t\tnew NYPizzaIngredientFactory();\n```\n\nNYPizzaIngredientFactory是一个实现了PizzaIngredientFactory的类,其中函数返回的对象都是实现了对应接口的原材料。\n\n```java\npackage pizzaaf;\n\npublic class NYPizzaIngredientFactory implements PizzaIngredientFactory {\n\n\tpublic Dough createDough() {\n\t\treturn new ThinCrustDough();\n\t}\n\n\tpublic Sauce createSauce() {\n\t\treturn new MarinaraSauce();\n\t}\n\n\tpublic Cheese createCheese() {\n\t\treturn new ReggianoCheese();\n\t}\n\n\tpublic Veggies[] createVeggies() {\n\t\tVeggies veggies[] = { new Garlic(), new Onion(), new Mushroom(), new RedPepper() };\n\t\treturn veggies;\n\t}\n\n\tpublic Pepperoni createPepperoni() {\n\t\treturn new SlicedPepperoni();\n\t}\n\n\tpublic Clams createClam() {\n\t\treturn new FreshClams();\n\t}\n}\n\n```\n\n```java\npackage pizzaaf;\n\npublic interface PizzaIngredientFactory {\n \n\tpublic Dough createDough();\n\tpublic Sauce createSauce();\n\tpublic Cheese createCheese();\n\tpublic Veggies[] createVeggies();\n\tpublic Pepperoni createPepperoni();\n\tpublic Clams createClam();\n \n}\n\n```\n\n完整代码请访问 https://github.com/caicaing/pizzaaf\n\n\n\n一连串的代码的改变，我们到底做了什么？我们通过引入新类型的工厂，也就是所谓的抽象工厂，来创建披萨家族。通过抽象工厂所提供的接口，可以创建产品的家族，利用这个接口书写代码。我们的代码将从实际工厂解耦，以便于在不同上下文中实现各式各样的工厂，制造出各种不同的产品。因为代码从实际的产品中解耦了，所以我们可以替换不同的工厂来取得不同的行为。","tags":["设计模式"]},{"title":"设计模式--观察者模式","url":"/2019/10/08/设计模式-观察者模式/","content":"\n设计模式之观察者模式。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 观察者模式\n\n## 概念\n\n观察者模式（有时又被称为模型（Model）-视图（View）模式、源-收听者(Listener)模式或从属者模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。\n\n## 优缺点\n\n观察者模式的主要的作用就是对对象解耦，将观察者和被观察者完全隔离。\n\n1、观察者模式的优点\n\n观察者模式解除了主题和具体观察者的[耦合](https://baike.baidu.com/item/耦合/2821124)，让耦合的双方都依赖于抽象，而不是依赖具体。\n\n2、观察者模式的缺点\n\n在应用观察者模式时需要考虑一下开发小路问题，程序中包括一个被观察者和多个被观察者，开发和调试比较复杂，而且Java中的消息的通知默认是顺序执行的，一个观察者的卡顿会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。\n\n## 观察者模式应用\n\n引入一个很常见的案例。现在有一家气象站负责发布气象消息。客户希望气象站能够建立一个应用，有三种布告板，分别显示目前的状况，气象统计以及简单的预报。当获得最新的测量数据的时候，三种布告板必须实时更新。而且要求这是一个可以扩展的气象站，气象站需要公布一组API，好让其他开发人员可以写出自己的气象布告板并且插入此应用中。\n\n此系统中的三个部分是气象站（获取实际气象数据的物理装置）、WeatherData对象（追踪来自气象站的数据，并更新布告板）和布告板（显示目前天气状况给用户看）。\n\n![](设计模式-观察者模式/1.jpg)\n\n如果了解报纸的订阅是怎么回事，其实就可以理解观察者模式是怎回事了，只是名称不太一样。对于报纸的订阅来说：\n\n1、报社的业务就是出版报纸\n\n2、向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的门户，你就会一直收到新报纸。\n\n3、当你不再想看报纸的时候，取消订阅，他们就不会再送新报纸来。\n\n4、只要报社还在运营，就会一直有人向他们订阅报纸或者取消订阅报纸。\n\n\n\n接下来按照观察者模式的思路来实现气象站：\n\n首先创建观察者和主题的接口和展示数据的接口\n\n```java\n\npublic interface Observer {\n    /**\n     * 更新数据\n     */\n    void update(float temp, float humidity, float pressure);\n}\n\n```\n\n\n\n```java\n\npublic interface Subject {\n\n    /**\n     * 注册一个观察者\n     */\n    void registerObserver(Observer observer);\n\n    /**\n     * 移除一个观察者\n     */\n\n    void removeObserver(Observer observer);\n\n    /**\n     * 更新后提醒\n     */\n\n    void notifyObservers();\n}\n```\n\n```java\npublic interface DisplayElement {\n    /**\n     * 展示数据\n     */\n    public void display();\n}\n\n```\n\n创建气象站类，并实现主题的接口：\n\n```java\nimport java.util.ArrayList;\n\npublic class WeatherData implements Subject {\n\n    private float temperature;\n\n    private float humidity;\n\n    private float pressure;\n\n    private ArrayList<Observer> observers;\n\n    public WeatherData() {\n        observers = new ArrayList();\n    }\n\n\n    @Override\n    public void registerObserver(Observer observer) {\n        observers.add(observer);\n    }\n\n    @Override\n    public void removeObserver(Observer observer) {\n        int i = observers.indexOf(observer);\n        if (i >= 0) {\n            observers.remove(observer);\n        }\n    }\n\n    @Override\n    public void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(temperature, humidity, pressure);\n        }\n    }\n\n    public void measurementsChanged() {\n        notifyObservers();\n    }\n\n    public void setMeasurements(float temperature, float humidety, float pressure){\n        this.temperature = temperature;\n        this.humidity = humidety;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n\n\n}\n\n```\n\n创建观察者类并实现接口：\n\n```java\npublic class ConcreteObserver implements Observer ,DisplayElement{\n\n    private float tempreature;\n\n    private float humidity;\n\n    private float pressure;\n\n    private Subject weatherData;\n    public ConcreteObserver(Subject weatherData){\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void update(float tempreature, float humidity, float pressure) {\n        this.tempreature = tempreature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        display();\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"tempreature = \" + tempreature + \" humidity = \" + humidity + \" pressure =\" + pressure);\n    }\n}\n\n```\n\n创建测试类：\n\n```java\n\npublic class WeatherStation {\n    public static void main(String[] args) {\n        WeatherData weatherData = new WeatherData();\n\n        ConcreteObserver concreteObserver = new ConcreteObserver(weatherData);\n        weatherData.setMeasurements(50, 42, 30);\n    }\n}\n\n```\n\n## Java内置的观察者模式\n\n在java.util包中，包含了最基本的Observer接口和Observable类，并且已经事先准备好了许多功能，你甚至可以用push或者pull的方式传送数据。\n\n利用内置的观察者模式重做气象站：\n\n```java\npackage obser;\nimport observe.DisplayElement;\n\nimport java.util.Observable;\nimport java.util.Observer;\n\npublic class ConcreteObserver implements Observer, DisplayElement {\n\n    float tempreature;\n\n    float humidity;\n\n    float pressure;\n\n    private Observable observable;\n\n    public ConcreteObserver(Observable observable) {\n\n        this.observable = observable;\n        observable.addObserver(this);\n    }\n\n\n    @Override\n    public void display() {\n        System.out.println(\"tempreature = \" + tempreature + \" humidity = \" + humidity + \" pressure =\" + pressure);\n    }\n\n    @Override\n    public void update(Observable observable, Object o) {\n\n        if (o instanceof WeatherData) {\n            WeatherData weatherData = (WeatherData) o;\n            this.tempreature = weatherData.getTemperature();\n            this.humidity = weatherData.getHumidity();\n            this.pressure = weatherData.getPressure();\n            display();\n        }\n    }\n}\n\n```\n\n\n\n```java\npackage obser;\nimport java.util.Observable;\nimport java.util.Observer;\n\npublic class WeatherData extends Observable {\n    private float temperature;\n\n    private float humidity;\n\n    private float pressure;\n\n    public WeatherData() {\n    }\n\n    public void measurementsChanged() {\n        setChanged();\n        notifyObservers(this);\n    }\n\n    public void setMeasurements(float temperature, float humidety, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidety;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n\n    public float getTemperature() {\n        return temperature;\n    }\n\n    public float getHumidity() {\n        return humidity;\n    }\n\n    public float getPressure() {\n        return pressure;\n    }\n}\n\n```\n\n```java\npackage obser;\npublic class Main {\n    public static void main(String[] args) {\n        WeatherData weatherData = new WeatherData();\n        ConcreteObserver concreteObserver = new ConcreteObserver(weatherData);\n        weatherData.setMeasurements(502, 42, 30);\n    }\n}\n\n```\n\n## java.util.Observable的缺点\n\nObservable是一个类而不是一个接口，如果想使用Observable就必须继承他，如果某类想同时具有Observable的行为和另一个超类的行为就会陷入两难，因为java不支持多继承。这限制了Observable的复用潜力。\n\nObservable将setChanged()方法定义为了protected，意味着除非继承Observable，否则无法创建Observable实例并组合到自己的对象中来。\n\n## 总结\n\n观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都会收到通知并自动更新。观察者模式提供了一种对象设计，让主题和观察者之间松耦合，但是他们可以进行交互，只是双方不清楚彼此的细节。在任何时候我们都可以增加新的观察者，因为主题唯一的以来的东西是一个实现了观察者接口的对象列表，所以我们可以随时增加观察者。事实上，在运行时我们可以用新的观察者取代现有的观察者，主题不会受到任何影响。同样的也可以在任何时候删除某些观察者。松耦合的设计之所以让我们建立富有弹性的OO系统，能够应对变化是因为对象之间的互相依赖降到了最低。","tags":["设计模式"]},{"title":"设计模式--策略模式","url":"/2019/10/07/设计模式-策略模式/","content":"\n设计模式之策略模式。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 策略模式\n\n## 概念\n\n策略模式的思想是针对一组算法，将每种算法都封装到具有共同接口的独立的类中，从而使他们可以互相替换。策略模式的最大特点是使算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。\n\n## 特点\n\n策略模式体现了面向对象程序设计中的非常重要的两个原则：\n\n1.封装变化的概念。\n\n2.编程中使用接口，而不是使用的是具体的实现类（面向接口编程）。\n\n## 策略模式的应用\n\n在正式应用策略模式之前，我们先讲一个小故事：现在小刘上班的公司做了一套相当成功的模拟鸭子游戏。游戏中会出现各种鸭子，一边游泳戏水，一边呱呱叫，此系统的内部设计使用了标准的OO技术，设计了一个鸭子的超类，并且让各种鸭子继承了此超类。去年公司的竞争压力加剧，在经过了为期一周的头脑风暴会议后，公司主管认为是该创新的时候了，他们需要展示一些让人真正印象深刻的东西来振奋人心。主管们决定此模拟程序需要会飞的鸭子来将竞争者抛在脑后。小刘的经理拍胸脯告诉主管们，小刘需要一个星期就能搞定。“毕竟，小刘是一个OO程序猿……这有什么困难？”\n\n当需求传达给小刘的时候小刘心想：“既然所有的鸭子都继承自鸭子的超类，那么只需要在超类中加上fly()方法，那么所有的鸭子都会继承fly()，所有的鸭子都会飞了。”小刘迅速的修改了代码，果真所有的鸭子都能飞了。然而，问题出现了……在一次产品展示上，经理发现居然有很多“橡皮鸭子”在屏幕上飞来飞去。小刘在修改代码的时候忽略了一件事，不是所有的鸭子都会飞，小刘在超类中加了飞的行为会使一些不该有此行为的子类也拥有了此行为。对代码所作的局部修改，影响层面却不只是局部。他深刻体会到了一件事：当涉及“维护”时，为了“复用”而使用继承，结局并不完美。\n\n小刘为了解决橡皮鸭子会飞的这个bug又想了新的办法：将橡皮鸭中的fly()方法覆盖掉，让其什么也不做。但是小刘又发愁：如果以后有新鸭子需要添加，他们可能有的只会叫不会飞，有的可能不会飞也不会叫，那么他都要去检查并且可能需要覆盖鸭子的行为，这简直是无穷无尽的噩梦。所以他需要一个更加清晰的方法，让某些鸭子类型可飞或者可叫。小刘心想他可以把fly()从超类中取出来做成一个接口，有鸭子会飞就实现这个接口，这样的话就实现了只有某些鸭子会飞。然而小刘的同事告诉他：“这个主意坏透了，你没发现这样重复的代码会变多吗？而且假如有50类鸭子都实现了这个接口，某天需要修改一下飞的行为，你又怎么说？”小刘听了陷入无尽的思考当中。\n\n小刘的同事小杨看到小刘苦苦想不出答案决定帮帮他：“既然鸭子的飞和叫的行为会随着鸭子的不同而改变，为了能够把这两个行为从鸭子类中分开，为何不考虑将他们从鸭子类中取出来，建立一组新类来代表每个行为呢？飞行行为有很多，可能用翅膀飞，也可能飞不起来，也可能靠风吹着飞，完全可以将飞作为接口，上述这三种飞行方式为飞行接口的实现类，到时候只需要在鸭子类中声明接口并且赋予飞行方式就好了。”小刘听了小杨的话恍然大悟，原来这就是面向接口编程。小刘在跟小杨的讨论中确定了实现方式并且写出了如下代码：\n\n\n\n```java\n/**\n * 飞行行为接口\n */\npublic interface FlyBehavior {\n    void fly();\n}\n\n```\n\n```java\n/**\n * 翅膀飞行实现类\n */\npublic class FlyWithWings implements FlyBehavior {\n    @Override\n    public void fly() {\n        System.out.println(\"i'm flying!\");\n    }\n}\n\n```\n\n```java\n/**\n * 不能飞行实现类\n */\npublic class FlyNoWay implements FlyBehavior {\n    @Override\n    public void fly() {\n        System.out.println(\"i can't fly\");\n    }\n}\n\n```\n\n```java\n/**\n * 鸭子超类\n */\npublic abstract class Duck {\n\n    FlyBehavior flyBehavior;\n\n    public void swim() {\n        System.out.println(\"All dicks float, even decoys!\");\n    }\n\n    public void setFlyBehavior(FlyBehavior flyBehavior) {\n        this.flyBehavior = flyBehavior;\n    }\n\n    public abstract void display();\n    public void performFly() {\n        flyBehavior.fly();\n    }\n}\n\n```\n\n```java\n/**\n * 绿头鸭实现类\n */\npublic class MallardDuck extends Duck {\n    public MallardDuck(){\n        flyBehavior = new FlyWithWings();\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"i'm a real mallard duck\");\n    }\n}\n\n```\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        Duck mallardDuck = new MallardDuck();\n        mallardDuck.display();\n        mallardDuck.performFly();\n\n    }\n}\n```\n\n小刘测试后发现果真使用面向接口编程可以有效地将代码解耦，而且在程序运行中可以方便的改变鸭子的飞行方式。假如有只绿头鸭不能飞了只需要\n\n```java\n        mallardDuck.setFlyBehavior(new FlyNoWay());\n```\n\n就可以将鸭子设置为不能飞的状态。\n\n小刘经过此次经历获得了很多感悟：\n\n在程序设计中，应当多用组合少用继承，使用组合建立系统具有很大的弹性。不仅可以将算法族封装成类，更可以在在运行时动态的改变行为，只要组合的行为对象符合正确的接口标准即可。例如鸭子模拟系统中，鸭子的行为不是继承来的，而是和适当的行为对象组合来的。当鸭子增加了新的飞行方式时，例如喷气火箭飞行只需要创建喷气火箭飞行类并且实现飞行的接口即可。不会对原有代码产生影响。\n\n```java\n\npublic class FlyRocketPowered implements FlyBehavior {\n    @Override\n    public void fly() {\n        System.out.println(\"i'm flying with a rocket!\");\n    }\n}\n\n```\n\n\n\n## 策略模式正式定义：\n\n策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。\n\n\n\n\n\n","tags":["设计模式"]},{"title":"网络科学导论简记","url":"/2019/09/08/网络科学导论/","content":"\n网络科学导论简记\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\\\n\n\n\n## 网络基本拓扑性质\n\n### 鲁棒性\n\n​\t\t鲁棒是Robust的音译，也就是健壮和强壮的意思。它是在异常和危险情况下系统生存的关键。比如说，计算机[软件](https://baike.baidu.com/item/软件)在输入错误、磁盘故障、网络过载或有意攻击情况下，能否不死机、不崩溃，就是该软件的鲁棒性。所谓“鲁棒性”，是指控制系统在一定（结构，大小）的参数[摄动](https://baike.baidu.com/item/摄动/4777855)下，维持其它某些性能的特性。根据对性能的不同定义，可分为稳定鲁棒性和性能鲁棒性。以[闭环系统](https://baike.baidu.com/item/闭环系统/5993157)的鲁棒性作为目标设计得到的固定控制器称为[鲁棒控制](https://baike.baidu.com/item/鲁棒控制)器。\n\n### 无向网络中的巨片\n\n​\t\t网络平均距离和直径等概念严格来说只有对连通图才是有限值。经验和实证研究表明，许多实际的大规模复杂网络都是不连通的，但是往往会存在一个特别大的连通片，它包含了整个网络中的相当比例的节点，这一连通片成为巨片。\n\n### 有向网络中的蝴蝶结结构\n\n​\t\t实际的大规模有向网络往往既不是强连通也不是弱连通的，但是许多有向网络往往有一个包含了网络中相当部分节点的很大弱连通片，成为弱连通巨片。这一若连通巨片又往往具有一种包含四个部分的蝴蝶结结构。\n\n![](网络科学导论\\1.png)\n\n```\n强连通核（SCC）：位于网络中心，其中的任意两个节点之间都是强连通的\n入部（IN）：包含可以从通过有向路径到达SCC但不能从SCC反向到达的节点\n出部（OUT）：包含可以从SCC通过有向路径到达但不能到达SCC的节点\n卷须（Tendrils）：包含既无法到达SCC也无法从SCC到达的节点\n管子（Tube）：可以从入部不经过SCC到达出部的节点\n```\n\n\n\n### 度与平均度\n\n​\t\t节点的度指与节点直接相连的边的数目，对于没有自环和重边的简单图，节点的度是与节点直接有边连接的其他节点的数目。度包括出度和入度。节点所有的度的平均值为网络的平均度\n\n​\t\t节点的强度是针对加权网络而言的。一个节点的强度为这个节点到其他节点的权值之和。\n\n\n\n### 网络的稀疏性与稠密化\n\n​\t\t对于无向网络，密度的定义为网络中实际存在的边数M与最大可能的边数之比。对于无向网络：\n\n![](网络科学导论\\2.png)\n\n对于有向网络，上式分母中的1/2去掉即可。当N趋于正无穷时，若网络密度趋于非零常数，那就可以认为网络时稠密的。若网络密度趋于0那么网络就是稀疏的。\n\n\n\n### 平均路径长度\n\n​\t\t网络中两个节点i和j之间的最短路径也成为测地路径，是指连接这两个节点的边数最少的路径。距离定义为连接两个节点的最短路径的边的数目。网络的平均路径长度定义为任意两个节点之间的距离的平均值。\n\n\n\n### Dijkstra算法实现\n\n\n\n\n\n### 聚类系数\n\n​\t\t聚类系数为节点与其临节点之间实际存在的边数与最多可存在的边数的比值。聚类系数是0到1之间的一个数，越趋近于1表示网络更加紧密。\n\n![](网络科学导论\\3.png)\n\n","tags":["网络科学导论"]},{"title":"spring boot邮件发送和定时任务","url":"/2019/09/03/spring-boot邮件发送/","content":"\n使用SpringBoot整合Mail发送邮件和定时任务,自用\n\n<!-- more -->\n<The rest of contents | 余下全文>\\\n\npom.xml:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.7.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>com.example</groupId>\n    <artifactId>springboot-task</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>springboot-task</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-mail</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n```\n\n\n\napplication.properties:\n\n```xml\nspring.mail.host=smtp.qq.com\nspring.mail.username=5426482@qq.com\nspring.mail.password=bphrczxkemzubibf\nspring.mail.properties.mail.smtp.auth=true\nspring.mail.properties.mail.smtp.starttls.enable=true\nspring.mail.properties.mail.smtp.starttls.required=true\n```\n\n\n\n SpringbootTaskApplication\n\n```java\npackage com.example.springboottask;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableAsync;import org.springframework.scheduling.annotation.EnableScheduling;@EnableScheduling@EnableAsync@SpringBootApplicationpublic class SpringbootTaskApplication {    public static void main(String[] args) {        SpringApplication.run(SpringbootTaskApplication.class, args);    }}\n```\n\nScheduledService\n\n```java\npackage com.example.springboottask.service;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Service;@Servicepublic class ScheduledService {    @Scheduled(cron = \"0 * * * * MON-FRI\")    public void hello(){        System.out.println(\"hello\");    }}\n```\n\nAsyncService\n\n```java\npackage com.example.springboottask.service;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;@Servicepublic class AsyncService {    @Async    public void hello(){        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(\"处理数据中\");    }}\n```\n\n\n\nAsynController\n\n```java\npackage com.example.springboottask.controller;import com.example.springboottask.service.AsyncService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AsyncController {    @Autowired    AsyncService asyncService;    @GetMapping(\"/hello\")    public String hello() {        asyncService.hello();        return \"success\";    }}\n```","tags":["Spring Boot"]},{"title":"python list.append方法数据覆盖","url":"/2019/09/01/python-list-append方法数据覆盖/","content":"\npython循环中添加list数据覆盖问题。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n测试代码如下:\n\n```python\ndef test():\n    for i in range(5):\n        a.append(i)\n        b.append(a)\n\n    print(b)\n\nif __name__ == '__main__':\n    global a\n    global b\n    a = list()\n    b = list()\n    test()\n\n```\n\n 运行结果:\n\n```\n[[0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4]]\n```\n\n然而此函数预期的结果应该为:\n\n```\n[[0], [0, 1], [0, 1, 2], [0, 1, 2, 3], [0, 1, 2, 3, 4]]\n```\n\n这是因为当向listb中添加lista时添加的相当于a的地址,当在循环中修改了lista的数据时候,由于listb中所有的指向都为lista所以所有的数据都会随之改变。若想在listb中展示预期数据，应当新建一个list再将其添加到listb中，此处使用python自带的深拷贝函数进行拷贝原来的a。代码如下：\n\n```python\nimport copy\ndef test():\n    for i in range(5):\n        a.append(i)\n        c = copy.deepcopy(a)\n        b.append(c)\n\n    print(b)\n\nif __name__ == '__main__':\n    global a\n    global b\n    a = list()\n    b = list()\n    test()\n\n```\n\n\n\n\n\n\n\n\n\n","tags":["python"]},{"title":"docker安装mysql","url":"/2019/07/15/docker安装mysql/","content":"\n\n\n使用使用docker 安装mysql,并且进行远程访问连接\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 实验环境\n\n+ centos7.3\n+ docker\n+ mysql-8.0.16.0\n\n## 实验步骤\n\n### 升级yum\n\n```shell\nyum update -y\n```\n\n### 安装docker\n\n```shell\nyum install docker -y\n```\n\n### 启动docker\n\n```shell\nsystemctl start docker  # 启动\nsystemctl enable docker # 设置开机启动\n```\n\n### 查找mysql镜像\n\n```shell\ndocker search mysql\n```\n\n### 拉取mysql镜像\n\n```shell\ndocker pull mysql #默认为下载最新版\n```\n\n### 查看mysql镜像\n\n```shell\ndocker images\n```\n\n### 启动mysql\n\n```shell\n docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql\n```\n\n（参数 -p 设置端口，--name 取名 ，-e MYSQL_ROOT_PASSWORD=123456 设置 账号为 root ，密码为 123456  -d 表示作为一个守护进程在后台运行 ）\n\n### 查看运行中的容器\n\n```shell\ndocker ps  \n```\n\n![2](docker安装mysql/2.jpg)\n\n## 远程连接mysql及错误解决\n\n在上文中,我们已经创建了一个mysql容器,在连接过程中使用navicat报错错误信息如下:\n\n![1](docker安装mysql/1.jpg)\n\n为了对mysql进行操作首先要进入docker中的mysql\n\n```shell\ndocker exec -it mysql bash\n```\n\n登录mysql\n\n```shell\nmysql -u root -p\n```\n\n执行sql语句\n\n```shell\nALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '你的密码';\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码';\n```\n\n执行后再次连接,连接成功\n\n\n\n\n\n\n\n","tags":["docker","mysql"]},{"title":"SpringBoot+ajax跨域请求","url":"/2019/07/11/SpringBoot-ajax跨域请求/","content":"\n\n\n在使用ajax请求SpringBoot + SpringSecurity后端时遇到的一些坑。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 不集成SpringSecurity的情况下进行跨域访问\n\n### 错误信息\n\n在使用ajax请求后端的时候在浏览器控制台会输出如下信息：\n\n```java\nAccess to XMLHttpRequest at 'http://localhost:8080/test' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n```\n\n从源'本地路径'访问 '目标路径(请求链接)'文本传输请求已被CORS策略阻塞:对预置请求的响应未通过访问控制检查:请求的资源上不存在'Access- control - allow - origin '报头。\n\n### 错误原因\n\n本地路径和目标路径不是同一个域名下引起的跨域问题\n\n### 解决方案\n\n在对应的Controller类前上@CrossOrigin注解\n\n例如：\n\n```java\npackage com.example.demo.controller;\n\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @program: demo\n * @description:\n * @author: liu\n * @create: 2019-07-11 18:14\n **/\n@RestController\n@CrossOrigin\npublic class TestController {\n  \n    @PostMapping(\"/testPost\")\n    public String testPost() {\n        System.out.println(\"testPost成功\");\n        return \"testPost跨域请求成功\";\n    }\n  \n    @GetMapping(\"/testGet\")\n    public String testGet() {\n        System.out.println(\"testGet成功\");\n        return \"testGet跨域请求成功\";\n    }\n}\n\n```\n\n\n\n## 集成SpringSecurity的情况下进行跨域访问\n\n### 错误信息\n\n集成SpringSecurity后get请求正常，但是对于post请求仍然会显示错误信息\n\n```java\njquery.min.js:4 POST http://localhost:8080/testPost 403\nlist_student.html:1 Access to XMLHttpRequest at 'http://localhost:8080/testPost' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n```\n\n### 解决方案\n\n添加WebSecurityConfiguration配置文件可关闭csrf\n\n```java\npackage com.example.demo;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled = true)\n@Order(-1)\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n//        http.requestMatchers().antMatchers(HttpMethod.OPTIONS, \"/oauth/**\",\"/login/**\",\"/logout/**\")\n//            .and()\n//            .authorizeRequests()\n//            .antMatchers().permitAll()\n//            .and()\n//            .formLogin().permitAll(); //新增login form 支持用户登录及授权\n\n        http.requestMatchers().antMatchers(HttpMethod.OPTIONS, \"/oauth/**\")\n                .and()\n                .cors()\n                .and()\n                .csrf().disable();\n    }\n}\n```\n\n\n\n\n\n\n\n","tags":["SpringBoot","ajax"]},{"title":"SpringBoot整合Activiti7使用","url":"/2019/07/10/SpringBoot整合Activiti7使用/","content":"\n <Excerpt in index | 首页摘要>\n\n最近做的一个项目中需要实现员工请假的功能，计划使用activiti来实现请假流程，所以去学习了一下相关的知识。并且完成了一个简单的请假实例。\n\n<!-- more -->\n\n<The rest of contents | 余下全文>\n\n\n\n# Activiti相关\n\n## Activiti介绍\n\nActiviti是基于Apache许可的开源BPM平台，创始人Tom Baeyens原是JBPM架构师，可以理解为与JBPM出自同一祖师爷。它提供了Eclipse插件，开发可以通过插件直接绘制业务流程图。基于Spring，ibatis等框架，并在此之上构建了非常清晰的开发框架。是由Alfresco软件发布的业务流程管理（BPM）框架，它是覆盖了业务流程管理、工作流、服务协作等领域的一个开源的、灵活的、易扩展的可执行流程语言框架。 本文基于Activiti7的Activiti Core，基于Spring Boot做简单学习总结。\n\n\n\n## Acticiti核心类介绍\n\n### ProcessEngine\n\n流程引擎的抽象，可以通过此类获取需要的所有服务。\n\n### Service类\n\n  通过ProcessEngine获取，Activiti将不同生命周期的服务封装在不同Service中，包括定义、部署、运行。通过服务类可获取相关生命周期中的服务信息。\n\n#### taskService\n\n流程运行过程中，每个任务节点的相关操作接口，如complete,delete,delegate等。\n\n#### RepositoryService\n\n流程定义和部署相关的存储服务\n\n#### RuntimeService\n\n流程运行时相关的服务，如根据流程好启动流程实例startProcessInstanceByKey。\n\n#### HistoryService\n\n历史记录相关服务接口。\n\n\n\n# 项目搭建\n\n## 创建SpringBoot项目并且添加maven依赖\n\npom.xml:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n   <modelVersion>4.0.0</modelVersion>\n   <parent>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-parent</artifactId>\n      <version>2.1.6.RELEASE</version>\n      <relativePath/> <!-- lookup parent from repository -->\n   </parent>\n   <groupId>com.example</groupId>\n   <artifactId>demo</artifactId>\n   <version>0.0.1-SNAPSHOT</version>\n   <name>demo</name>\n   <description>Demo project for Spring Boot</description>\n\n   <properties>\n      <java.version>1.8</java.version>\n   </properties>\n\n   <dependencies>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter</artifactId>\n      </dependency>\n\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-devtools</artifactId>\n         <scope>runtime</scope>\n         <optional>true</optional>\n      </dependency>\n      <dependency>\n         <groupId>mysql</groupId>\n         <artifactId>mysql-connector-java</artifactId>\n         <scope>runtime</scope>\n      </dependency>\n      <dependency>\n         <groupId>org.projectlombok</groupId>\n         <artifactId>lombok</artifactId>\n         <optional>true</optional>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-test</artifactId>\n         <scope>test</scope>\n      </dependency>\n      <dependency>\n         <groupId>org.activiti</groupId>\n         <artifactId>activiti-spring-boot-starter</artifactId>\n         <version>7.0.0.Beta2</version>\n      </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-jdbc</artifactId>\n        </dependency>\n\n   </dependencies>\n\n   <build>\n      <plugins>\n         <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n         </plugin>\n      </plugins>\n   </build>\n\n</project>\n\n```\n\n## 添加配置文件\n\napplication.yml：\n\n```xml\nspring:\n  datasource:\n    username: root\n    password: 123456\n    url: jdbc:mysql://localhost:3306/test2?nullCatalogMeansCurrent=true\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  devtools:\n      restart:\n        enabled: true  #设置开启热部署\n  activiti:\n    database-schema-update: true\n    history-level: full\n    db-history-used: true\n\n\ndebug: true\n\n```\n\n\n\n## 创建流程图\n\n在创建流程图之前首先需要安装idea支持bpm文件的插件\n\n![2](SpringBoot整合Activiti7使用/2.jpg)\n\n安装成功后在resources目录下创建processes文件夹并新建holiday.bpmn文件并且创建流程\n\n![](SpringBoot整合Activiti7使用/3.jpg)\n\n\n\n对应xml文件代码如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<definitions xmlns=\"http://www.omg.org/spec/BPMN/20100524/MODEL\" xmlns:activiti=\"http://activiti.org/bpmn\" xmlns:bpmndi=\"http://www.omg.org/spec/BPMN/20100524/DI\" xmlns:omgdc=\"http://www.omg.org/spec/DD/20100524/DC\" xmlns:omgdi=\"http://www.omg.org/spec/DD/20100524/DI\" xmlns:tns=\"http://www.activiti.org/test\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" expressionLanguage=\"http://www.w3.org/1999/XPath\" id=\"m1562573992349\" name=\"\" targetNamespace=\"http://www.activiti.org/test\" typeLanguage=\"http://www.w3.org/2001/XMLSchema\">\n  <process id=\"myProcess_1\" isClosed=\"false\" isExecutable=\"true\" processType=\"None\">\n    <startEvent id=\"_2\" name=\"StartEvent\"/>\n    <userTask activiti:assignee=\"${userId}\" activiti:exclusive=\"false\" id=\"_3\" name=\"填写申请单\"/>\n    <userTask activiti:assignee=\"department\" activiti:exclusive=\"true\" id=\"_4\" name=\"审核\"/>\n    <endEvent id=\"_6\" name=\"EndEvent\"/>\n    <sequenceFlow id=\"_7\" sourceRef=\"_2\" targetRef=\"_3\"/>\n    <sequenceFlow id=\"_8\" sourceRef=\"_3\" targetRef=\"_4\"/>\n    <sequenceFlow id=\"_11\" sourceRef=\"_4\" targetRef=\"_6\"/>\n  </process>\n  <bpmndi:BPMNDiagram documentation=\"background=#3C3F41;count=1;horizontalcount=1;orientation=0;width=842.4;height=1195.2;imageableWidth=832.4;imageableHeight=1185.2;imageableX=5.0;imageableY=5.0\" id=\"Diagram-_1\" name=\"New Diagram\">\n    <bpmndi:BPMNPlane bpmnElement=\"myProcess_1\">\n      <bpmndi:BPMNShape bpmnElement=\"_2\" id=\"Shape-_2\">\n        <omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"225.0\" y=\"175.0\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNShape>\n      <bpmndi:BPMNShape bpmnElement=\"_3\" id=\"Shape-_3\">\n        <omgdc:Bounds height=\"55.0\" width=\"85.0\" x=\"435.0\" y=\"175.0\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"55.0\" width=\"85.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNShape>\n      <bpmndi:BPMNShape bpmnElement=\"_4\" id=\"Shape-_4\">\n        <omgdc:Bounds height=\"55.0\" width=\"85.0\" x=\"655.0\" y=\"175.0\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"55.0\" width=\"85.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNShape>\n      <bpmndi:BPMNShape bpmnElement=\"_6\" id=\"Shape-_6\">\n        <omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"875.0\" y=\"185.0\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"32.0\" width=\"32.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNShape>\n      <bpmndi:BPMNEdge bpmnElement=\"_7\" id=\"BPMNEdge__7\" sourceElement=\"_2\" targetElement=\"_3\">\n        <omgdi:waypoint x=\"257.0\" y=\"191.0\"/>\n        <omgdi:waypoint x=\"435.0\" y=\"202.5\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"0.0\" width=\"0.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNEdge>\n      <bpmndi:BPMNEdge bpmnElement=\"_8\" id=\"BPMNEdge__8\" sourceElement=\"_3\" targetElement=\"_4\">\n        <omgdi:waypoint x=\"520.0\" y=\"202.5\"/>\n        <omgdi:waypoint x=\"655.0\" y=\"202.5\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"0.0\" width=\"0.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNEdge>\n      <bpmndi:BPMNEdge bpmnElement=\"_11\" id=\"BPMNEdge__11\" sourceElement=\"_4\" targetElement=\"_6\">\n        <omgdi:waypoint x=\"740.0\" y=\"202.5\"/>\n        <omgdi:waypoint x=\"875.0\" y=\"201.0\"/>\n        <bpmndi:BPMNLabel>\n          <omgdc:Bounds height=\"0.0\" width=\"0.0\" x=\"0.0\" y=\"0.0\"/>\n        </bpmndi:BPMNLabel>\n      </bpmndi:BPMNEdge>\n    </bpmndi:BPMNPlane>\n  </bpmndi:BPMNDiagram>\n</definitions>\n\n```\n\n## 运行Application\n\n启动后查看数据库发现springboot 自动读取了processes下的holiday.bpmn文件并且部署任务流程到activiti。数据库中生成了25张工作表。\n\n![](SpringBoot整合Activiti7使用/1.jpg)\n\n并且在ACT_GE_BYTEARRAY表中也存在部署的信息\n\n![4](SpringBoot整合Activiti7使用/4.jpg)\n\n\n\n# 编写实例\n\n## 开启请假流程\n\n```java\n\t@Test\n\tpublic void start() {\n\t\tString instanceKey = \"myProcess_1\";\n\t\tlogger.info(\"开启请假流程...\");\n\t\tMap<String, Object> map = new HashMap<String, Object>();\n\t\t//在holiday.bpmn中,填写请假单的任务办理人为动态传入的userId,此处模拟一个id\n\t\tmap.put(\"userId\", \"10001\");\n\t\tProcessInstance instance = runtimeService.startProcessInstanceByKey(instanceKey, map);\n\t\tlogger.info(\"启动流程实例成功:{}\", instance);\n\t\tlogger.info(\"流程实例ID:{}\", instance.getId());\n\t\tlogger.info(\"流程定义ID:{}\", instance.getProcessDefinitionId());\n\n\t}\n```\n\n运行结果：\n\n![5](SpringBoot整合Activiti7使用/5.jpg)\n\n运行后成功开启了一个请假实例并且获取到id为：adc6a5f0-a2c3-11e9-bb83-00e04c83a7ff。\n\n\n\n## 填写请假单\n\n通过实例id可以查询到实例所对应的任务，模拟用户请假的内容存入map中添加为流程变量。\n\n```java\n\t@Test\n\tpublic void employeeApply() {\n\t\tString instanceId = \"adc6a5f0-a2c3-11e9-bb83-00e04c83a7ff\"; // 任务ID\n\t\tString leaveDays = \"10\"; // 请假天数\n\t\tString leaveReason = \"回老家结婚\"; // 请假原因\n\t\tTask task = taskService.createTaskQuery().processInstanceId(instanceId).singleResult();\n\t\tif (task == null) {\n\t\t\tlogger.info(\"任务ID:{}查询到任务为空！\", instanceId);\n\t\t}\n\t\tMap<String, Object> map = new HashMap<String, Object>();\n\t\tmap.put(\"days\", leaveDays);\n\t\tmap.put(\"date\", new Date());\n\t\tmap.put(\"reason\", leaveReason);\n\t\ttaskService.complete(task.getId(), map);\n\t\tlogger.info(\"执行【员工申请】环节，流程推动到【上级审核】环节\");\n\t}\n```\n\n运行结果如下：\n\n![6](SpringBoot整合Activiti7使用/6.jpg)\n\n## 流程变量查看\n\n上级审核的时候需要查看到员工所提交的请假相关信息，可以通过taskService.getVariable的形式来获取。\n\n```java\n\t@Test\n\tpublic void showTaskVariable (){\n\t\tString instanceId = \"adc6a5f0-a2c3-11e9-bb83-00e04c83a7ff\"; // 任务ID\n\n\t\tTask task = taskService.createTaskQuery().processInstanceId(instanceId).singleResult();\n\t\tString days = (String) taskService.getVariable(task.getId(), \"days\");\n\t\tDate date = (Date) taskService.getVariable(task.getId(), \"date\");\n\t\tString reason = (String) taskService.getVariable(task.getId(), \"reason\");\n\t\tString userId = (String) taskService.getVariable(task.getId(), \"userId\");\n\t\tSystem.out.println(\"请假天数:  \" + days);\n\t\tSystem.out.println(\"请假理由:  \" + reason);\n\t\tSystem.out.println(\"请假人id:  \" + userId);\n\t\tSystem.out.println(\"请假日期:  \" + date.toString());\n\t}\n```\n\n运行结果：\n\n![7](SpringBoot整合Activiti7使用/7.jpg)\n\n## 上级审批\n\n上级审批并且添加意见\n\n```java\n\t@Test\n\tpublic void departmentAudit() {\n\t\tString instanceId = \"adc6a5f0-a2c3-11e9-bb83-00e04c83a7ff\"; // 任务ID\n\t\tString departmentalOpinion = \"早去早回\";\n\t\tTask task = taskService.createTaskQuery().processInstanceId(instanceId).singleResult();\n\t\tMap<String, Object> map = new HashMap<String, Object>();\n\t\tmap.put(\"departmentalOpinion\", departmentalOpinion);\n\t\ttaskService.complete(task.getId(), map);\n\t\tlogger.info(\"添加审批意见,请假流程结束\");\n\t}\n\n```\n\n运行结果：\n\n![8](SpringBoot整合Activiti7使用/8.jpg)\n\n\n\n# 总结\n\n使用Activiti可以方便对流程进行控制。本文只是对简单的请假流程做了实例，没有涉及到多任务或多分支等情景。对于此类情况以后再做补充。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["SpringBoot","Activiti7"]},{"title":"Thumbnailator图片处理","url":"/2019/06/18/Thumbnailator图片处理/","content":"\n\n\nThumbnailator 是一个优秀的图片处理的Google开源Java类库。处理效果远比Java API的好。从API提供现有的图像文件和图像对象的类中简化了处理过程，两三行代码就能够从现有图片生成处理后的图片，且允许微调图片的生成方式，同时保持了需要写入的最低限度的代码量。还支持对一个目录的所有图片进行批量处理操作。\n\n支持的处理操作：图片缩放，区域裁剪，水印，旋转，保持比例。\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 导入依赖\n\n```xml\n<!-- https://mvnrepository.com/artifact/net.coobird/thumbnailator -->\n<dependency>\n    <groupId>net.coobird</groupId>\n    <artifactId>thumbnailator</artifactId>\n    <version>0.4.8</version>\n</dependency>\n\n```\n\n## 函数示例\n\n```java\n从图像文件创建缩略图\nThumbnails.of(new File(\"original.jpg\"))\n        .size(160, 160)\n        .toFile(new File(\"thumbnail.jpg\"));\n在此示例中，图像来自original.jpg调整大小，然后保存到thumbnail.jpg。\n\n或者，Thumbnailator将接受文件名作为String。File不需要使用对象指定图像文件：\n\nThumbnails.of(\"original.jpg\")\n        .size(160, 160)\n        .toFile(\"thumbnail.jpg\");\n在编写快速原型代码或从脚本语言中使用Thumbnailator时，此表单非常有用。\n\n使用旋转和水印创建缩略图\nThumbnails.of(new File(\"original.jpg\"))\n        .size(160, 160)\n        .rotate(90)\n        .watermark(Positions.BOTTOM_RIGHT, ImageIO.read(new File(\"watermark.png\")), 0.5f)\n        .outputQuality(0.8)\n        .toFile(new File(\"image-with-watermark.jpg\"));\n在此示例中，original.jpg调整图像大小，然后顺时针旋转90度，然后在右下角放置一个半透明水印，然后image-with-watermark.jpg以80％压缩质量设置保存。\n\n创建缩略图并写入 OutputStream\nOutputStream os = ...;\n\t\t\nThumbnails.of(\"large-picture.jpg\")\n        .size(200, 200)\n        .outputFormat(\"png\")\n        .toOutputStream(os);\n在此示例中，将文件中的图像large-picture.jpg调整为最大尺寸200 x 200（保持原始图像的纵横比），并将其写入指定OutputStream的PNG图像。\n\n创建固定大小的缩略图\nBufferedImage originalImage = ImageIO.read(new File(\"original.png\"));\n\nBufferedImage thumbnail = Thumbnails.of(originalImage)\n        .size(200, 200)\n        .asBufferedImage();\n上面的代码采用图像originalImage并创建一个200像素乘200像素的缩略图，并使用并存储结果thumbnail。\n\n按给定因子缩放图像\nBufferedImage originalImage = ImageIO.read(new File(\"original.png\"));\n\nBufferedImage thumbnail = Thumbnails.of(originalImage)\n        .scale(0.25)\n        .asBufferedImage();\n上面的代码将图像originalImage带入并创建一个缩略图，该缩略图是原始图像的25％，并使用默认缩放技术来制作存储在其中的缩略图thumbnail。\n\n创建缩略图时旋转图像\nBufferedImage originalImage = ImageIO.read(new File(\"original.jpg\"));\n\nBufferedImage thumbnail = Thumbnails.of(originalImage)\n        .size(200, 200)\n        .rotate(90)\n        .asBufferedImage();\n上面的代码采用原始图像并创建一个顺时针旋转90度的缩略图。\n\n使用水印创建缩略图\nBufferedImage originalImage = ImageIO.read(new File(\"original.jpg\"));\nBufferedImage watermarkImage = ImageIO.read(new File(\"watermark.png\"));\n\nBufferedImage thumbnail = Thumbnails.of(originalImage)\n        .size(200, 200)\n        .watermark(Positions.BOTTOM_RIGHT, watermarkImage, 0.5f)\n        .asBufferedImage();\n如图所示，可以通过调用该watermark方法将水印添加到缩略图。\n\n可以从Positions枚举中选择定位。\n\n缩略图的不透明度（或相反地，透明度）可以通过改变最后一个参数来调整，其中0.0f缩略图是完全透明的，并且1.0f水印是完全不透明的。\n\n将缩略图写入特定目录\nFile destinationDir = new File(\"path/to/output\");\n\nThumbnails.of(\"apple.jpg\", \"banana.jpg\", \"cherry.jpg\")\n        .size(200, 200)\n        .toFiles(destinationDir, Rename.PREFIX_DOT_THUMBNAIL);\n此示例将获取源图像，并将缩略图作为文件写入destinationDir（path/to/output目录），同时thumbnail.在文件名前添加重命名。\n\n因此，缩略图将被写为以下文件：\n\npath/to/output/thumbnail.apple.jpg\npath/to/output/thumbnail.banana.jpg\npath/to/output/thumbnail.cherry.jpg\n写入指定目录时，也可以保留原始文件名：\n\nFile destinationDir = new File(\"path/to/output\");\n\nThumbnails.of(\"apple.jpg\", \"banana.jpg\", \"cherry.jpg\")\n        .size(200, 200)\n        .toFiles(destinationDir, Rename.NO_CHANGE);\n在上面的代码中，缩略图将写入：\n\npath/to/output/apple.jpg\npath/to/output/banana.jpg\npath/to/output/cherry.jpg\n```\n\n","tags":["Thumbnailator"]},{"title":"lucene全文检索操作实例","url":"/2019/06/03/lucene操作实例/","content":"\n\n\nLucene是apache下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 全文检索\n\n将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之**索引**。\n\n例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。\n\n**这种先建立索引，再对索引进行搜索的过程就叫全文检索****(Full-text Search)****。**\n\n虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。对于数据量大、数据结构不固定的数据可采用全文检索方式搜索，比如百度、Google等搜索引擎、论坛站内搜索、电商网站站内搜索等。\n\nTip:lucene对java环境的最低要求为JAVA1.8\n\n## 创建索引\n\n第一步：创建一个java工程，并导入jar包。\n\n工程所需jar包:\n\n![](lucene操作实例\\2019-06-03_232645.jpg)\n\n第二步：创建一个indexwriter对象。\n\n1）指定索引库的存放位置Directory对象\n\n2）指定一个IndexWriterConfig对象。\n\n第二步：创建document对象。\n\n第三步：创建field对象，将field添加到document对象中。\n\n第四步：使用indexwriter对象将document对象写入索引库，此过程进行索引创建。并将索引和document对象写入索引库。\n\n第五步：关闭IndexWriter对象。\n\n\n\n代码如下:\n\n```java\n @Test\n    public void createIndex() throws Exception {\n        //创建一个Director对象,指定索引库保存的位置\n        Directory directory = FSDirectory.open(new File(\"c:\\\\temp\\\\index\").toPath());\n        //基于directory对象创建一个IndexWriter对象\n        IndexWriter indexWriter = new IndexWriter(directory, new IndexWriterConfig());\n        //读取磁盘上的文件\n        File dir = new File(\"C:\\\\Users\\\\liu\\\\Desktop\\\\searchsource\");\n        //原始文档的路径\n        File[] files = dir.listFiles();\n        for (File f : files) {\n            String name = f.getName();\n            String filePath = f.getPath();\n            String fileContent = FileUtils.readFileToString(f, \"utf-8\");\n            long fileSize = FileUtils.sizeOf(f);\n            //创建Field\n            //第一个参数：域的名称\n            //第二个参数：域的内容\n            //第三个参数：是否存储\n            Field fieldName = new TextField(\"name\", name, Field.Store.YES);\n            //文件路径域（不分析、不索引、只存储）\n            Field fieldPath = new TextField(\"path\", filePath, Field.Store.YES);\n            //文件内容域\n            Field fieldContent = new TextField(\"content\", fileContent, Field.Store.YES);\n            //文件大小域\n            Field fieldSize = new TextField(\"size\", fileSize + \"\", Field.Store.YES);\n            //创建文档对象\n            Document document = new Document();\n            document.add(fieldName);\n            document.add(fieldPath);\n            document.add(fieldContent);\n            document.add(fieldSize);\n            //把文档对象写入索引库\n            indexWriter.addDocument(document);\n\n        }\n        //关闭indexwriter\n        indexWriter.close();\n    }\n```\n\n\n\ncreateIndex方法运行后会在c:\\\\\\temp\\\\\\index文件夹下生成索引文件,如下图:\n\n![](lucene操作实例\\2019-06-03_231250.jpg)\n\n生成的索引文件为二进制文件,可以使用luke打开索引\n\n## 查看索引\n\nluck开始界面如下,在indexPath中选择索引存储位置文件夹即可\n\n![](lucene操作实例\\2019-06-03_231604.jpg)\n\n\n\n![](D:\\OneDrive - business\\myblog\\source\\_posts\\lucene操作实例\\2019-06-03_232113.jpg)\n\n## 查询索引\n\n第一步：创建一个Directory对象，也就是索引库存放的位置。\n\n第二步：创建一个indexReader对象，需要指定Directory对象。\n\n第三步：创建一个indexsearcher对象，需要指定IndexReader对象\n\n第四步：创建一个TermQuery对象，指定查询的域和查询的关键词。\n\n第五步：执行查询。\n\n第六步：返回查询结果。遍历查询结果并输出。\n\n第七步：关闭IndexReader对象\n\n代码如下:\n\n```java\n    @Test\n    public void searchIndex() throws Exception {\n        //指定索引库存放的路径\n        Directory directory = FSDirectory.open(new File(\"c:\\\\temp\\\\index\").toPath());\n        //创建indexReader对象\n        IndexReader indexReader = DirectoryReader.open(directory);\n        //创建indexsearcher对象\n        IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n        //创建查询\n        Query query = new TermQuery(new Term(\"content\", \"spring\"));\n\n        //执行查询\n        //第一个参数是查询对象，第二个参数是查询结果返回的最大值\n        TopDocs topDocs = indexSearcher.search(query, 10);\n        //查询结果的总条数\n        System.out.println(\"查询总记录数:\" + topDocs.totalHits);\n        //遍历查询结果\n        //topDocs.scoreDocs存储了document对象的id\n\n        ScoreDoc[] scoreDocs = topDocs.scoreDocs;\n\n        for (ScoreDoc doc : scoreDocs) {\n            //scoreDoc.doc属性就是document对象的id\n            //根据document的id找到document对象\n\n            int docId = doc.doc;\n            Document document = indexSearcher.doc(docId);\n            System.out.println(document.get(\"name\"));\n            System.out.println(document.get(\"path\"));\n            System.out.println(document.get(\"size\"));\n            System.out.println(document.get(\"content\"));\n            System.out.println(\"--------------------------\");\n        }\n        //关闭indexreader对象\n        indexReader.close();\n\n    }\n```\n\n部分查询结果如下图:\n\n![](lucene操作实例\\2019-06-03_232508.jpg)","tags":["lucene"]},{"title":"centos7.3搭建gogs","url":"/2019/05/31/centos7-3搭建gogs/","content":"\n\n\nGogs 是一款类似GitHub的开源文件/代码管理系统（基于Git），Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。使用 Go 语言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 所有平台，包括 Linux、Mac OS X、Windows 以及 ARM 平台。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 安装docker\n\n### 升级centos内核到最新版本\n\n在安装响应包之前先将centos的系统版本和内核升级,防止出现docker启动gogs时候报错\n\n```shell\nyum -y update\n```\n\n### 安装docker\n\n```shell\n# 通过yum源安装docker\nyum -y install docker\n# 启动docker\nsystemctl start docker\n# 设置开机自启\nsudo systemctl enable docker\n```\n\n### 下载gogs镜像\n\n```shell\ndocker pull gogs/gogs\n```\n\n### 创建gogs存储目录\n\n```shell\nmkdir -p /var/gogs\n```\n\n### 运行镜像,产生容器\n\n```shell\ndocker run --name=gogs -p 10022:22 -p 10080:3000 -v /var/gogs:/data gogs/gogs\n```\n\n\n\n## 运行并配置配置gogs\n\n\n\n![](centos7-3搭建gogs\\3203841-709cd56c61b12bd7.png)\n\n配置完成后点击立即安装开始安装\n\n## 创建仓库\n\n注册登录后,在控制面版中可以看到我的仓库,点击 '+' 可以创建新的仓库:\n\n创建仓库的时候可以选择使用选定的文件和模板初始化仓库,如果不勾选初始化则创建一个空的仓库.\n\n![](centos7-3搭建gogs\\2019-05-31_142708.jpg)\n\n\n\n\n\n## 克隆仓库\n\n打开想要克隆的仓库,复制http url连接,在想要克隆的目录下使用git clone url 即可\n\n\n\n![](centos7-3搭建gogs\\2019-05-31_152224.jpg)\n\n\n\n## 提交本地仓库\n\n如下图所示,在克隆下来的仓库中添加了一张图片,现在要想整个本地仓库再上传到gogs中\n\n![](centos7-3搭建gogs\\2019-05-31_152749.jpg)\n\n使用如下命令:\n\n```shell\n#添加所有文件\ngit add -A \n#提交到本地仓库\ngit commit -m \"first commit\"\n#提交到gogs仓库\ngit push\n```\n\n","tags":["gogs"]},{"title":"git常用命令","url":"/2019/05/25/git常用命令/","content":"\ngit常用命令\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n\n**git init**\n\n​     在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹.\n\n \n\n**git clone**\n\n​     获取一个url对应的远程Git repo, 创建一个local copy.\n\n​     一般的格式是git clone [url].\n\n​     clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定.\n\n \n\n**git status**\n\n​     查询repo的状态.\n\n​     git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言.\n\n \n\n**git log**\n\n​     show commit history of a branch.\n\n​     git log --oneline --number: 每条log只显示一行,显示number条.\n\n​     git log --oneline --graph:可以图形化地表示出分支合并历史.\n\n​     git log branchname可以显示特定分支的log.\n\n​     git log --oneline branch1 ^branch2,可以查看在分支1,却不在分支2中的提交.^表示排除这个分支(Window下可能要给^branch2加上引号).\n\n​     git log --decorate会显示出tag信息.\n\n​     git log --author=[author name] 可以指定作者的提交历史.\n\n​     git log --since --before --until --after 根据提交时间筛选log.\n\n​     --no-merges可以将merge的commits排除在外.\n\n​     git log --grep 根据commit信息过滤log: git log --grep=keywords\n\n​     默认情况下, git log --grep --author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上--all-match的option.\n\n​     git log -S: filter by introduced diff.\n\n​     比如: git log -SmethodName (注意S和后面的词之间没有等号分隔).\n\n​     git log -p: show patch introduced at each commit.\n\n​     每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看.\n\n​     另一种方法是git show [SHA].\n\n​     git log --stat: show diffstat of changes introduced at each commit.\n\n​     同样是用来看改动的相对信息的,--stat比-p的输出更简单一些.\n\n​    \n\n**git add**\n\n​     在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动.\n\n​     git add .\n\n​     会递归地添加当前工作目录中的所有文件.\n\n \n\n**git diff**\n\n​     不加参数的git diff:\n\n​     show diff of unstaged changes.\n\n​     此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容.\n\n \n\n​     若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用:\n\n​     git diff --cached 命令.\n\n​     show diff of staged changes.\n\n​     (Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的).\n\n \n\n​     git diff HEAD\n\n​     show diff of all staged or unstated changes.\n\n​     也即比较woking directory和上次提交之间所有的改动.\n\n \n\n​     如果想看自从某个版本之后都改动了什么,可以用:\n\n​     git diff [version tag]\n\n​     跟log命令一样,diff也可以加上--stat参数来简化输出.\n\n \n\n​     git diff [branchA] [branchB]可以用来比较两个分支.\n\n​     它实际上会返回一个由A到B的patch,不是我们想要的结果.\n\n​     一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令:\n\n​     git diff [branchA]…[branchB]给出的.\n\n​     实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果.\n\n \n\n \n\n**git commit**\n\n​     提交已经被add进来的改动.\n\n​     git commit -m “the commit message\"\n\n​     git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下.\n\n​     git commit --amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消.\n\n \n\n**git reset**\n\n​     undo changes and commits.\n\n​     这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本.\n\n​     git reset HEAD: unstage files from index and reset pointer to HEAD\n\n​     这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD - - filename, 这个- - 也可以不加.\n\n​     git reset --soft\n\n​     move HEAD to specific commit reference, index and staging are untouched.\n\n​     git reset --hard\n\n​     unstage files AND undo any changes in the working directory since last commit.\n\n​     使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态.\n\n​     这里的HEAD可以被写成任何一次提交的SHA-1.\n\n​     不带soft和hard参数的git reset,实际上带的是默认参数mixed.\n\n \n\n​     总结:\n\n​     git reset --mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容.\n\n​     git reset --soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容.\n\n​     git reset --hard id.是将git的HEAD变了,文件也变了.\n\n​     按改动范围排序如下:\n\n​     soft (commit) < mixed (commit + add) < hard (commit + add + local working)\n\n \n\n**git revert**\n\n​     反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了.\n\n​     git revert HEAD: 撤销最近的一个提交.\n\n​     git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交.\n\n​    \n\n**git rm**\n\n​     git rm file: 从staging区移除文件,同时也移除出工作目录.\n\n​     git rm --cached: 从staging区移除文件,但留在工作目录中.\n\n​     git rm --cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树.\n\n \n\n**git clean**\n\n​     git clean是从工作目录中移除没有track的文件.\n\n​     通常的参数是git clean -df:\n\n​     -d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行.\n\n \n\n**git mv**\n\n​     git rm - - cached orig; mv orig new; git add new\n\n \n\n**git stash**\n\n​     把当前的改动压入一个栈.\n\n​     git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处.\n\n​     git stash list会显示这个栈的list.\n\n​     git stash apply:取出stash中的上一个项目(stash@{0}),并且应用于当前的工作目录.\n\n​     也可以指定别的项目,比如git stash apply stash@{1}.\n\n​     如果你在应用stash中项目的同时想要删除它,可以用git stash pop\n\n \n\n​     删除stash中的项目:\n\n​     git stash drop: 删除上一个,也可指定参数删除指定的一个项目.\n\n​     git stash clear: 删除所有项目.\n\n \n\n**git branch**\n\n​     git branch可以用来列出分支,创建分支和删除分支.\n\n​     git branch -v可以看见每一个分支的最后一次提交.\n\n​     git branch: 列出本地所有分支,当前分支会被星号标示出.\n\n​     git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的). \n\n​     git branch -d (branchname): 删除一个分支.\n\n​     删除remote的分支:\n\n​     git push (remote-name) :(branch-name): delete a remote branch.\n\n​     这个是因为完整的命令形式是:\n\n​     git push remote-name local-branch:remote-branch\n\n​     而这里local-branch的部分为空,就意味着删除了remote-branch\n\n \n\n**git checkout**\n\n　　git checkout (branchname)\n\n \n\n切换到一个分支.\n\n​     git checkout -b (branchname): 创建并切换到新的分支.\n\n​     这个命令是将git branch newbranch和git checkout newbranch合在一起的结果.\n\n​     checkout还有另一个作用:替换本地改动:\n\n​     git checkout --<filename>\n\n​     此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响.\n\n​     注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的.\n\n \n\n**git merge**\n\n​     把一个分支merge进当前的分支.\n\n​     git merge [alias]/[branch]\n\n​     把远程分支merge到当前分支.\n\n \n\n​     如果出现冲突,需要手动修改,可以用git mergetool.\n\n​     解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved.\n\n \n\n**git tag**\n\n​     tag a point in history as import.\n\n​     会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag.\n\n​     比如: git tag v1.0\n\n​     git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag.\n\n​     当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息.\n\n​     \n\n​     我们可以利用commit SHA来给一个过去的提交打tag:\n\n​     git tag -a v0.9 XXXX\n\n \n\n​     push的时候是不包含tag的,如果想包含,可以在push时加上--tags参数.\n\n​     fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上--tags选项.\n\n \n\n**git remote**\n\n​     list, add and delete remote repository aliases.\n\n​     因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list.\n\n​     git remote: 列出remote aliases.\n\n​     如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin.\n\n​     git remote -v:可以看见每一个别名对应的实际url.\n\n​     git remote add [alias] [url]: 添加一个新的remote repo.\n\n​     git remote rm [alias]: 删除一个存在的remote alias.\n\n​     git remote rename [old-alias] [new-alias]: 重命名.\n\n​     git remote set-url [alias] [url]:更新url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址.\n\n \n\n**git fetch**\n\n​     download new branches and data from a remote repository.\n\n​     可以git fetch [alias]取某一个远程repo,也可以git fetch --all取到全部repo\n\n​     fetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们. \n\n \n\n**git pull**\n\n​     fetch from a remote repo and try to merge into the current branch.\n\n​     pull == fetch + merge FETCH_HEAD\n\n​     git pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit.    \n\n​     如果使用--rebase参数,它会执行git rebase来取代原来的git merge.\n\n  \n\n \n\n**git rebase**\n\n​     --rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上.\n\n​     rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要:\n\n​     git rebase --continue就会继续打余下的补丁.\n\n​     git rebase --abort将会终止rebase,当前分支将会回到rebase之前的状态.\n\n \n\n**git push**\n\n​     push your new branches and data to a remote repository.\n\n​     git push [alias] [branch]\n\n​     将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支.\n\n​     如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来.\n\n \n\n**git reflog**\n\n​     git reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化.\n\n​     当git reflog不指定引用的时候,默认列出HEAD的reflog.\n\n​     HEAD@{0}代表HEAD当前的值,HEAD@{3}代表HEAD在3次变化之前的值.\n\n​     git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中.\n\n![](git常用命令\\20181008143725727.png)","tags":["git"]},{"title":"Java Builder Pattern","url":"/2019/05/15/Java-Builder-Pattern/","content":"\n\n\n静态工厂和构造函数有一个共同的限制:它们不能很好地扩展到大量可选参数，所以考虑通过构造器来构造一个类的实例。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n# Telescoping constructor pattern\n\n通常我们在创建一个类的实例时候都是用它的构造函数来创建。例如：\n\n```java\n// Telescoping constructor pattern - does not scale well!\npublic class NutritionFacts {\n    private final int servingSize; // (mL) required\n    private final int servings; // (per container) required\n    private final int calories; // (per serving) optional\n    private final int fat; // (g/serving) optional\n    private final int sodium; // (mg/serving) optional\n    private final int carbohydrate; // (g/serving) optional\n\n    public NutritionFacts(int servingSize, int servings) {\n        this(servingSize, servings, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings,\n                          int calories) {\n        this(servingSize, servings, calories, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings,\n                          int calories, int fat) {\n        this(servingSize, servings, calories, fat, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings,\n                          int calories, int fat, int sodium) {\n        this(servingSize, servings, calories, fat, sodium, 0);\n    }\n\n    public NutritionFacts(int servingSize, int servings,\n                          int calories, int fat, int sodium, int carbohydrate) {\n        this.servingSize = servingSize;\n        this.servings = servings;\n        this.calories = calories;\n        this.fat = fat;\n        this.sodium = sodium;\n        this.carbohydrate = carbohydrate;\n    }\n}\n```\n\n\n\n```java\nNutritionFacts cocaCola =\nnew NutritionFacts(240, 8, 100, 0, 35, 27);\n```\n\n但是这种方式存在很多不便之处：\n\n+ 即使只需要设定一部分参数也要为不需要设置的参数设置默认值\n+ 当参数过多的时候，尤其是存在许多同类型的参数的时候，很容易产生参数设置的混淆，这种混淆编译是不会发现的，在程序运行的时候才会产生错误\n+ 代码不易读懂，用户使用函数时候需要参照api\n\n\n\n# JavaBeans Pattern\n\n另外一种可选的方式是javabean的形式，其主要理念是通过空构造函数来创建一个实例，然后通过set方法对参数进行赋值。例如：\n\n```java\n// JavaBeans Pattern - allows inconsistency, mandates mutability\npublic class NutritionFacts {\n    // Parameters initialized to default values (if any)\n    private int servingSize = -1; // Required; no default value\n    private int servings = -1; // Required; no default value\n    private int calories = 0;\n    private int fat = 0;\n    private int sodium = 0;\n    private int carbohydrate = 0;\n\n    public NutritionFacts() {\n    }\n\n    // Setters\n    public void setServingSize(int val) {\n        servingSize = val;\n    }\n\n    public void setServings(int val) {\n        servings = val;\n    }\n\n    public void setCalories(int val) {\n        calories = val;\n    }\n\n    public void setFat(int val) {\n        fat = val;\n    }\n\n    public void setSodium(int val) {\n        sodium = val;\n    }\n\n    public void setCarbohydrate(int val) {\n        carbohydrate = val;\n    }\n}\n```\n\n这种模式没有Telescoping constructor pattern的任何缺点。\n\n创建实例很容易，虽然有点冗长，并且很容易读取生成的代码:\n\n```java\nNutritionFacts cocaCola = new NutritionFacts();\ncocaCola.setServingSize(240);\ncocaCola.setServings(8);\ncocaCola.setCalories(100);\ncocaCola.setSodium(35);\ncocaCola.setCarbohydrate(27);\n```\n\n但是，javabean模式本身有严重的缺点。因为构造是在多个调用之间分割的，所以JavaBean在构造过程中可能处于不一致的状态。\n\n# Builder pattern \n\n客户机不直接生成所需的对象，而是使用所有必需的参数调用构造函数(或静态工厂)并获得一个构建器对象。然后客户端调用builder对象上类似setter的方法来设置每个可选参数。最后，客户端调用一个无参数的构建方法来生成对象，该对象通常是不可变的。\n\n```java\n/**\n * @Author liu\n * @Description //TODO\n * @Date 9:08 2019/5/15\n * @Param\n * @return\n **/\npublic class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private final int carbohydrate;\n\n    public static class Builder {\n        // Required parameters\n        private final int servingSize;\n        private final int servings;\n        // Optional parameters - initialized to default values\n        private int calories = 0;\n        private int fat = 0;\n        private int sodium = 0;\n        private int carbohydrate = 0;\n\n        public Builder(int servingSize, int servings) {\n            this.servingSize = servingSize;\n            this.servings = servings;\n        }\n\n        public Builder calories(int val) {\n            calories = val;\n            return this;\n        }\n\n        public Builder fat(int val) {\n            fat = val;\n            return this;\n        }\n\n        public Builder sodium(int val) {\n            sodium = val;\n            return this;\n        }\n\n        public Builder carbohydrate(int val) {\n            carbohydrate = val;\n            return this;\n        }\n\n        public NutritionFacts build() {\n            return new NutritionFacts(this);\n        }\n    }\n\n    private NutritionFacts(Builder builder) {\n        servingSize = builder.servingSize;\n        servings = builder.servings;\n        calories = builder.calories;\n        fat = builder.fat;\n        sodium = builder.sodium;\n        carbohydrate = builder.carbohydrate;\n    }\n\n    public static void main(String[] args) {\n        NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)\n                .calories(100).sodium(35).carbohydrate(27).build();\n    }\n}\n```\n\nBuilder pattern也有缺点。为了创建对象，必须首先创建它的构建器。虽然在实践中创建这个构建器的成本不太可能显著，但在性能关键的情况下，它可能会成为一个问题。此外，Builder pattern的代码较为冗长，在设计构造函数或静态工厂有多个参数的类时，尤其是当许多参数是可选的或具有相同类型时，Builder模式是一个很好的选择，因为它更易读、更安全。","tags":["JAVA"]},{"title":"java异常、线程","url":"/2019/05/12/java异常、线程/","content":"\n异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：\n\n- **异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。\n\n在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 1.1 异常概念\n\n异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：\n\n- **异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。\n\n在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。\n\n> 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.\n\n## 1.2 异常体系\n\n异常机制其实是帮助我们**找到**程序中的问题，异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`。\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png)\n\n**Throwable体系：**\n\n- **Error**:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。\n- **Exception**:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。\n\n**Throwable中的常用方法：**\n\n- `public void printStackTrace()`:打印异常的详细信息。\n\n  *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*\n\n- `public String getMessage()`:获取发生异常的原因。\n\n  *提示给用户的时候,就提示错误原因。*\n\n- `public String toString()`:获取异常的类型和异常描述信息(不用)。\n\n***出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。***\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9F%A5%E7%9C%8B.bmp)\n\n## 1.3 异常分类\n\n我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。\n\n**异常(Exception)的分类**:根据在编译时期还是运行时期去检查异常?\n\n- **编译时期异常**:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)\n- **运行时期异常**:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)\n\n​    ![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png)\n\n## 1.4     异常的产生过程解析\n\n先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。\n\n 工具类\n\n```java\npublic class ArrayTools {\n    // 对给定的数组通过给定的角标获取元素。\n    public static int getElement(int[] arr, int index) {\n        int element = arr[index];\n        return element;\n    }\n}\n```\n\n 测试类\n\n```java\npublic class ExceptionDemo {\n    public static void main(String[] args) {\n        int[] arr = { 34, 12, 67 };\n        intnum = ArrayTools.getElement(arr, 4)\n        System.out.println(\"num=\" + num);\n        System.out.println(\"over\");\n    }\n}\n```\n\n上述程序执行过程图解：\n\n ![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png)\n\n# 第二章 异常的处理\n\nJava异常处理的五个关键字：**try、catch、finally、throw、throws**\n\n## 2.1 \t抛出异常throw\n\n在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。\n\n在java中，提供了一个**throw**关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？\n\n1. 创建一个异常对象。封装一些提示信息(信息可以自己编写)。\n\n2. 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。\n\n   throw**用在方法内**，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。\n\n**使用格式：**\n\n```\nthrow new 异常类名(参数);\n```\n\n 例如：\n\n```java\nthrow new NullPointerException(\"要访问的arr数组不存在\");\n\nthrow new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\");\n```\n\n学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。\n\n```java\npublic class ThrowDemo {\n    public static void main(String[] args) {\n        //创建一个数组 \n        int[] arr = {2,4,52,2};\n        //根据索引找对应的元素 \n        int index = 4;\n        int element = getElement(arr, index);\n\n        System.out.println(element);\n        System.out.println(\"over\");\n    }\n    /*\n     * 根据 索引找到数组中对应的元素\n     */\n    public static int getElement(int[] arr,int index){ \n       \t//判断  索引是否越界\n        if(index<0 || index>arr.length-1){\n             /*\n             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。\n             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 \n              */\n             throw new ArrayIndexOutOfBoundsException(\"哥们，角标越界了~~~\");\n        }\n        int element = arr[index];\n        return element;\n    }\n}\n```\n\n> 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。\n>\n> 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。\n\n## 2.2 Objects非空判断\n\n还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。\n\n- `public static <T> T requireNonNull(T obj)`:查看指定引用对象不是null。\n\n查看源码发现这里对为null的进行了抛出异常操作：\n\n```java\npublic static <T> T requireNonNull(T obj) {\n    if (obj == null)\n      \tthrow new NullPointerException();\n    return obj;\n}\n```\n\n## 2.3  声明异常throws\n\n**声明异常**：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。\n\n关键字**throws**运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).\n\n**声明异常格式：**\n\n```\n修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }\t\n```\n\n声明异常的代码演示：\n\n```java\npublic class ThrowsDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        read(\"a.txt\");\n    }\n\n    // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n```\n\nthrows用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。\n\n```java\npublic class ThrowsDemo2 {\n    public static void main(String[] args) throws IOException {\n        read(\"a.txt\");\n    }\n\n    public static void read(String path)throws FileNotFoundException, IOException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n        if (!path.equals(\"b.txt\")) {\n            throw new IOException();\n        }\n    }\n}\n```\n\n## 2.4  捕获异常try…catch\n\n如果异常出现的话,会立刻终止程序,所以我们得处理异常:\n\n1. 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。\n2. 在方法中使用try-catch的语句块来处理异常。\n\n**try-catch**的方式就是捕获异常。\n\n- **捕获异常**：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。\n\n捕获异常语法如下：\n\n```java\ntry{\n     编写可能会出现异常的代码\n}catch(异常类型  e){\n     处理异常的代码\n     //记录日志/打印异常信息/继续抛出异常\n}\n```\n\n**try：**该代码块中编写可能产生异常的代码。\n\n**catch：**用来进行某种异常的捕获，实现对捕获到的异常进行处理。\n\n> 注意:try和catch都不能单独使用,必须连用。\n\n演示如下：\n\n```java\npublic class TryCatchDemo {\n    public static void main(String[] args) {\n        try {// 当产生异常时，必须有处理方式。要么捕获，要么声明。\n            read(\"b.txt\");\n        } catch (FileNotFoundException e) {// 括号中需要定义什么呢？\n          \t//try中抛出的是什么异常，在括号中就定义什么异常类型\n            System.out.println(e);\n        }\n        System.out.println(\"over\");\n    }\n    /*\n     *\n     * 我们 当前的这个方法中 有异常  有编译期异常\n     */\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n```\n\n如何获取异常信息：\n\nThrowable类中定义了一些查看方法:\n\n- `public String getMessage()`:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。\n\n- `public String toString()`:获取异常的类型和异常描述信息(不用)。\n- `public void printStackTrace()`:打印异常的跟踪栈信息并输出到控制台。\n\n​            *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*\n\n## 2.4 finally 代码块\n\n**finally**：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。\n\n什么时候的代码必须最终执行？\n\n当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。\n\nfinally的语法:\n\n try...catch....finally:自身需要处理异常,最终还得关闭资源。\n\n> 注意:finally不能单独使用。\n\n比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。\n\nfinally代码参考如下：\n\n```java\npublic class TryCatchDemo4 {\n    public static void main(String[] args) {\n        try {\n            read(\"a.txt\");\n        } catch (FileNotFoundException e) {\n            //抓取到的是编译期异常  抛出去的是运行期 \n            throw new RuntimeException(e);\n        } finally {\n            System.out.println(\"不管程序怎样，这里都将会被执行。\");\n        }\n        System.out.println(\"over\");\n    }\n    /*\n     *\n     * 我们 当前的这个方法中 有异常  有编译期异常\n     */\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n```\n\n> 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E6%AD%BB%E4%BA%86%E9%83%BD%E8%A6%81try.bmp)\n\n## 2.5   异常注意事项\n\n- 多个异常使用捕获又该如何处理呢？\n\n  1. 多个异常分别处理。\n  2. 多个异常一次捕获，多次处理。\n  3. 多个异常一次捕获一次处理。\n\n  一般我们是使用一次捕获多次处理方式，格式如下：\n\n  ```java\n  try{\n       编写可能会出现异常的代码\n  }catch(异常类型A  e){  当try中出现A类型异常,就用该catch来捕获.\n       处理异常的代码\n       //记录日志/打印异常信息/继续抛出异常\n  }catch(异常类型B  e){  当try中出现B类型异常,就用该catch来捕获.\n       处理异常的代码\n       //记录日志/打印异常信息/继续抛出异常\n  }\n  ```\n\n  > 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。\n\n- 运行时异常被抛出可以不处理。即不捕获也不声明抛出。\n\n- 如果finally有return语句,永远返回finally中的结果,避免该情况. \n\n- 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。\n\n- 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出\n\n# 第三章 自定义异常\n\n## 3.1 概述\n\n**为什么需要自定义异常类:**\n\n我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。\n\n在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？\n\n**什么是自定义异常类:**\n\n在开发中根据自己业务的异常情况来定义异常类.\n\n自定义一个业务逻辑异常: **RegisterException**。一个注册异常类。\n\n**异常类如何定义:**\n\n1. 自定义一个编译期异常: 自定义类 并继承于`java.lang.Exception`。\n2. 自定义一个运行时期的异常类:自定义类 并继承于`java.lang.RuntimeException`。\n\n## 3.2 自定义异常的练习\n\n要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。\n\n首先定义一个登陆异常类RegisterException：\n\n```java\n// 业务逻辑异常\npublic class RegisterException extends Exception {\n    /**\n     * 空参构造\n     */\n    public RegisterException() {\n    }\n\n    /**\n     *\n     * @param message 表示异常提示\n     */\n    public RegisterException(String message) {\n        super(message);\n    }\n}\n```\n\n模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。\n\n```java\npublic class Demo {\n    // 模拟数据库中已存在账号\n    private static String[] names = {\"bill\",\"hill\",\"jill\"};\n   \n    public static void main(String[] args) {     \n        //调用方法\n        try{\n              // 可能出现异常的代码\n            checkUsername(\"nill\");\n            System.out.println(\"注册成功\");//如果没有异常就是注册成功\n        }catch(RegisterException e){\n            //处理异常\n            e.printStackTrace();\n        }\n    }\n\n    //判断当前注册账号是否存在\n    //因为是编译期异常，又想调用者去处理 所以声明该异常\n    public static boolean checkUsername(String uname) throws LoginException{\n        for (String name : names) {\n            if(name.equals(uname)){//如果名字在这里面 就抛出登陆异常\n                throw new RegisterException(\"亲\"+name+\"已经被注册了！\");\n            }\n        }\n        return true;\n    }\n}\n```\n\n# 第四章 多线程\n\n我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？\n\n要解决上述问题,咱们得使用多进程或者多线程来解决.\n\n## 4.1 并发与并行\n\n- **并发**：指两个或多个事件在**同一个时间段内**发生。\n- **并行**：指两个或多个事件在**同一时刻**发生（同时发生）。\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91.bmp)\n\n在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。\n\n而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。\n\n> 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。\n\n## 4.2 线程与进程\n\n- **进程**：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。\n\n- **线程**：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 \n\n  简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 \n\n我们可以再电脑底部任务栏，右键----->打开任务管理器,可以查看当前任务的进程：\n\n**进程**\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5.png)\n\n**线程**\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png)\n\n**线程调度:**\n\n- 分时调度\n\n  所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。\n\n- 抢占式调度\n\n  优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。\n\n  - 设置线程的优先级\n\n  ![设置线程优先级](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.bmp)\n\n  - 抢占式调度详解\n\n    大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。\n\n    实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。\n    其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。\n\n    ![抢占式调度](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/05.%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/16.%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91-%E7%AC%94%E8%AE%B0/%E5%B0%B1%E4%B8%9A%E7%8F%AD-day05-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/img/%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.bmp)\n\n## 4.3 创建线程类\n\nJava使用`java.lang.Thread`类代表**线程**，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来**创建**并**启动多线程**的步骤如下：\n\n1. 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。\n2. 创建Thread子类的实例，即创建了线程对象\n3. 调用线程对象的start()方法来启动该线程\n\n代码如下：\n\n测试类：\n\n```java\npublic class Demo01 {\n\tpublic static void main(String[] args) {\n\t\t//创建自定义线程对象\n\t\tMyThread mt = new MyThread(\"新的线程！\");\n\t\t//开启新线程\n\t\tmt.start();\n\t\t//在主方法中执行for循环\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tSystem.out.println(\"main线程！\"+i);\n\t\t}\n\t}\n}\n```\n\n自定义线程类：\n\n```java\npublic class MyThread extends Thread {\n\t//定义指定线程名称的构造方法\n\tpublic MyThread(String name) {\n\t\t//调用父类的String参数的构造方法，指定线程的名称\n\t\tsuper(name);\n\t}\n\t/**\n\t * 重写run方法，完成该线程执行的逻辑\n\t */\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tSystem.out.println(getName()+\"：正在执行！\"+i);\n\t\t}\n\t}\n}\n```","tags":["java"]},{"title":"java集合工具对自定义类进行排序","url":"/2019/05/11/java集合工具对自定义类进行排序/","content":"\n想要被排序的类需要实现Comparable接口并且重写compareTo方法。 this - 传进来的参数为升序。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n```java\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) throws ParseException {\n\n        List<User> list = new ArrayList<User>();\n        list.add(new User(65, \"小张\"));\n        list.add(new User(77, \"小强\"));\n        list.add(new User(39, \"小明\"));\n        list.add(new User(99, \"小红\"));\n        Collections.sort(list);\n        System.out.println(list);\n    }\n\n}\n\nclass User implements Comparable<User> {\n    private int score;\n    private String name;\n\n    public User(int score, String name) {\n\n        this.score = score;\n        this.name = name;\n    }\n\n    public int getScore() {\n        return score;\n    }\n\n    public void setScore(int score) {\n        this.score = score;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"score=\" + score +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n\n    @Override\n    public int compareTo(User o) {\n        return this.getScore() - o.getScore();\n    }\n}\n```\n\n","tags":["JAVA"]},{"title":"java常用类api","url":"/2019/05/10/java常用类api/","content":"\njava常用类api\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n#  Object类\n\n## 1.1 概述\n\n`java.lang.Object`类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。\n\n如果一个类没有特别指定父类，\t那么默认则继承自Object类。例如：\n\n```java\npublic class MyClass /*extends Object*/ {\n  \t// ...\n}\n```\n\n根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：\n\n- `public String toString()`：返回该对象的字符串表示。\n- `public boolean equals(Object obj)`：指示其他某个对象是否与此对象“相等”。\n\n## 1.2 toString方法\n\n### 方法摘要\n\n- `public String toString()`：返回该对象的字符串表示。\n\ntoString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。\n\n由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。\n\n### 覆盖重写\n\n如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：\n\n```java\npublic class Person {  \n    private String name;\n    private int age;\n\n    @Override\n    public String toString() {\n        return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}';\n    }\n\n    // 省略构造器与Getter Setter\n}\n```\n\n在IntelliJ IDEA中，可以点击`Code`菜单中的`Generate...`，也可以使用快捷键`alt+insert`，点击`toString()`选项。选择需要包含的成员变量并确定。如下图所示：\n\n> 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。\n\n## 1.3 equals方法\n\n### 方法摘要\n\n- `public boolean equals(Object obj)`：指示其他某个对象是否与此对象“相等”。\n\n调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。\n\n### 默认地址比较\n\n如果没有覆盖重写equals方法，那么Object类中默认进行`==`运算符的对象地址比较，只要不是同一个对象，结果必然为false。\n\n### 对象内容比较\n\n如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：\n\n```java\nimport java.util.Objects;\n\npublic class Person {\t\n\tprivate String name;\n\tprivate int age;\n\t\n    @Override\n    public boolean equals(Object o) {\n        // 如果对象地址一样，则认为相同\n        if (this == o)\n            return true;\n        // 如果参数为空，或者类型信息不一样，则认为不同\n        if (o == null || getClass() != o.getClass())\n            return false;\n        // 转换为当前类型\n        Person person = (Person) o;\n        // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果\n        return age == person.age && Objects.equals(name, person.name);\n    }\n}\n```\n\n这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用`Code`菜单中的`Generate…`选项，也可以使用快捷键`alt+insert`，并选择`equals() and hashCode()`进行自动代码生成。如下图所示：\n\n\n\n## 1.4 Objects类\n\n在刚才IDEA自动重写equals代码中，使用到了`java.util.Objects`类，那么这个类是什么呢？\n\n在**JDK7**添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。\n\n在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：\n\n- `public static boolean equals(Object a, Object b)`:判断两个对象是否相等。\n\n我们可以查看一下源码，学习一下：\n\n```java\npublic static boolean equals(Object a, Object b) {  \n    return (a == b) || (a != null && a.equals(b));  \n}\n```\n\n# 日期时间类\n\n## 2.1 Date类\n\n### 概述\n\n` java.util.Date`类 表示特定的瞬间，精确到毫秒。\n\n继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。\n\n- `public Date()`：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。\n- `public Date(long date)`：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。\n\n> tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。\n\n简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：\n\n```java\nimport java.util.Date;\n\npublic class Demo01Date {\n    public static void main(String[] args) {\n        // 创建日期对象，把当前的时间\n        System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018\n        // 创建日期对象，把当前的毫秒值转成日期对象\n        System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970\n    }\n}\n```\n\n> tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。\n\n### 常用方法\n\nDate类中的多数方法已经过时，常用的方法有：\n\n- `public long getTime()` 把日期对象转换成对应的时间毫秒值。\n\n## 2.2 DateFormat类\n\n`java.text.DateFormat` 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。\n\n- **格式化**：按照指定的格式，从Date对象转换为String对象。\n- **解析**：按照指定的格式，从String对象转换为Date对象。\n\n### 构造方法\n\n由于DateFormat为抽象类，不能直接使用，所以需要常用的子类`java.text.SimpleDateFormat`。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：\n\n- `public SimpleDateFormat(String pattern)`：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。\n\n参数pattern是一个字符串，代表日期时间的自定义格式。\n\n### 格式规则\n\n常用的格式规则为：\n\n| 标识字母（区分大小写） | 含义 |\n| ---------------------- | ---- |\n| y                      | 年   |\n| M                      | 月   |\n| d                      | 日   |\n| H                      | 时   |\n| m                      | 分   |\n| s                      | 秒   |\n\n> 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。\n\n创建SimpleDateFormat对象的代码如：\n\n```java\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\n\npublic class Demo02SimpleDateFormat {\n    public static void main(String[] args) {\n        // 对应的日期格式如：2018-01-16 15:06:38\n        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    }    \n}\n```\n\n### 常用方法\n\nDateFormat类的常用方法有：\n\n- `public String format(Date date)`：将Date对象格式化为字符串。\n- `public Date parse(String source)`：将字符串解析为Date对象。\n\n#### format方法\n\n使用format方法的代码为：\n\n```java\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n/*\n 把Date对象转换成String\n*/\npublic class Demo03DateFormatMethod {\n    public static void main(String[] args) {\n        Date date = new Date();\n        // 创建日期格式化对象,在获取格式化对象时可以指定风格\n        DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\");\n        String str = df.format(date);\n        System.out.println(str); // 2008年1月23日\n    }\n}\n```\n\n#### parse方法\n\n使用parse方法的代码为：\n\n```java\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n/*\n 把String转换成Date对象\n*/\npublic class Demo04DateFormatMethod {\n    public static void main(String[] args) throws ParseException {\n        DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\");\n        String str = \"2018年12月11日\";\n        Date date = df.parse(str);\n        System.out.println(date); // Tue Dec 11 00:00:00 CST 2018\n    }\n}\n```\n\n\n\n## 2.4 Calendar类\n\n### 概念\n\n日历我们都见过\n\n`java.util.Calendar`是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。\n\n### 获取方式\n\nCalendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：\n\nCalendar静态方法\n\n- `public static Calendar getInstance()`：使用默认时区和语言环境获得一个日历\n\n例如：\n\n```java\nimport java.util.Calendar;\n\npublic class Demo06CalendarInit {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n    }    \n}\n```\n\n### 常用方法\n\n根据Calendar类的API文档，常用方法有：\n\n- `public int get(int field)`：返回给定日历字段的值。\n- `public void set(int field, int value)`：将给定的日历字段设置为给定值。\n- `public abstract void add(int field, int amount)`：根据日历的规则，为给定的日历字段添加或减去指定的时间量。\n- `public Date getTime()`：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。\n\nCalendar类中提供很多成员常量，代表给定的日历字段：\n\n| 字段值       | 含义                                  |\n| ------------ | ------------------------------------- |\n| YEAR         | 年                                    |\n| MONTH        | 月（从0开始，可以+1使用）             |\n| DAY_OF_MONTH | 月中的天（几号）                      |\n| HOUR         | 时（12小时制）                        |\n| HOUR_OF_DAY  | 时（24小时制）                        |\n| MINUTE       | 分                                    |\n| SECOND       | 秒                                    |\n| DAY_OF_WEEK  | 周中的天（周几，周日为1，可以-1使用） |\n\n#### get/set方法\n\nget方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：\n\n```java\nimport java.util.Calendar;\n\npublic class CalendarUtil {\n    public static void main(String[] args) {\n        // 创建Calendar对象\n        Calendar cal = Calendar.getInstance();\n        // 设置年 \n        int year = cal.get(Calendar.YEAR);\n        // 设置月\n        int month = cal.get(Calendar.MONTH) + 1;\n        // 设置日\n        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\");\n    }    \n}\n```\n\n```java\nimport java.util.Calendar;\n\npublic class Demo07CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.YEAR, 2020);\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日\n    }\n}\n```\n\n#### add方法\n\nadd方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：\n\n```java\nimport java.util.Calendar;\n\npublic class Demo08CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日\n        // 使用add方法\n        cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天\n        cal.add(Calendar.YEAR, -3); // 减3年\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; \n    }\n}\n```\n\n#### getTime方法\n\nCalendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。\n\n```java\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class Demo09CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        Date date = cal.getTime();\n        System.out.println(date); // Tue Jan 16 16:03:09 CST 2018\n    }\n}\n```\n\n> 小贴士：\n>\n> ​     西方星期的开始为周日，中国为周一。\n>\n> ​     在Calendar类中，月份的表示是以0-11代表1-12月。\n>\n> ​     日期是有大小关系的，时间靠后，时间越大。\n\n#  System类\n\n`java.lang.System`类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：\n\n- `public static long currentTimeMillis()`：返回以毫秒为单位的当前时间。\n- `public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`：将数组中指定的数据拷贝到另一个数组中。\n\n## 3.1 currentTimeMillis方法\n\n实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值\n\n```java\nimport java.util.Date;\n\npublic class SystemDemo {\n    public static void main(String[] args) {\n       \t//获取当前时间毫秒值\n        System.out.println(System.currentTimeMillis()); // 1516090531144\n    }\n}\n```\n\n### 练习\n\n验证for循环打印数字1-9999所需要使用的时间（毫秒）\n\n```java\npublic class SystemTest1 {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 10000; i++) {\n            System.out.println(i);\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"共耗时毫秒：\" + (end - start));\n    }\n}\n```\n\n## 3.2 arraycopy方法\n\n- `public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`：将数组中指定的数据拷贝到另一个数组中。\n\n数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：\n\n| 参数序号 | 参数名称 | 参数类型 | 参数含义             |\n| -------- | -------- | -------- | -------------------- |\n| 1        | src      | Object   | 源数组               |\n| 2        | srcPos   | int      | 源数组索引起始位置   |\n| 3        | dest     | Object   | 目标数组             |\n| 4        | destPos  | int      | 目标数组索引起始位置 |\n| 5        | length   | int      | 复制元素个数         |\n\n### 练习\n\n将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]\n\n```java\nimport java.util.Arrays;\n\npublic class Demo11SystemArrayCopy {\n    public static void main(String[] args) {\n        int[] src = new int[]{1,2,3,4,5};\n        int[] dest = new int[]{6,7,8,9,10};\n        System.arraycopy( src, 0, dest, 0, 3);\n        /*代码运行后：两个数组中的元素发生了变化\n         src数组元素[1,2,3,4,5]\n         dest数组元素[1,2,3,9,10]\n        */\n    }\n}\n```\n\n# StringBuilder类\n\n## 4.1 字符串拼接问题\n\n由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：\n\n```java\npublic class StringDemo {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        s += \"World\";\n        System.out.println(s);\n    }\n}\n```\n\n在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。\n\n根据这句话分析我们的代码，其实总共产生了三个字符串，即`\"Hello\"`、`\"World\"`和`\"HelloWorld\"`。引用变量s首先指向`Hello`对象，最终指向拼接出来的新字符串对象，即`HelloWord` 。\n\n![](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/03.%E5%B8%B8%E7%94%A8API%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/12.%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91/12.%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/img/String%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98.bmp)\n\n由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用`java.lang.StringBuilder`类。\n\n## 4.2 StringBuilder概述\n\n查阅`java.lang.StringBuilder`的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。\n\n原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。\n\n它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)\n\n![06-StringBuilder的原理](D:/java%E9%AB%98%E7%BA%A7/1-3-Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/%E8%B5%84%E6%96%99/03.%E5%B8%B8%E7%94%A8API%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/12.%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91/12.%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/img/06-StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.png)\n\n## 4.3 构造方法\n\n根据StringBuilder的API文档，常用构造方法有2个：\n\n- `public StringBuilder()`：构造一个空的StringBuilder容器。\n- `public StringBuilder(String str)`：构造一个StringBuilder容器，并将字符串添加进去。\n\n```java\npublic class StringBuilderDemo {\n    public static void main(String[] args) {\n        StringBuilder sb1 = new StringBuilder();\n        System.out.println(sb1); // (空白)\n        // 使用带参构造\n        StringBuilder sb2 = new StringBuilder(\"itcast\");\n        System.out.println(sb2); // itcast\n    }\n}\n```\n\n## 4.4 常用方法\n\nStringBuilder常用的方法有2个：\n\n- `public StringBuilder append(...)`：添加任意类型数据的字符串形式，并返回当前对象自身。\n- `public String toString()`：将当前StringBuilder对象转换为String对象。\n\n### append方法\n\nappend方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：\n\n```java\npublic class Demo02StringBuilder {\n\tpublic static void main(String[] args) {\n\t\t//创建对象\n\t\tStringBuilder builder = new StringBuilder();\n\t\t//public StringBuilder append(任意类型)\n\t\tStringBuilder builder2 = builder.append(\"hello\");\n\t\t//对比一下\n\t\tSystem.out.println(\"builder:\"+builder);\n\t\tSystem.out.println(\"builder2:\"+builder2);\n\t\tSystem.out.println(builder == builder2); //true\n\t    // 可以添加 任何类型\n\t\tbuilder.append(\"hello\");\n\t\tbuilder.append(\"world\");\n\t\tbuilder.append(true);\n\t\tbuilder.append(100);\n\t\t// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。\n        // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下\n\t\t//链式编程\n\t\tbuilder.append(\"hello\").append(\"world\").append(true).append(100);\n\t\tSystem.out.println(\"builder:\"+builder);\n\t}\n}\n```\n\n> 备注：StringBuilder已经覆盖重写了Object当中的toString方法。\n\n### toString方法\n\n通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：\n\n```java\npublic class Demo16StringBuilder {\n    public static void main(String[] args) {\n        // 链式创建\n        StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\");\n        // 调用方法\n        String str = sb.toString();\n        System.out.println(str); // HelloWorldJava\n    }\n}\n```\n\n# 包装类\n\n## 5.1 概述\n\nJava提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：\n\n| 基本类型 | 对应的包装类（位于java.lang包中） |\n| -------- | --------------------------------- |\n| byte     | Byte                              |\n| short    | Short                             |\n| int      | **Integer**                       |\n| long     | Long                              |\n| float    | Float                             |\n| double   | Double                            |\n| char     | **Character**                     |\n| boolean  | Boolean                           |\n\n## 5.2 装箱与拆箱\n\n基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：\n\n- **装箱**：从基本类型转换为对应的包装类对象。\n- **拆箱**：从包装类对象转换为对应的基本类型。\n\n用Integer与 int为例：（看懂代码即可）\n\n基本数值---->包装对象\n\n```java\nInteger i = new Integer(4);//使用构造函数函数\nInteger iii = Integer.valueOf(4);//使用包装类中的valueOf方法\n```\n\n包装对象---->基本数值\n\n```java\nint num = i.intValue();\n```\n\n## 5.3自动装箱与自动拆箱\n\n由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：\n\n```java\nInteger i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);\ni = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;\n//加法运算完成后，再次装箱，把基本数值转成对象。\n```\n\n## 5.3 基本类型与字符串之间的转换\n\n### 基本类型转换为String\n\n   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： \n\n```\n基本类型直接与””相连接即可；如：34+\"\"\n```\n\nString转换成对应的基本类型 \n\n除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：\n\n- `public static byte parseByte(String s)`：将字符串参数转换为对应的byte基本类型。\n- `public static short parseShort(String s)`：将字符串参数转换为对应的short基本类型。\n- `public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。\n- `public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。\n- `public static float parseFloat(String s)`：将字符串参数转换为对应的float基本类型。\n- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。\n- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的boolean基本类型。\n\n代码使用（仅以Integer类的静态方法parseXxx为例）如：\n\n```java\npublic class Demo18WrapperParse {\n    public static void main(String[] args) {\n        int num = Integer.parseInt(\"100\");\n    }\n}\n```\n\n> 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。\n\n","tags":["java"]},{"title":"Spring Boot单/多文件上传","url":"/2019/05/06/Spring-Boot单文件上传/","content":"\nSpring Bootd单/多文件上传\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 单/多文件上传\n\nupload.html：\n\n```html\n<!DOCTYPE HTML>\n<html>\n<head>\n    <title>文件上传</title>\n</head>\n\n<body>\n<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">\n    上传文件1：<input type=\"file\" name=\"file\"><br/>\n    <input type=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n\n\nUploadController:\n\n```java\npackage com.example.demo.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.multipart.MultipartFile;\nimport org.springframework.web.multipart.MultipartHttpServletRequest;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\n\n@Controller\npublic class UploadController {\n    @GetMapping(\"/upload\")\n    public String upload() {\n        return \"upload\";\n    }\n\n    @GetMapping(\"/multiUpload\")\n    public String multiUpload() {\n        return \"multiUpload\";\n    }\n\n\n    @PostMapping(\"/multiUpload\")\n    @ResponseBody\n    public String multiUpload(HttpServletRequest request) {\n        List<MultipartFile> files = ((MultipartHttpServletRequest) request).getFiles(\"file\");\n        String filePath = \"D:/path/\";\n        for (int i = 0; i < files.size(); i++) {\n            MultipartFile file = files.get(i);\n            if (file.isEmpty()) {\n                return \"上传第\" + (i++) + \"个文件失败\";\n            }\n            String fileName = file.getOriginalFilename();\n\n            File dest = new File(filePath + fileName);\n            try {\n                file.transferTo(dest);\n            } catch (IOException e) {\n                return \"上传第\" + (i++) + \"个文件失败\";\n            }\n        }\n\n        return \"上传成功\";\n\n    }\n\n\n    @PostMapping(\"/upload\")\n    @ResponseBody\n    public String upload(@RequestParam(\"file\") MultipartFile file) {\n        if (file.isEmpty()) {\n            return \"上传失败，请选择文件\";\n        }\n\n        String fileName = file.getOriginalFilename();\n        String filePath = \"D:/path/\";\n        File dest = new File(filePath + fileName);\n        try {\n            file.transferTo(dest);\n            return \"上传成功\";\n        } catch (IOException e) {\n        }\n        return \"上传失败！\";\n    }\n}\n\n\n```\n\n\n\nmultiUpload.html\n\n```html\n<!DOCTYPE HTML>\n<html>\n<head>\n    <title>文件上传</title>\n</head>\n\n<body>\n<form action=\"/multiUpload\" enctype=\"multipart/form-data\" method=\"post\">\n    上传文件：<input type=\"file\" name=\"file\"><br/>\n    上传文件：<input type=\"file\" name=\"file\"><br/>\n    上传文件：<input type=\"file\" name=\"file\"><br/>\n    上传文件：<input type=\"file\" name=\"file\"><br/>\n    <input type=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n\n\n\n\n\n\n## 设置上传文件大小的两种方式\n\n### springboot 1.5.X系列处理方式\n\n#### 创建tomcat配置类\n\n```java\n @Bean  \n    public MultipartConfigElement multipartConfigElement() {  \n        MultipartConfigFactory factory = new MultipartConfigFactory();  \n        //文件最大  \n        factory.setMaxFileSize(\"10240KB\"); //KB,MB  \n        /// 设置总上传数据总大小  \n        factory.setMaxRequestSize(\"102400KB\");  \n        return factory.createMultipartConfig();  \n    }  \n```\n\n**注意**\nspring.http.multipart.maxFileSize=10Mb\nspring.http.multipart.maxRequestSize=10Mb\n已经过期 >>>>\n\n#### **在application.properties中添加如下配置信息**\n\napplication.properties\n\n```xml\n spring.servlet.multipart.max-file-size=20MB\n spring.servlet.multipart.max-request-size=20MB\n```\n\nmaxFileSize 是单个文件大小\nmaxRequestSize是设置总上传的数据大小\n\n\n\n### Springboot 2.X系列配置\n\n#### 创建tomcat配置类\n\n```java\n\n@Configuration\npublic class TomcatConfig {\n\n\n    @Bean\n    public MultipartConfigElement multipartConfigElement() {\n        MultipartConfigFactory factory = new MultipartConfigFactory();\n        //文件最大10M,DataUnit提供5中类型B,KB,MB,GB,TB\n        factory.setMaxFileSize(DataSize.of(100, DataUnit.MEGABYTES));\n        /// 设置总上传数据总大小10M\n        factory.setMaxRequestSize(DataSize.of(100, DataUnit.MEGABYTES));\n        return factory.createMultipartConfig();\n    }\n}\n```\n\n#### 配置文件配置\n\napplication.properties\n\n```xml\n   spring.servlet.multipart.max-file-size=20MB\n   spring.servlet.multipart.max-request-size=20MB\n```\n\n\n\n","tags":["Spring Boot"]},{"title":"JAVAWEB文件上传","url":"/2019/05/06/form表单文件上传/","content":"\n对于文件上传，浏览器在上传的过程中是将文件以流的形式提交到服务器端的，如果直接使用Servlet获取上传文件的输入流然后再解析里面的请求参数是比较麻烦，所以一般选择采用apache的开源工具common-fileupload这个文件上传组件。这个common-fileupload上传组件的jar包可以去apache官网上面下载，也可以在struts的lib文件夹下面找到，struts上传的功能就是基于这个实现的。common-fileupload是依赖于common-io这个包的，所以还需要下载这个包。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\nUploadHandleServlet的代码如下：\n\n```java\npackage me.gacl.web.controller;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.UUID;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadBase;\nimport org.apache.commons.fileupload.ProgressListener;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n* @ClassName: UploadHandleServlet\n*\n*/ \npublic class UploadHandleServlet extends HttpServlet {\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n                //得到上传文件的保存目录，将上传的文件存放于WEB-INF目录下，不允许外界直接访问，保证上传文件的安全\n                String savePath = this.getServletContext().getRealPath(\"/WEB-INF/upload\");\n                //上传时生成的临时文件保存目录\n                String tempPath = this.getServletContext().getRealPath(\"/WEB-INF/temp\");\n                File tmpFile = new File(tempPath);\n                if (!tmpFile.exists()) {\n                    //创建临时目录\n                    tmpFile.mkdir();\n                }\n                \n                //消息提示\n                String message = \"\";\n                try{\n                    //使用Apache文件上传组件处理文件上传步骤：\n                    //1、创建一个DiskFileItemFactory工厂\n                    DiskFileItemFactory factory = new DiskFileItemFactory();\n                    //设置工厂的缓冲区的大小，当上传的文件大小超过缓冲区的大小时，就会生成一个临时文件存放到指定的临时目录当中。\n                    factory.setSizeThreshold(1024*100);//设置缓冲区的大小为100KB，如果不指定，那么缓冲区的大小默认是10KB\n                    //设置上传时生成的临时文件的保存目录\n                    factory.setRepository(tmpFile);\n                    //2、创建一个文件上传解析器\n                    ServletFileUpload upload = new ServletFileUpload(factory);\n                    //监听文件上传进度\n                    upload.setProgressListener(new ProgressListener(){\n                        public void update(long pBytesRead, long pContentLength, int arg2) {\n                            System.out.println(\"文件大小为：\" + pContentLength + \",当前已处理：\" + pBytesRead);\n                            /**\n                             * 文件大小为：14608,当前已处理：4096\n                                文件大小为：14608,当前已处理：7367\n                                文件大小为：14608,当前已处理：11419\n                                文件大小为：14608,当前已处理：14608\n                             */\n                        }\n                    });\n                     //解决上传文件名的中文乱码\n                    upload.setHeaderEncoding(\"UTF-8\"); \n                    //3、判断提交上来的数据是否是上传表单的数据\n                    if(!ServletFileUpload.isMultipartContent(request)){\n                        //按照传统方式获取数据\n                        return;\n                    }\n                    \n                    //设置上传单个文件的大小的最大值，目前是设置为1024*1024字节，也就是1MB\n                    upload.setFileSizeMax(1024*1024);\n                    //设置上传文件总量的最大值，最大值=同时上传的多个文件的大小的最大值的和，目前设置为10MB\n                    upload.setSizeMax(1024*1024*10);\n                    //4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List<FileItem>集合，每一个FileItem对应一个Form表单的输入项\n                    List<FileItem> list = upload.parseRequest(request);\n                    for(FileItem item : list){\n                        //如果fileitem中封装的是普通输入项的数据\n                        if(item.isFormField()){\n                            String name = item.getFieldName();\n                            //解决普通输入项的数据的中文乱码问题\n                            String value = item.getString(\"UTF-8\");\n                            //value = new String(value.getBytes(\"iso8859-1\"),\"UTF-8\");\n                            System.out.println(name + \"=\" + value);\n                        }else{//如果fileitem中封装的是上传文件\n                            //得到上传的文件名称，\n                            String filename = item.getName();\n                            System.out.println(filename);\n                            if(filename==null || filename.trim().equals(\"\")){\n                                continue;\n                            }\n                            //注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如：  c:\\a\\b\\1.txt，而有些只是单纯的文件名，如：1.txt\n                            //处理获取到的上传文件的文件名的路径部分，只保留文件名部分\n                            filename = filename.substring(filename.lastIndexOf(\"\\\\\")+1);\n                            //得到上传文件的扩展名\n                            String fileExtName = filename.substring(filename.lastIndexOf(\".\")+1);\n                            //如果需要限制上传的文件类型，那么可以通过文件的扩展名来判断上传的文件类型是否合法\n                            System.out.println(\"上传的文件的扩展名是：\"+fileExtName);\n                            //获取item中的上传文件的输入流\n                            InputStream in = item.getInputStream();\n                            //得到文件保存的名称\n                            String saveFilename = makeFileName(filename);\n                            //得到文件的保存目录\n                            String realSavePath = makePath(saveFilename, savePath);\n                            //创建一个文件输出流\n                            FileOutputStream out = new FileOutputStream(realSavePath + \"\\\\\" + saveFilename);\n                            //创建一个缓冲区\n                            byte buffer[] = new byte[1024];\n                            //判断输入流中的数据是否已经读完的标识\n                            int len = 0;\n                            //循环将输入流读入到缓冲区当中，(len=in.read(buffer))>0就表示in里面还有数据\n                            while((len=in.read(buffer))>0){\n                                //使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath + \"\\\\\" + filename)当中\n                                out.write(buffer, 0, len);\n                            }\n                            //关闭输入流\n                            in.close();\n                            //关闭输出流\n                            out.close();\n                            //删除处理文件上传时生成的临时文件\n                            //item.delete();\n                            message = \"文件上传成功！\";\n                        }\n                    }\n                }catch (FileUploadBase.FileSizeLimitExceededException e) {\n                    e.printStackTrace();\n                    request.setAttribute(\"message\", \"单个文件超出最大值！！！\");\n                    request.getRequestDispatcher(\"/message.jsp\").forward(request, response);\n                    return;\n                }catch (FileUploadBase.SizeLimitExceededException e) {\n                    e.printStackTrace();\n                    request.setAttribute(\"message\", \"上传文件的总的大小超出限制的最大值！！！\");\n                    request.getRequestDispatcher(\"/message.jsp\").forward(request, response);\n                    return;\n                }catch (Exception e) {\n                    message= \"文件上传失败！\";\n                    e.printStackTrace();\n                }\n                request.setAttribute(\"message\",message);\n                request.getRequestDispatcher(\"/message.jsp\").forward(request, response);\n    }\n    \n    /**\n    * @Method: makeFileName\n    */ \n    private String makeFileName(String filename){  //2.jpg\n        //为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名\n        return UUID.randomUUID().toString() + \"_\" + filename;\n    }\n    \n    /**\n     * 为防止一个目录下面出现太多文件，要使用hash算法打散存储\n    */ \n    private String makePath(String filename,String savePath){\n        //得到文件名的hashCode的值，得到的就是filename这个字符串对象在内存中的地址\n        int hashcode = filename.hashCode();\n        int dir1 = hashcode&0xf;  //0--15\n        int dir2 = (hashcode&0xf0)>>4;  //0-15\n        //构造新的保存目录\n        String dir = savePath + \"\\\\\" + dir1 + \"\\\\\" + dir2;  //upload\\2\\3  upload\\3\\5\n        //File既可以代表文件也可以代表目录\n        File file = new File(dir);\n        //如果目录不存在\n        if(!file.exists()){\n            //创建目录\n            file.mkdirs();\n        }\n        return dir;\n    }\n\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        doGet(request, response);\n    }\n}\n```\n\n\n\nupload.jsp页面的代码如下：\n\n```html\n<%@ page language=\"java\" pageEncoding=\"UTF-8\"%>\n<!DOCTYPE HTML>\n<html>\n  <head>\n    <title>文件上传</title>\n  </head>\n  \n  <body>\n    <form action=\"${pageContext.request.contextPath}/servlet/UploadHandleServlet\" enctype=\"multipart/form-data\" method=\"post\">\n        上传用户：<input type=\"text\" name=\"username\"><br/>\n        上传文件1：<input type=\"file\" name=\"file1\"><br/>\n        上传文件2：<input type=\"file\" name=\"file2\"><br/>\n        <input type=\"submit\" value=\"提交\">\n    </form>\n  </body>\n</html>\n```\n\n\n\n","tags":["JAVA"]},{"title":"vue学习笔记(二)","url":"/2019/04/19/vue学习笔记-二/","content":"\nVue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与[现代化的工具链](https://cn.vuejs.org/v2/guide/single-file-components.html)以及各种[支持类库](https://github.com/vuejs/awesome-vue#libraries--plugins)结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## Class与Style绑定\n\n### 绑定HTML Class\n\n#### 对象语法\n\n可以传给v-bind:class一个对象,动态的切换class:\n\n```html\n<div class=\"static\" id = \"div1\"  v-bind:class=\"{'active': isActive, 'text-danger' : hasError}\">\n\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#div1',\n\t\t\t\tdata:{\n\t\t\t\t\tisActive : true,\n\t\t\t\t\thasError : true\n\t\t\t\t}\n\t\t\t})\n```\n\n当对应的属性的值为true的时候,div的class里就会增加相应的格式,上述例子的class为:\n\n```html\nstatic active text-danger\n```\n\n\n\n绑定的数据对象不必内联定义在模板里：\n\n```html\n<div id=\"div2\" v-bind:class=\"classObject\"></div>\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#div2',\n\t\t\t\tdata:{\n\t\t\t\tclassObject:{\n\t\t\t\t\tavtive:true,\n\t\t\t\t\t'text-danger':true\n\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t})\n```\n\n 也可以使 div   class=\"avtive text-danger\"\n\n我们也可以在这里绑定一个返回对象的计算属性:\n\n```java\n<div id=\"div3\" v-bind:class=\"classObject3\"></div>\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#div3',\n\t\t\t\tdata:{\n\t\t\t\t\tisActive:true,\n\t\t\t\t\terror: null\n\t\t\t\t},\n\t\t\t\tcomputed:{\n\t\t\t\t\tclassObject3:function(){\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tactive:this.isActive&&!this.error,'text-danger':this.error&&this.error.type ==='fatal'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t)\n```\n\n\n\n#### 数组语法:\n\n我们可以把一个数组传给v-bind:class,以应用一个class列表:\n\n```html\n<div id = \"div4\" v-bind:class=\"[activeClass, errorClass]\">div4</div>\n\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#div4',\n\t\t\t\tdata:{\n\t\t\t\t\tactiveClass: 'active',\n\t\t\t\t\terrorClass: 'text-danger'\n\t\t\t\t}\n\t\t\t})\n```\n\n\n\n也可以用三元表达式来按条件切换class\n\n```html\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n```\n\n\n\n#### 用在组件上\n\n当在一个自定义组件上使用 `class` 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。\n\n例如，如果你声明了这个组件：\n\n```\nVue.component('my-component', {\n  template: '<p class=\"foo bar\">Hi</p>'\n})\n```\n\n然后在使用它的时候添加一些 class：\n\n```\n<my-component class=\"baz boo\"></my-component>\n```\n\nHTML 将被渲染为:\n\n```html\n<p class=\"foo bar baz boo\">Hi</p>\n```\n\nhtml对于带数据绑定 class 也同样适用：\n\n```html\n<my-component v-bind:class=\"{ active: isActive }\"></my-component>\n```\n\n当 `isActive` 为 truthy[[1\\]](https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1) 时，HTML 将被渲染成为：\n\n```html\n<p class=\"foo bar active\">Hi</p>\n```\n\n\n\n### 绑定内联样式\n\n#### 对象语法\n\n```html\n\t\t<div id=\"div5\" v-bind:style=\"{color: activeColor, fontSize:fontSize + 'px'}\"> div5</div>\n\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel: '#div5',\n\t\t\t\tdata: {\n\t\t\t\t\tactiveColor: 'red',\n\t\t\t\t\tfontSize: 30\n\t\t\t\t}\n\n\t\t\t})\n\n```\n\n\n\n直接绑定到一个样式对象会让模板更清晰：\n\n```html\n\t\t<div id=\"div6\" v-bind:style=\"styleObject\"> div6</div>\n\n\n```\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel: '#div6',\n\t\t\t\tdata: {\n\t\t\t\t\tstyleObject:{\n\t\t\t\t\t\tcolor: 'red',\n\t\t\t\t\t\tfontSize: '30px'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\n```\n\n\n\n#### 数组语法\n\nv-bind:style的数组语法可以将多个样式对象应用到同一个元素上:\n\n#### 数组语法\n\n`v-bind:style` 的数组语法可以将多个样式对象应用到同一个元素上：\n\n```html\n<div v-bind:style=\"[baseStyles, overridingStyles]\"></div>\n\n```\n\n#### 自动添加前缀\n\n当 `v-bind:style` 使用需要添加浏览器引擎前缀的 CSS 属性时，如 `transform`，Vue.js 会自动侦测并添加相应的前缀。\n\n\n\n## 条件渲染\n\n#### v-if\n\n```html\n\t\t<div id=\"example\">\n\t\t\t<p v-if=\"greeting\">\n\t\t\t\tDirective1\n\t\t\t</p>\n\t\t\t<p v-else=\"greeting\">\n\t\t\t\tDirective2\n\t\t\t</p>\n\t\t</div>\n\n```\n\n\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel: '#example',\n\t\t\t\tdata: {\n\t\t\t\t\tgreeting: true\n\t\t\t\t}\n\t\t\t});\n\n```\n\nv-else必须要和v-if匹配使用，v-else不能单独使用。\n只有v-if的值为false时，v-else模块才会显示出来。\n\n因为 `v-if` 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 `<template>` 元素当做不可见的包裹元素，并在上面使用 `v-if`。最终的渲染结果将不包含 `<template>` 元素。\n\n#### 在template 元素上使用v-if 条件渲染分组\n\n```html\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n\n```\n\n\n\n#### v-else-if\n\n`v-else-if`，顾名思义，充当 `v-if` 的“else-if 块”，可以连续使用：\n\n```html\n<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else-if=\"type === 'C'\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n\n```\n\n\n\n#### 用key管理可复用的元素\n\nVue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：\n\n```html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\">\n</template>\n\n```\n\n\n\n添加一个具有唯一值的 `key` 属性,每次切换时，输入框都将被重新渲染。\n\n```html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\" key=\"username-input\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\" key=\"email-input\">\n</template>\n\n```\n\n#### v-show\n\n`v-show` 只是简单地切换元素的 CSS 属性 `display`。\n\n```html\n<h1 v-show=\"ok\">Hello!</h1>\n\n```\n\n v-if 和v-show区别\n\n`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\n\n\n\n\n\n\n\n\n\n","tags":["vue.js"]},{"title":"vue学习笔记(一)","url":"/2019/04/18/vue学习笔记-一/","content":"\nVue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与[现代化的工具链](https://cn.vuejs.org/v2/guide/single-file-components.html)以及各种[支持类库](https://github.com/vuejs/awesome-vue#libraries--plugins)结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 引入vue\n\n可以通过如下方式引入vue\n\n<!-- 开发环境版本，包含了有帮助的命令行警告 -->\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n\n或者\n\n<!-- 生产环境版本，优化了尺寸和速度 -->\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue\"></script>\n\n或者去\n\n[vue git仓库]: https://github.com/vuejs/vue\n\n下载vue.js文件本地引入\n\n\n\n## vue的使用:\n\n### 创建vue实例:\n\n```js\n\t\tvar vm = new Vue({\n\t\t\tel: '#app',\n\t\t\tdata: {\n\t\t\t\tmessage: 'hello Vue.js'\n\t\t\t}\n\t\t})\n```\n对应的html的id为app的div:\n\n```html\n        <div id=\"app\">\n            <p>{{message}}</p>  \n        </div>\n```\n当运行时,message会被替换为data中的 message的值 'hello Vue.js' ,值得注意的是使用双大括号会把值解析为纯文本,所以即使Vue的定义为:\n\n```javascript\n\tvar vm = new Vue({\n\t\tel: '#app',\n\t\tdata: {\n\t\t\tmessage: '<h1>标题</h1>'\n\t\t}\n\t})\n```\nmessage的值也会被解析为<h1>标题</h1> 文本,而不会被解析为html的格式\n\n### 数据与方法:\n\n当一个 Vue 实例被创建时，它将 `data` 对象中的所有的属性加入到 Vue 的**响应式系统**中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。\n\n\t\t<div id=\"app1\">\n\t\t\t{{data}}\n\t\t</div>\n\n\n```html\n\t<script>\n\t\tvar data = \"1\"\n\t\tvar vm = new Vue({\n\t\t\tel: '#app1',\n\t\t\tdata: data\n\t\t})\n\t</script>\n```\n在上述代码中,我们在js控制台中无论改变data的值或者vm.data的值,两者都会一起改变.值得注意的是只有当实例被创建时 `data` 中存在的属性才是**响应式**的。也就是说如果你添加一个新的属性，比如： vm.b = 'hi'那么对 `b` 的改动将不会触发任何视图的更新。\n\n除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 `$`，以便与用户定义的属性区分开来。例如：\n\n```js\nvar data = { a: 1 }\nvar vm = new Vue({\n  el: '#example',\n  data: data\n})\n\nvm.$data === data // => true\nvm.$el === document.getElementById('example') // => true\n\n// $watch 是一个实例方法\nvm.$watch('a', function (newValue, oldValue) {\n  // 这个回调将在 `vm.a` 改变后调用\n})\n```\n\n### 生命周期钩子:\n\n例如create 可以用来在一个实例被创建之后执行代码,：\n\n```js\nnew Vue({\n  data: {\n    a: 1\n  },\n  created: function () {\n    // `this` 指向 vm 实例\n    console.log('a is: ' + this.a)\n  }\n})\n```\n\n\n\n| 钩子          |                                                              |\n| ------------- | ------------------------------------------------------------ |\n| beforeCreate  | 创建实例之前执行                                             |\n| created       | 实例创建完成后执行                                           |\n| beforeMount   | 将编译完成的HTML挂载到对应虚拟dom时触发的钩子,此时页面并没有内容 |\n| mounted       | 将编译完成的HTML挂载到页面完成后执行的钩子,此时钩子函数中一般会做一些ajax请求获取数据进行数据初始化,mounted在整个实例中只执行一次 |\n| beforeUpdate  | 实时监控数据变化并随之更新DOM                                |\n| updated       | 更新之后的钩子                                               |\n| beforeDestroy | 实例销毁之前执行的钩子                                       |\n| destroyed     | 实例销毁完成执行的钩子                                       |\n\n### 使用JavaScript表达式:\n\n对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。\n\n```js\n{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div v-bind:id=\"'list-' + id\"></div>\n```\n\n这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含**单个表达式**，所以下面的例子都**不会**生效。\n\n```html\n<!-- 这是语句，不是表达式 -->\n{{ var a = 1 }}\n\n<!-- 流控制也不会生效，请使用三元表达式 -->\n{{ if (ok) { return message } }}\n\n```\n\n### 指令:\n\n指令 (Directives) 是带有 `v-` 前缀的特殊特性。指令特性的值预期是**单个 JavaScript 表达式** (`v-for` 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。\n\n```html\n\t\t<div id=\"app2\">\n\t\t\t<span v-bind:title=\"message\">\n\t\t\t\t鼠标悬停几秒钟查看此处动态绑定的提示信息;\n\t\t\t</span>\n\n\t\t</div>\t\t\n\n\t\t<div id=\"app3\">\n\t\t\t<p v-if=\"seen\">现在你看到我了</p>\n\t\t</div>\n\n\t\t<div id=\"app4\">\n\t\t\t<ol>\n\t\t\t\t<li v-for=\"todo in todos\">\n\t\t\t\t\t{{todo.text}}\n\t\t\t\t</li>\n\t\t\t</ol>\n\t\t</div>\n\n\t\t<div id=\"app5\">\n\t\t\t<p>\n\t\t\t\t{{message}}\n\t\t\t</p>\n\t\t\t<button v-on:click=\"reverseMessage\"> 逆转消息</button>\n\t\t</div>\n\n```\n\n\n\n```js\n\t\tvar app2 = new Vue({\n\t\t\tel: '#app2',\n\t\t\tdata: {\n\t\t\t\tmessage: '页面加载于' + new Date().toLocaleDateString()\n\t\t\t}\n\t\t})\t\n        \n\t\tvar app3 = new Vue({\n\t\t\tel: '#app3',\n\t\t\tdata: {\n\t\t\t\tseen: true\n\t\t\t}\n\t\t})\n\n\n\t\tvar app4 = new Vue({\n\t\t\tel: '#app4',\n\t\t\tdata: {\n\t\t\t\ttodos: [{\n\t\t\t\t\t\ttext: '学习javascript'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttext: '学习vue'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttext: '整个牛项目'\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t})\n\n\n\t\tvar app5 = new Vue({\n\t\t\tel: '#app5',\n\t\t\tdata: {\n\t\t\t\tmessage: 'Hello Vue.js'\n\t\t\t},\n\t\t\tmethods: {\n\t\t\t\treverseMessage: function() {\n\t\t\t\t\tthis.message = this.message.split('').reverse().join('')\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n```\n\n\n\n在app2,app3,app4.app5中分别实现了绑定鼠标事件,if判断,for循环,函数功能\n\n### 动态参数:\n\n```html\n\t\t<a id = \"a1\" v-bind:[url]=\"url\"> ... </a>\t<br>\n\t\t<a id = \"a2\" v-on:[name]=\"doSomething\"> ... </a>\n\n```\n\n\n\n```js\n\t\t\tnew Vue({\n\t\t\t\tel:'#a1',\n\t\t\t\tdata:{\n\t\t\t\t\turl:'href'\n\t\t\t\t}\n\t\t\t})\t\t\t\t\n\n\t\t\tnew Vue({\n\t\t\t\tel:'#a2',\n\t\t\t\tdata:{\n\t\t\t\t\tname:'dblclick'\n\t\t\t\t},\n\t\t\t\tmethods:{\n\t\t\t\t\tdoSomething : function (){\n\t\t\t\t\t\talert(\"函数执行\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t\n\t\t\t\n```\n\n从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：\n\na1 中 v-bind:[url] ,中括号内的url会被替换为Vue中定义的url值:href\n\na2中v-on:[name],中括号内的name会被替换为Vue中定义的name值:dblclick\n\n","tags":["vue.js"]},{"title":"org.springframework.expression.spel.SpelEvaluationException: EL1008E:","url":"/2019/04/15/org-springframework-expression-spel-SpelEvaluationException-EL1008E/","content":"\n今天发生了一个很诡异的事情,在进行thymeleaf进行前端视图显示的时候总是出现SpelEvaluationException异常.刚开始以为自己的属性名字填错了,经过反复确认发现没填错.后来考虑是不是get方法的问题.去类里一看,果真是get方法出了问题.\n\n\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n正确的get方法是\n\n```java\n    public Long getDid() {\n        return did;\n    }\n```\n\n然而我的get方法是从原来改的,当时为了省劲就直接把名字改了改,直接输入了did,导致在使用${dept.did}时找不到did属性\n\n```java\n    public Long getdid() {\n        return did;\n    }\n```\n\n\n\n\n\n## 错误信息:\n\n```java\n\n\norg.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field 'did' cannot be found on object of type 'com.caicai.aidangjian.entity.Department' - maybe not public or not valid?\n\tat org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:217) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:51) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:406) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:90) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:109) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:328) ~[spring-expression-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:263) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:144) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.OpenElementTag.beHandled(OpenElementTag.java:205) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.Model.process(Model.java:290) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.IteratedGatheringModelProcessable.processIterationModel(IteratedGatheringModelProcessable.java:367) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.IteratedGatheringModelProcessable.process(IteratedGatheringModelProcessable.java:221) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.ProcessorTemplateHandler.handleCloseElement(ProcessorTemplateHandler.java:1640) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleCloseElementEnd(TemplateHandlerAdapterMarkupHandler.java:388) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleCloseElementEnd(InlinedOutputExpressionMarkupHandler.java:322) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleCloseElementEnd(OutputExpressionInlinePreProcessorHandler.java:220) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleCloseElementEnd(InlinedOutputExpressionMarkupHandler.java:164) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.attoparser.HtmlElement.handleCloseElementEnd(HtmlElement.java:169) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.HtmlMarkupHandler.handleCloseElementEnd(HtmlMarkupHandler.java:412) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.MarkupEventProcessorHandler.handleCloseElementEnd(MarkupEventProcessorHandler.java:473) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.ParsingElementMarkupUtil.parseCloseElement(ParsingElementMarkupUtil.java:201) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:725) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\n\tat org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1370) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1116) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1055) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_201]\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_201]\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_201]\n```\n\n\n\n## \n\n\n\n","tags":["Spring Boot"]},{"title":"JPA Space is not allowed after parameter prefix ':'","url":"/2019/04/14/JPA-Space-is-not-allowed-after-parameter-prefix/","content":"\n查询时候想根据分数排序并且添加对应的名词序号,所以mysql语句中出现了(@i:=@i+1),在navicat下可以正常的运行.但是在使用@Query时出现'JPA Space is not allowed after parameter prefix '':'''错误;\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n@Query注解如下:\n\n```java\n    @Query(value = \"select (@i:=@i+1)pm from record s,(select @i:=0)t  order by score desc;\",nativeQuery = true)\n\n```\n\n\n\n去查资料,解决方案是把:转义 变成//:\n\n\n\n```java\n@Query(value = \"select (@i\\\\:=@i+1)pm from record s,(select @i\\\\:=0)t  order by score desc;\",nativeQuery = true)\n```","tags":["Spring Boot","JPA"]},{"title":"Echarts","url":"/2019/04/13/Echarts/","content":"\nECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的矢量图形库 [ZRender](https://github.com/ecomfe/zrender)，提供直观，交互丰富，可高度个性化定制的数据可视化图表。\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 引入Echarts.js文件\n\n> Echarts.js文件可以到\n>\n> [echarts官网](<https://echarts.baidu.com/>)下载\n>\n> ```html\n> <script src=\"echarts.min.js\"></script>\n> ```\n>\n> \n\n## 准备一个存放图表的容器\n\n```html\n<div id=\"box\" style=\"width: 600px;height:400px;\"></div>\n```\n\n\n\n## 设置参数 初始化图表\n\n```html\n\t<script>\n    var myChart = echarts.init(document.getElementById(\"box\"));\n\tvar option = {\n\t\ttitle : {\n\t\t\ttext: '未来一周气温变化',\n\t\t\tsubtext: '纯属虚构'\n\t\t},\n\t\ttooltip : {\n\t\t\ttrigger: 'axis'\n\t\t},\n\t\tlegend: {\n\t\t\tdata:['最高气温','最低气温']\n\t\t},\n\t\ttoolbox: {\n\t\t\tshow : true,\n\t\t\tfeature : {\n\t\t\t\tmark : {show: true},\n\t\t\t\tdataView : {show: true, readOnly: false},\n\t\t\t\tmagicType : {show: true, type: ['line', 'bar']},\n\t\t\t\trestore : {show: true},\n\t\t\t\tsaveAsImage : {show: true}\n\t\t\t}\n\t\t},\n\t\tcalculable : true,\n\t\txAxis : [\n\t\t\t{\n\t\t\t\ttype : 'category',\n\t\t\t\tboundaryGap : false,\n\t\t\t\tdata : ['周一','周二','周三','周四','周五','周六','周日']\n\t\t\t}\n\t\t],\n\t\tyAxis : [\n\t\t\t{\n\t\t\t\ttype : 'value',\n\t\t\t\taxisLabel : {\n\t\t\t\t\tformatter: '{value} °C'\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\tseries : [\n\t\t\t{\n\t\t\t\tname:'最高气温',\n\t\t\t\ttype:'line',\n\t\t\t\tdata:[11, 11, 15, 13, 12, 13, 10],\n\t\t\t\tmarkPoint : {\n\t\t\t\t\tdata : [\n\t\t\t\t\t\t{type : 'max', name: '最大值'},\n\t\t\t\t\t\t{type : 'min', name: '最小值'}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tmarkLine : {\n\t\t\t\t\tdata : [\n\t\t\t\t\t\t{type : 'average', name: '平均值'}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:'最低气温',\n\t\t\t\ttype:'line',\n\t\t\t\tdata:[1, -2, 2, 5, 3, 2, 0],\n\t\t\t\tmarkPoint : {\n\t\t\t\t\tdata : [\n\t\t\t\t\t\t{name : '周最低', value : -2, xAxis: 1, yAxis: -1.5}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tmarkLine : {\n\t\t\t\t\tdata : [\n\t\t\t\t\t\t{type : 'average', name : '平均值'}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t};\n    myChart.setOption(option);\n</script>\n```\n\n## 效果图\n\n![](/Echarts-初体验/1.png)\n\n​\t\t\t\n\n\n\n![](Echarts-初体验\\2.png)\n\n## 各个配置参数的说明\n\n```java\ntheme = {\n    // 全图默认背景\n    // backgroundColor: 'rgba(0,0,0,0)',\n\n    // 默认色板\n    color: ['#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed',\n            '#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0',\n            '#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700',\n            '#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'],\n\n    // 图表标题\n    title: {\n        x: 'left',                 // 水平安放位置，默认为左对齐，可选为：\n                                   // 'center' ¦ 'left' ¦ 'right'\n                                   // ¦ {number}（x坐标，单位px）\n        y: 'top',                  // 垂直安放位置，默认为全图顶端，可选为：\n                                   // 'top' ¦ 'bottom' ¦ 'center'\n                                   // ¦ {number}（y坐标，单位px）\n        //textAlign: null          // 水平对齐方式，默认根据x设置自动调整\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',       // 标题边框颜色\n        borderWidth: 0,            // 标题边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 标题内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        itemGap: 10,               // 主副标题纵向间隔，单位px，默认为10，\n        textStyle: {\n            fontSize: 18,\n            fontWeight: 'bolder',\n            color: '#333'          // 主标题文字颜色\n        },\n        subtextStyle: {\n            color: '#aaa'          // 副标题文字颜色\n        }\n    },\n\n    // 图例\n    legend: {\n        orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：\n                                   // 'horizontal' ¦ 'vertical'\n        x: 'center',               // 水平安放位置，默认为全图居中，可选为：\n                                   // 'center' ¦ 'left' ¦ 'right'\n                                   // ¦ {number}（x坐标，单位px）\n        y: 'top',                  // 垂直安放位置，默认为全图顶端，可选为：\n                                   // 'top' ¦ 'bottom' ¦ 'center'\n                                   // ¦ {number}（y坐标，单位px）\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',       // 图例边框颜色\n        borderWidth: 0,            // 图例边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 图例内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，\n                                   // 横向布局时为水平间隔，纵向布局时为纵向间隔\n        itemWidth: 20,             // 图例图形宽度\n        itemHeight: 14,            // 图例图形高度\n        textStyle: {\n            color: '#333'          // 图例文字颜色\n        }\n    },\n\n    // 值域\n    dataRange: {\n        orient: 'vertical',        // 布局方式，默认为垂直布局，可选为：\n                                   // 'horizontal' ¦ 'vertical'\n        x: 'left',                 // 水平安放位置，默认为全图左对齐，可选为：\n                                   // 'center' ¦ 'left' ¦ 'right'\n                                   // ¦ {number}（x坐标，单位px）\n        y: 'bottom',               // 垂直安放位置，默认为全图底部，可选为：\n                                   // 'top' ¦ 'bottom' ¦ 'center'\n                                   // ¦ {number}（y坐标，单位px）\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',       // 值域边框颜色\n        borderWidth: 0,            // 值域边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 值域内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，\n                                   // 横向布局时为水平间隔，纵向布局时为纵向间隔\n        itemWidth: 20,             // 值域图形宽度，线性渐变水平布局宽度为该值 * 10\n        itemHeight: 14,            // 值域图形高度，线性渐变垂直布局高度为该值 * 10\n        splitNumber: 5,            // 分割段数，默认为5，为0时为线性渐变\n        color:['#1e90ff','#f0ffff'],//颜色 \n        //text:['高','低'],         // 文本，默认为数值文本\n        textStyle: {\n            color: '#333'          // 值域文字颜色\n        }\n    },\n\n    toolbox: {\n        orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：\n                                   // 'horizontal' ¦ 'vertical'\n        x: 'right',                // 水平安放位置，默认为全图右对齐，可选为：\n                                   // 'center' ¦ 'left' ¦ 'right'\n                                   // ¦ {number}（x坐标，单位px）\n        y: 'top',                  // 垂直安放位置，默认为全图顶端，可选为：\n                                   // 'top' ¦ 'bottom' ¦ 'center'\n                                   // ¦ {number}（y坐标，单位px）\n        color : ['#1e90ff','#22bb22','#4b0082','#d2691e'],\n        backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色\n        borderColor: '#ccc',       // 工具箱边框颜色\n        borderWidth: 0,            // 工具箱边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 工具箱内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，\n                                   // 横向布局时为水平间隔，纵向布局时为纵向间隔\n        itemSize: 16,              // 工具箱图形宽度\n        featureImageIcon : {},     // 自定义图片icon\n        featureTitle : {\n            mark : '辅助线开关',\n            markUndo : '删除辅助线',\n            markClear : '清空辅助线',\n            dataZoom : '区域缩放',\n            dataZoomReset : '区域缩放后退',\n            dataView : '数据视图',\n            lineChart : '折线图切换',\n            barChart : '柱形图切换',\n            restore : '还原',\n            saveAsImage : '保存为图片'\n        }\n    },\n\n    // 提示框\n    tooltip: {\n        trigger: 'item',           // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'\n        showDelay: 20,             // 显示延迟，添加显示延迟可以避免频繁切换，单位ms\n        hideDelay: 100,            // 隐藏延迟，单位ms\n        transitionDuration : 0.4,  // 动画变换时间，单位s\n        backgroundColor: 'rgba(0,0,0,0.7)',     // 提示背景颜色，默认为透明度为0.7的黑色\n        borderColor: '#333',       // 提示边框颜色\n        borderRadius: 4,           // 提示边框圆角，单位px，默认为4\n        borderWidth: 0,            // 提示边框线宽，单位px，默认为0（无边框）\n        padding: 5,                // 提示内边距，单位px，默认各方向内边距为5，\n                                   // 接受数组分别设定上右下左边距，同css\n        axisPointer : {            // 坐标轴指示器，坐标轴触发有效\n            type : 'line',         // 默认为直线，可选为：'line' | 'shadow'\n            lineStyle : {          // 直线指示器样式设置\n                color: '#48b',\n                width: 2,\n                type: 'solid'\n            },\n            shadowStyle : {                       // 阴影指示器样式设置\n                width: 'auto',                   // 阴影大小\n                color: 'rgba(150,150,150,0.3)'  // 阴影颜色\n            }\n        },\n        textStyle: {\n            color: '#fff'\n        }\n    },\n\n    // 区域缩放控制器\n    dataZoom: {\n        orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：\n                                   // 'horizontal' ¦ 'vertical'\n        // x: {number},            // 水平安放位置，默认为根据grid参数适配，可选为：\n                                   // {number}（x坐标，单位px）\n        // y: {number},            // 垂直安放位置，默认为根据grid参数适配，可选为：\n                                   // {number}（y坐标，单位px）\n        // width: {number},        // 指定宽度，横向布局时默认为根据grid参数适配\n        // height: {number},       // 指定高度，纵向布局时默认为根据grid参数适配\n        backgroundColor: 'rgba(0,0,0,0)',       // 背景颜色\n        dataBackgroundColor: '#eee',            // 数据背景颜色\n        fillerColor: 'rgba(144,197,237,0.2)',   // 填充颜色\n        handleColor: 'rgba(70,130,180,0.8)'     // 手柄颜色\n    },\n\n    // 网格\n    grid: {\n        x: 80,\n        y: 60,\n        x2: 80,\n        y2: 60,\n        // width: {totalWidth} - x - x2,\n        // height: {totalHeight} - y - y2,\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderWidth: 1,\n        borderColor: '#ccc'\n    },\n\n    // 类目轴\n    categoryAxis: {\n        position: 'bottom',    // 位置\n        nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'\n        boundaryGap: true,     // 类目起始和结束两端空白策略\n        axisLine: {            // 坐标轴线\n            show: true,        // 默认显示，属性show控制显示与否\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#48b',\n                width: 2,\n                type: 'solid'\n            }\n        },\n        axisTick: {            // 坐标轴小标记\n            show: true,       // 属性show控制显示与否，默认不显示\n            interval: 'auto',\n            // onGap: null,\n            inside : false,    // 控制小标记是否在grid里 \n            length :5,         // 属性length控制线长\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#333',\n                width: 1\n            }\n        },\n        axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel\n            show: true,\n            interval: 'auto',\n            rotate: 0,\n            margin: 8,\n            // formatter: null,\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                color: '#333'\n            }\n        },\n        splitLine: {           // 分隔线\n            show: true,        // 默认显示，属性show控制显示与否\n            // onGap: null,\n            lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        splitArea: {           // 分隔区域\n            show: false,       // 默认不显示，属性show控制显示与否\n            // onGap: null,\n            areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    },\n\n    // 数值型坐标轴默认参数\n    valueAxis: {\n        position: 'left',      // 位置\n        nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'\n        nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式\n        boundaryGap: [0, 0],   // 数值起始和结束两端空白策略\n        splitNumber: 5,        // 分割段数，默认为5\n        axisLine: {            // 坐标轴线\n            show: true,        // 默认显示，属性show控制显示与否\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#48b',\n                width: 2,\n                type: 'solid'\n            }\n        },\n        axisTick: {            // 坐标轴小标记\n            show: false,       // 属性show控制显示与否，默认不显示\n            inside : false,    // 控制小标记是否在grid里 \n            length :5,         // 属性length控制线长\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#333',\n                width: 1\n            }\n        },\n        axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel\n            show: true,\n            rotate: 0,\n            margin: 8,\n            // formatter: null,\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                color: '#333'\n            }\n        },\n        splitLine: {           // 分隔线\n            show: true,        // 默认显示，属性show控制显示与否\n            lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        splitArea: {           // 分隔区域\n            show: false,       // 默认不显示，属性show控制显示与否\n            areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    },\n\n    polar : {\n        center : ['50%', '50%'],    // 默认全局居中\n        radius : '75%',\n        startAngle : 90,\n        splitNumber : 5,\n        name : {\n            show: true,\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                color: '#333'\n            }\n        },\n        axisLine: {            // 坐标轴线\n            show: true,        // 默认显示，属性show控制显示与否\n            lineStyle: {       // 属性lineStyle控制线条样式\n                color: '#ccc',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel\n            show: false,\n            textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                color: '#333'\n            }\n        },\n        splitArea : {\n            show : true,\n            areaStyle : {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        },\n        splitLine : {\n            show : true,\n            lineStyle : {\n                width : 1,\n                color : '#ccc'\n            }\n        }\n    },\n\n    // 柱形图默认参数\n    bar: {\n        barMinHeight: 0,          // 最小高度改为0\n        // barWidth: null,        // 默认自适应\n        barGap: '30%',            // 柱间距离，默认为柱形宽度的30%，可设固定值\n        barCategoryGap : '20%',   // 类目间柱形距离，默认为类目间距的20%，可设固定值\n        itemStyle: {\n            normal: {\n                // color: '各异',\n                barBorderColor: '#fff',       // 柱条边线\n                barBorderRadius: 0,           // 柱条边线圆角，单位px，默认为0\n                barBorderWidth: 1,            // 柱条边线线宽，单位px，默认为1\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            },\n            emphasis: {\n                // color: '各异',\n                barBorderColor: 'rgba(0,0,0,0)',   // 柱条边线\n                barBorderRadius: 0,                // 柱条边线圆角，单位px，默认为0\n                barBorderWidth: 1,                 // 柱条边线线宽，单位px，默认为1\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            }\n        }\n    },\n\n    // 折线图默认参数\n    line: {\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                lineStyle: {\n                    width: 2,\n                    type: 'solid',\n                    shadowColor : 'rgba(0,0,0,0)', //默认透明\n                    shadowBlur: 5,\n                    shadowOffsetX: 3,\n                    shadowOffsetY: 3\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            }\n        },\n        //smooth : false,\n        //symbol: null,         // 拐点图形类型\n        symbolSize: 2,          // 拐点图形大小\n        //symbolRotate : null,  // 拐点图形旋转控制\n        showAllSymbol: false    // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\n    },\n\n    // K线图默认参数\n    k: {\n        // barWidth : null          // 默认自适应\n        // barMaxWidth : null       // 默认自适应 \n        itemStyle: {\n            normal: {\n                color: '#fff',          // 阳线填充颜色\n                color0: '#00aa11',      // 阴线填充颜色\n                lineStyle: {\n                    width: 1,\n                    color: '#ff3200',   // 阳线边框颜色\n                    color0: '#00aa11'   // 阴线边框颜色\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                // color0: 各异\n            }\n        }\n    },\n\n    // 散点图默认参数\n    scatter: {\n        //symbol: null,      // 图形类型\n        symbolSize: 4,       // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\n        //symbolRotate : null,  // 图形旋转控制\n        large: false,        // 大规模散点图\n        largeThreshold: 2000,// 大规模阀值，large为true且数据量>largeThreshold才启用大规模模式\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            },\n            emphasis: {\n                // color: '各异'\n                label: {\n                    show: false\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            }\n        }\n    },\n\n    // 雷达图默认参数\n    radar : {\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                label: {\n                    show: false\n                },\n                lineStyle: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                label: {\n                    show: false\n                }\n            }\n        },\n        //symbol: null,         // 拐点图形类型\n        symbolSize: 2           // 可计算特性参数，空数据拖拽提示图形大小\n        //symbolRotate : null,  // 图形旋转控制\n    },\n\n    // 饼图默认参数\n    pie: {\n        center : ['50%', '50%'],    // 默认全局居中\n        radius : [0, '75%'],\n        clockWise : false,          // 默认逆时针\n        startAngle: 90,\n        minAngle: 0,                // 最小角度改为0\n        selectedOffset: 10,         // 选中是扇区偏移量\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                borderColor: '#fff',\n                borderWidth: 1,\n                label: {\n                    show: true,\n                    position: 'outer'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                labelLine: {\n                    show: true,\n                    length: 20,\n                    lineStyle: {\n                        // color: 各异,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                borderColor: 'rgba(0,0,0,0)',\n                borderWidth: 1,\n                label: {\n                    show: false\n                    // position: 'outer'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                labelLine: {\n                    show: false,\n                    length: 20,\n                    lineStyle: {\n                        // color: 各异,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            }\n        }\n    },\n\n    map: {\n        mapType: 'china',   // 各省的mapType暂时都用中文\n        mapLocation: {\n            x : 'center',\n            y : 'center'\n            // width    // 自适应\n            // height   // 自适应\n        },\n        showLegendSymbol : true,       // 显示图例颜色标识（系列标识的小圆点），存在legend时生效\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                borderColor: '#fff',\n                borderWidth: 1,\n                areaStyle: {\n                    color: '#ccc'//rgba(135,206,250,0.8)\n                },\n                label: {\n                    show: false,\n                    textStyle: {\n                        color: 'rgba(139,69,19,1)'\n                    }\n                }\n            },\n            emphasis: {                 // 也是选中样式\n                // color: 各异,\n                borderColor: 'rgba(0,0,0,0)',\n                borderWidth: 1,\n                areaStyle: {\n                    color: 'rgba(255,215,0,0.8)'\n                },\n                label: {\n                    show: false,\n                    textStyle: {\n                        color: 'rgba(139,69,19,1)'\n                    }\n                }\n            }\n        }\n    },\n\n    force : {\n        // 数据map到圆的半径的最小值和最大值\n        minRadius : 10,\n        maxRadius : 20,\n        density : 1.0,\n        attractiveness : 1.0,\n        // 初始化的随机大小位置\n        initSize : 300,\n        // 向心力因子，越大向心力越大\n        centripetal : 1,\n        // 冷却因子\n        coolDown : 0.99,\n        // 分类里如果有样式会覆盖节点默认样式\n        itemStyle: {\n            normal: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                nodeStyle : {\n                    brushType : 'both',\n                    color : '#f08c2e',\n                    strokeColor : '#5182ab'\n                },\n                linkStyle : {\n                    strokeColor : '#5182ab'\n                }\n            },\n            emphasis: {\n                // color: 各异,\n                label: {\n                    show: false\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                nodeStyle : {},\n                linkStyle : {}\n            }\n        }\n    },\n\n    chord : {\n        radius : ['65%', '75%'],\n        center : ['50%', '50%'],\n        padding : 2,\n        sort : 'none', // can be 'none', 'ascending', 'descending'\n        sortSub : 'none', // can be 'none', 'ascending', 'descending'\n        startAngle : 90,\n        clockWise : false,\n        showScale : false,\n        showScaleText : false,\n        itemStyle : {\n            normal : {\n                label : {\n                    show : true\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                lineStyle : {\n                    width : 0,\n                    color : '#000'\n                },\n                chordStyle : {\n                    lineStyle : {\n                        width : 1,\n                        color : '#666'\n                    }\n                }\n            },\n            emphasis : {\n                lineStyle : {\n                    width : 0,\n                    color : '#000'\n                },\n                chordStyle : {\n                    lineStyle : {\n                        width : 2,\n                        color : '#333'\n                    }\n                }\n            }\n        }\n    },\n\n    island: {\n        r: 15,\n        calculateStep: 0.1  // 滚轮可计算步长 0.1 = 10%\n    },\n\n    markPoint : {\n        symbol: 'pin',         // 标注类型\n        symbolSize: 10,        // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\n        //symbolRotate : null, // 标注旋转控制\n        itemStyle: {\n            normal: {\n                // color: 各异，\n                // borderColor: 各异,     // 标注边线颜色，优先于color \n                borderWidth: 2,            // 标注边线线宽，单位px，默认为1\n                label: {\n                    show: true,\n                    position: 'inside' // 可选为'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            },\n            emphasis: {\n                // color: 各异\n                label: {\n                    show: true\n                    // position: 'inside'  // 'left'|'right'|'top'|'bottom'\n                    // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE\n                }\n            }\n        }\n    },\n\n    markLine : {\n        // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string\n        symbol: ['circle', 'arrow'],  \n        // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\n        symbolSize: [2, 4],\n        // 标线起始和结束的symbol旋转控制\n        //symbolRotate : null,\n        itemStyle: {\n            normal: {\n                // color: 各异,           // 标线主色，线色，symbol主色\n                // borderColor: 随color,     // 标线symbol边框颜色，优先于color \n                borderWidth: 2,          // 标线symbol边框线宽，单位px，默认为2\n                label: {\n                    show: false,\n                    // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom'\n                    position: 'inside',  \n                    textStyle: {         // 默认使用全局文本样式，详见TEXTSTYLE\n                        color: '#333'\n                    }\n                },\n                lineStyle: {\n                    // color: 随borderColor, // 主色，线色，优先级高于borderColor和color\n                    // width: 随borderWidth, // 优先于borderWidth\n                    type: 'solid',\n                    shadowColor : 'rgba(0,0,0,0)', //默认透明\n                    shadowBlur: 5,\n                    shadowOffsetX: 3,\n                    shadowOffsetY: 3\n                }\n            },\n            emphasis: {\n                // color: 各异\n                label: {\n                    show: false\n                    // position: 'inside' // 'left'|'right'|'top'|'bottom'\n                    // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE\n                },\n                lineStyle : {}\n            }\n        }\n    },\n\n    textStyle: {\n        decoration: 'none',\n        fontFamily: 'Arial, Verdana, sans-serif',\n        fontFamily2: '微软雅黑',    // IE8- 字体模糊并且不支持不同字体混排，额外指定一份\n        fontSize: 12,\n        fontStyle: 'normal',\n        fontWeight: 'normal'\n    },\n\n    // 默认标志图形类型列表\n    symbolList : [\n      'circle', 'rectangle', 'triangle', 'diamond',\n      'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond'\n    ],\n    loadingText : 'Loading...',\n    // 可计算特性配置，孤岛，提示颜色\n    calculable: false,              // 默认关闭可计算特性\n    calculableColor: 'rgba(255,165,0,0.6)',       // 拖拽提示边框颜色\n    calculableHolderColor: '#ccc', // 可计算占位提示颜色\n    nameConnector: ' & ',\n    valueConnector: ' : ',\n    animation: true,\n    animationThreshold: 2500,       // 动画元素阀值，产生的图形原素超过2500不出动画\n    addDataAnimation: true,         // 动态数据接口是否开启动画效果\n    animationDuration: 2000,\n    animationEasing: 'ExponentialOut'    //BounceOut\n}\n\n```\n\n","tags":["Echarts"]},{"title":"Spring Boot 拦截器","url":"/2019/04/12/Spring-Boot-登录拦截器验证/","content":"\njava里的拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在AOP（Aspect-Oriented Programming）中拦截器用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## HandlerInterceptor 接口介绍:\n\n在HandlerInterceptor 中有三个方法:\n\n```java\ndefault boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    return true;\n}\n\ndefault void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {\n}\n\ndefault void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n}\n```\n\n**preHandle:** 预处理方法,实现处理器的预处理(例如登录状态),handler参数为相应的处理器,返回值:true表示继续流程,false表示流程中断,我们需要通过reponse来产生响应.\n\n**postHandle**：后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。\n\n**afterCompletion**：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。\n\n\n\n## 配置拦截器:\n\n### 创建拦截器类:\n\n```java\npackage caicai.springbootinterceptor1.interceptor;\n\nimport org.springframework.lang.Nullable;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * @author liu\n * @title: LoginInterceptor\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:31\n */\npublic class LoginInterceptor implements HandlerInterceptor{\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        System.out.println(\"preHandle.............................\");\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {\n        System.out.println(\"postHandle.............................\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n        System.out.println(\"afterCompletion.............................\");\n    }\n}\n```\n\n### 创建拦截器配置类:\n\n```java\npackage caicai.springbootinterceptor1.config;\n\nimport caicai.springbootinterceptor1.interceptor.LoginInterceptor;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n/**\n * @author liu\n * @title: LoginInterceptorConfig\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:33\n */\n@Configuration\npublic class LoginInterceptorConfig implements WebMvcConfigurer{\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/login\");\n\n    }\n}\n```\n\naddPathPatterns(\"/**\"):表示拦截所有的url请求;\n\nexcludePathPatterns(\"/login\"):表示排除login\n\n完成了拦截器配置后,在启动springboot项目的时候,除了login以外,其他所有的请求都会经过拦截器处理,我们可以使用preHandle来完成一个登录验证的功能\n\n\n\n## 登录验证实现:\n\n### 效果:\n\n1.有两个界面: 登录界面, 主界面\n\n2:登录界面和主界面都可以通过相应请求跳转到,但是主界面只有登录之后才能查看,否则就跳回登录界面\n\n项目目录:\n\n![](Spring-Boot-登录拦截器验证\\1.png)\n\n### \n\n### index.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<form action=\"/login\">\n    <span>用户名:</span> <input type=\"text\" name=\"username\">\n    <span>密码:</span>  <input type=\"text\" name=\"password\">\n    <button>提交</button>\n</form>\n</body>\n</html>\n```\n\n\n\n### main.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"><head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<h1>这里是主页面</h1>\n当前登录用户:<span th:text=\"${session.username}\"></span>\n</body>\n</html>\n```\n\n如果登录的话 ${session.username}会获取到存贮在session中的用户名\n\n\n\n\n\n### Logininterceptor.java\n\n```java\npackage caicai.springbootinterceptor1.interceptor;\n\nimport org.springframework.lang.Nullable;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * @author liu\n * @title: LoginInterceptor\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:31\n */\npublic class LoginInterceptor implements HandlerInterceptor{\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        /**\n        通过session中的用户名来判断是否登录,因为一旦登录了就会在session中存储用户名\n        **/\n        if(request.getSession().getAttribute(\"username\")!=null){\n            System.out.println(\"登录了\");\n            return true;\n        }else{\n            System.out.println(\"未登录\");\n            response.sendRedirect(request.getContextPath()+\"/index\");\n\n            return false;\n        }\n\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {\n        System.out.println(\"postHandle.............................\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n        System.out.println(\"afterCompletion.............................\");\n    }\n}\n```\n\n\n\n### LoginController\n\n```java\npackage caicai.springbootinterceptor1.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n * @author liu\n * @title: LoginController\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:22\n */\n@Controller\npublic class LoginController {\n\n    /**\n    登录界面的url映射\n    **/\n    @RequestMapping(\"/index\")\n    public String index(){\n        return \"index\";\n    }\n    /**\n    登录,此处直接用字符串是否是admin的方式来模拟数据库查询登录\n    若账号密码正确则跳转到main界面若账号密码错误则继续跳转到登录界面\n    **/\n    @RequestMapping(\"/login\")\n    public String login(String username, String password, HttpServletRequest request){\n        if (username.equals(\"admin\")&& password.equals(\"admin\")){\n            request.getSession().setAttribute(\"username\",username);\n            return \"main\";\n        }else {\n            return \"login\";\n        }\n    }\n    /**\n    主界面的url映射  为了测试不登陆直接进主页面被拦截\n    **/\n    @RequestMapping(\"/main\")\n    public String main(){\n        return \"main\";\n    }\n\n}\n```\n\n### LoginInterceptorConfig.java:\n\n配置文件,配置了拦截器和拦截路径\n\n```java\npackage caicai.springbootinterceptor1.config;\n\nimport caicai.springbootinterceptor1.interceptor.LoginInterceptor;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n/**\n * @author liu\n * @title: LoginInterceptorConfig\n * @projectName spring-boot-interceptor1\n * @description: TODO\n * @date 2019/4/1216:33\n */\n@Configuration\npublic class LoginInterceptorConfig implements WebMvcConfigurer{\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/login\").excludePathPatterns(\"/index\");\n\n    }\n}\n```\n\n\n\n本实例只是粗略的完成了登录拦截的功能,对于一些细节没有完善,例如错误提示等.","tags":["Spring Boot"]},{"title":"MYSQL随机选择数据","url":"/2019/04/10/MYSQL随机选择数据/","content":"\n最近在做一个在线考试系统,遇到需要随机选择20道选择题的需求.\n\n\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 使用ORDER BY RAND()选择随机记录\n\nMySQL没有内置语句来从数据库表中选择随机记录。为了实现这个目的，可使用`RAND`函数。 以下查询是从数据库表中选择N个随机记录：\n\n```mysql\nSELECT \n    *\nFROM\n    tbl\nORDER BY RAND()\nLIMIT N;\n```\n\n- `RAND（）`函数为表中的每一行生成一个随机值。 \n- [ORDER BY](http://www.studymysql.com/mysql/order-by.html)子句按照`RAND（）`函数生成的随机数对表中的所有行进行排序。 \n\n这种技术非常适合小表。如果在大的表上执行速度是非常缓慢的，因为MySQL必须排序整个表，以挑选随机的行数据。查询的速度还取决于表中的行数。表具有的行越多，MySQL都要为每行生成随机数，所以所需的时间就越多。\n\n\n\n","tags":["MYSQL"]},{"title":"Jpa 自定义查询语句","url":"/2019/04/10/jpa-自定义查询语句/","content":"\n在使用Spring Data Jpa框架时，根据业务需求我们通常需要进行复杂的数据库查询，并返回我们自定义的实体类，而在该框架下，目前仅仅支持返回与数据库映射进行持久化的POJO实体。虽然在框架上我们可以使用@Query注解执行我们自定义的sql语句，但是其返回值为List<Object[]> 类型，即多个Object数组的List集合。\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## @Query()注解\n\n通过使@query注解,可以自定义语句进行sql操作\n\n下例为在数据库中查询10个随机的选择题的自定义查询方法:\n\n```java\npublic interface MultipleChoiceRepository extends JpaRepository<MultipleChoice,Long> {\n    @Query(value = \"select * from choice ORDER BY RAND() limit :num\",nativeQuery = true)\n    public List<MultipleChoice> findByNmber(@Param(\"num\") Integer num);\n}\n```\n\n## 开启mysql语句\n\n```java\n  @Query(value = \"\",nativeQuery = true)  //nativeQuery= true开启mysql\n```\n\n## @Modefying()注解\n\n如果是删除或修改操作，需要加入此注解进行修饰. 以通知 SpringData， 这是一个 UPDATE 或 DELETE 操作 ；默认情况下，是只读，所以查询不需要\n\n# 参数传递:\n\n## @Param()注解\n\n使用@Param注解可以给查询语句中注入参数\n\n```java\n@Param(\"num\") Integer num\n```\n\n在sql语句中使用  :参数名    进行调用\n\n## 使用?占位符\n\n```java\npublic interface MultipleChoiceRepository extends JpaRepository<MultipleChoice,Long> {\n    @Query(value = \"select * from choice ORDER BY RAND() limit ?\",nativeQuery = true)\n\n    public List<MultipleChoice> findByNmber(Integer num);\n\n}\n```\n\nsql语句中也可以使用?占位符的方式进行参数写入","tags":["Spring Boot"]},{"title":"Spring Boot Jpa","url":"/2019/03/31/Spring-Boot-Jpa/","content":"\n  全称Java Persistence API，通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。\n\n​     JPA的出现有两个原因：\n 其一，简化现有Java EE和Java SE应用的对象持久化的开发工作；\n 其二，Sun希望整合对ORM技术，实现持久化领域的统一。\n\n​     JPA提供的技术：\n\n 1）ORM映射元数据：JPA支持XML和JDK 5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中；\n\n 2）JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。\n\n 3）查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## pom.xml中导入依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n   <modelVersion>4.0.0</modelVersion>\n   <parent>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-parent</artifactId>\n      <version>2.1.3.RELEASE</version>\n      <relativePath/> <!-- lookup parent from repository -->\n   </parent>\n   <groupId>com.caicai</groupId>\n   <artifactId>spring-boot-jpa</artifactId>\n   <version>0.0.1-SNAPSHOT</version>\n   <name>spring-boot-jpa</name>\n   <description>Demo project for Spring Boot</description>\n\n   <properties>\n      <java.version>1.8</java.version>\n   </properties>\n\n   <dependencies>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-data-jpa</artifactId>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-jdbc</artifactId>\n      </dependency>\n\n      <dependency>\n         <groupId>mysql</groupId>\n         <artifactId>mysql-connector-java</artifactId>\n         <scope>runtime</scope>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-test</artifactId>\n         <scope>test</scope>\n      </dependency>\n   </dependencies>\n\n   <build>\n      <plugins>\n         <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n         </plugin>\n      </plugins>\n   </build>\n\n</project>\n```\n\n## 创建实体类\n\n```java\npackage com.caicai.springbootjpa.entity;\n\nimport javax.persistence.*;\n\n/**\n * @author liu\n * @title: User\n * @projectName spring-boot-jpa\n * @description: TODO\n * @date 2019/3/3121:14\n */\n\n@Entity\npublic class User {\n    @GeneratedValue(strategy = GenerationType.AUTO)//设置自增长策略\n    @Id\n    private Integer id;\n    @Column(length = 20,nullable = false)  //column可以设置属性\n    private String name;\n    @Column(length = 20,nullable = true)\n    private Integer age;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public User() {\n    }\n\n    public User(String name, Integer age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n\n\n## 创建UserRepository\n\n```java\npackage com.caicai.springbootjpa.repository;\n\nimport com.caicai.springbootjpa.entity.User;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\n/**\n * @author liu\n * @title: UserRepository\n * @projectName spring-boot-jpa\n * @description: TODO\n * @date 2019/3/3121:06\n */\npublic interface UserRepository extends JpaRepository<User,Integer>{\n}\n\n```\n\n## 配置数据源和自动建表:\n\n```xml\nspring:\n  datasource:\n    username: root\n    password: 123456\n    url: jdbc:mysql://localhost:3306/jpa\n    driver-class-name: com.mysql.jdbc.Driver\n  jpa:\n    hibernate:\n      ddl-auto: update\n    show-sql: true\n```\n\n\n\n## 测试类:\n\n```java\npackage com.caicai.springbootjpa;\n\nimport com.caicai.springbootjpa.entity.User;\nimport com.caicai.springbootjpa.repository.UserRepository;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootJpaApplicationTests {\n    @Autowired\n    UserRepository userRepository;\n\t@Test\n\tpublic void test() {\n\t    User user = new User();\n\t    user.setAge(10);\n\t    user.setName(\"caicai\");\n\t    userRepository.save(user);\n\t}\n\n}\n```\n\n","tags":["Spring Boot"]},{"title":"Spring Boot 整合Mybatis(基于注解)","url":"/2019/03/31/Spring-Boot-整合Mybatis-基于注解/","content":"\n基于注解的Spring Boot 整合Mybatis\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 项目结构\n\n![](Spring-Boot-整合Mybatis-基于注解\\1.png)\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.1.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.caicai</groupId>\n\t<artifactId>spring-boot-mybatis-annotation</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>spring-boot-mybatis-annotation</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-jdbc</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.spring.boot</groupId>\n\t\t\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t\t\t<version>2.0.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>mysql</groupId>\n\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t\t<scope>runtime</scope>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n## UserMapper.java\n\n```java\npackage com.caicai.springbootmybatisannotation.mapper;\n\nimport com.caicai.springbootmybatisannotation.pojo.User;\nimport org.apache.ibatis.annotations.Insert;\nimport org.apache.ibatis.annotations.Mapper;\n\n/**\n * @author liu\n * @title: UserMapper\n * @projectName spring-boot-mybatis-annotation\n * @description: TODO\n * @date 2019/3/3120:16\n */\n@Mapper\npublic interface UserMapper {\n    @Insert(\"insert into users(name,age) values(#{name},#{age})\")\n    public void addUser(User user);\n\n}\n```\n\n\n\n## User.java\n\n```java\npackage com.caicai.springbootmybatisannotation.pojo;\n\n/**\n * @author liu\n * @title: User\n * @projectName spring-boot-mybatis-annotation\n * @description: TODO\n * @date 2019/3/3120:16\n */\npublic class User {\n    private Integer id;\n    private String name;\n    private Integer age;\n\n    public User() {\n    }\n\n    public User(Integer id, String name, Integer age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n```\n\n\n\n## application.yml\n\n```xml\nspring:\n  datasource:\n    password: 123456\n    username: root\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm\n```\n\n\n\n## SpringBootMybatisAnnotationApplicationTests.java\n\n```java\npackage com.caicai.springbootmybatisannotation;\n\nimport com.caicai.springbootmybatisannotation.mapper.UserMapper;\nimport com.caicai.springbootmybatisannotation.pojo.User;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootMybatisAnnotationApplicationTests {\n    @Autowired\n    UserMapper userMapper;\n   @Test\n    public void addUser(){\n        User user = new User();\n        user.setAge(10);\n        user.setName(\"caicai\");\n        userMapper.addUser(user);\n    }\n\n}\n```\n\n## 对比xml文件配置\n\n```java\n@Insert(\"insert into users(name,age) values(#{name},#{age})\")\npublic void addUser(User user);\n```\n\n@Insert注解的配置就相当于在UserMapper.xml中配置:","tags":["Spring Boot","Mybatis"]},{"title":"org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)异常处理","url":"/2019/03/31/org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found-异常处理/","content":"\n在SpringBoot整合Mybatis出现org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): 错误\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n## 报错信息:\n\n```java\norg.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.caicai.springbootspringmvcmybatis.mapper.UsersMapper.insertUser\n\tat org.apache.ibatis.binding.MapperMethod$SqlCommand.<init>(MapperMethod.java:232) ~[mybatis-3.5.0.jar:3.5.0]\n\tat org.apache.ibatis.binding.MapperMethod.<init>(MapperMethod.java:50) ~[mybatis-3.5.0.jar:3.5.0]\n\tat org.apache.ibatis.binding.MapperProxy.lambda$cachedMapperMethod$0(MapperProxy.java:62) ~[mybatis-3.5.0.jar:3.5.0]\n\tat java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1660) ~[na:1.8.0_201]\n\tat org.apache.ibatis.binding.MapperProxy.cachedMapperMethod(MapperProxy.java:62) ~[mybatis-3.5.0.jar:3.5.0]\n\tat org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:57) ~[mybatis-3.5.0.jar:3.5.0]\n\tat com.sun.proxy.$Proxy56.insertUser(Unknown Source) ~[na:na]\n\tat com.caicai.springbootspringmvcmybatis.service.UserServiceImpl.addUser(UserServiceImpl.java:23) ~[classes/:na]\n\tat com.caicai.springbootspringmvcmybatis.service.UserServiceImpl$$FastClassBySpringCGLIB$$3b4656c9.invoke(<generated>) ~[classes/:na]\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:294) ~[spring-tx-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98) ~[spring-tx-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ~[spring-aop-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat com.caicai.springbootspringmvcmybatis.service.UserServiceImpl$$EnhancerBySpringCGLIB$$c9ef3195.addUser(<generated>) ~[classes/:na]\n\tat com.caicai.springbootspringmvcmybatis.controller.UserController.addUser(UserController.java:30) ~[classes/:na]\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_201]\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_201]\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_201]\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_201]\n\tat org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:800) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:908) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:660) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200) ~[tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_201]\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_201]\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.16.jar:9.0.16]\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_201]\n```\n\n\n\n## 解决\n\n经过研究,发现UsersMapper.xml文件在com.caicai.springbootspringmvcmybatis.mapper包里不会被编译,所以考虑在resources里创建一个mapper文件夹,并且在application.yml配置mybatis\n\n```xml\nmybatis:\n  type-aliases-package: com.caicai.springbootspringmvcmybatis.pojo\n  mapper-locations: classpath:mapper/*.xml\n\n```\n\n","tags":["Spring Boot","Mybatis"]},{"title":"JDBC连接Mysql8.0驱动版本过低报错","url":"/2019/03/29/JDBC连接Mysql8-0-11版本出现问题/","content":"\nJDBC连接Mysql8.0.11版本出现问题,不停循环报错 错误信息如下:\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 报错信息:\n\n```java\nFri Mar 29 21:39:01 CST 2019 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.\nERROR [Druid-ConnectionPool-Create-2085079540] - create connection SQLException, url: jdbc:mysql://localhost:3306/phone, errorCode 0, state 08001\ncom.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server.\n\tat sun.reflect.GeneratedConstructorAccessor36.newInstance(Unknown Source)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat com.mysql.jdbc.Util.handleNewInstance(Util.java:404)\n\tat com.mysql.jdbc.Util.getInstance(Util.java:387)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:917)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:896)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:885)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:860)\n\tat com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2332)\n\tat com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2085)\n\tat com.mysql.jdbc.ConnectionImpl.<init>(ConnectionImpl.java:795)\n\tat com.mysql.jdbc.JDBC4Connection.<init>(JDBC4Connection.java:44)\n\tat sun.reflect.GeneratedConstructorAccessor27.newInstance(Unknown Source)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat com.mysql.jdbc.Util.handleNewInstance(Util.java:404)\n\tat com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:400)\n\tat com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:327)\n\tat com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1513)\n\tat com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1578)\n\tat com.alibaba.druid.pool.DruidDataSource$CreateConnectionThread.run(DruidDataSource.java:2451)\nCaused by: java.lang.NullPointerException\n\tat com.mysql.jdbc.ConnectionImpl.getServerCharset(ConnectionImpl.java:3005)\n\tat com.mysql.jdbc.MysqlIO.sendConnectionAttributes(MysqlIO.java:1916)\n\tat com.mysql.jdbc.MysqlIO.proceedHandshakeWithPluggableAuthentication(MysqlIO.java:1845)\n\tat com.mysql.jdbc.MysqlIO.doHandshake(MysqlIO.java:1215)\n\tat com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2255)\n\tat com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2286)\n\t... 12 more\n\n```\n\n\n\n## 解决方案:\n\nMysql是8.0版本的 ,但是项目中用的jdbc驱动包5.1.31,将jdbc驱动包改为8.0.13后不再报错","tags":["MYSQL"]},{"title":"Spring Boot 整合mybatis","url":"/2019/03/29/Spring-Boot-整合mybatis/","content":"\n Spring Boot 整合mybatis\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 创建项目   pom.xml中添加依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.1.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.caicai</groupId>\n\t<artifactId>12-spring-boot-springmvc-mybatis</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>12-spring-boot-springmvc-mybatis</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-thymeleaf</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.spring.boot</groupId>\n\t\t\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t\t\t<version>2.0.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>1.1.8</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n## 创建application.yml\n\n```xml\nspring:\n  datasource:\n    driver-class-name: com.mysql.jdbc.Driver\n    username: root\n    password: 123456\n    url: jdbc:mysql://localhost:3306/ssm\n    type: com.alibaba.druid.pool.DruidDataSource\nmybatis:\n  type-aliases-package: com.caicai.springbootspringmvcmybatis.pojo\n  mapper-locations: classpath:mapper/*.xml\n```\n\n## 创建Users类\n\n```java\npackage com.caicai.springbootspringmvcmybatis.pojo;\n\npublic class Users {\n\n    private Integer id;\n    private String name;\n    private Integer age;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n\n```\n\n\n\n## 创建Controller\n\n```java\npackage com.caicai.springbootspringmvcmybatis.controller;\n\nimport com.caicai.springbootspringmvcmybatis.pojo.Users;\nimport com.caicai.springbootspringmvcmybatis.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n/**\n * @author liu\n * @title: Controller\n * @projectName 12-spring-boot-springmvc-mybatis\n * @description: TODO\n * @date 2019/3/3113:01\n */\n@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n    @Autowired\n    private UserService userService;\n    @RequestMapping(\"/{page}\")\n    public String showPage(@PathVariable String page){\n        return page;\n    }\n    @RequestMapping(\"/addUser\")\n    @ResponseBody\n    public String addUser(Users user){\n        userService.addUser(user);\n        return \"success\";\n    }\n}\n\n```\n\n## 创建 UserMapper接口和UsersMapper.xml(创建路径在resources/mapper下)\n\n```\npackage com.caicai.springbootspringmvcmybatis.mapper;\n\n\nimport com.caicai.springbootspringmvcmybatis.pojo.Users;\n\npublic interface UsersMapper {\n\t\n\tvoid insertUser(Users users);\n}\n\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\nPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.caicai.springbootspringmvcmybatis.mapper.UsersMapper\">\n\t<insert id=\"insertUser\" parameterType=\"users\">\n\t\tinsert into users(name,age) values(#{name},#{age})\n\t</insert>\n</mapper>\n```\n\n## 创建Service\n\n```java\npackage com.caicai.springbootspringmvcmybatis.service;\n\nimport com.caicai.springbootspringmvcmybatis.pojo.Users;\n\n/**\n * @author liu\n * @title: UserService\n * @projectName 12-spring-boot-springmvc-mybatis\n * @description: TODO\n * @date 2019/3/3112:16\n */\npublic interface UserService {\n    void addUser(Users users);\n}\n\n```\n\n```java\npackage com.caicai.springbootspringmvcmybatis.service;\n\nimport com.caicai.springbootspringmvcmybatis.mapper.UsersMapper;\nimport com.caicai.springbootspringmvcmybatis.pojo.Users;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n/**\n * @author liu\n * @title: UserServiceImpl\n * @projectName 12-spring-boot-springmvc-mybatis\n * @description: TODO\n * @date 2019/3/3112:25\n */\n@Service\n@Transactional\npublic class UserServiceImpl implements  UserService{\n    @Autowired\n    private UsersMapper usersMapper;\n    @Override\n    public void addUser(Users users) {\n        this.usersMapper.insertUser(users);\n    }\n}\n\n```\n\n## 创建page.html\n\n```html\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<form th:action=\"@{/users/addUser}\" method=\"post\">\n用户姓名<input type=\"text\" name=\"name\"><br>\n用户年龄<input type=\"text\" name=\"age\"><br>\n<input type=\"submit\" th:value=\"确定\"><br>\n\n</form>\n\n</body>\n</html>\n```\n\n## 创建启动类:\n\n```java\npackage com.caicai.springbootspringmvcmybatis;\n\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n@MapperScan(\"com.caicai.springbootspringmvcmybatis.mapper\")\npublic class Application {\n\n   public static void main(String[] args) {\n      SpringApplication.run(Application.class, args);\n   }\n\n}\n```\n\n\n\n\n\n","tags":["Spring Boot","Mybatis"]},{"title":"thymeleaf的整合和使用","url":"/2019/03/29/thymeleaf基本语法/","content":"\nThymeleaf是用于Web和独立环境的现代服务器端Java模板引擎。Thymeleaf的主要目标是将优雅的自然模板带到您的开发工作流程中—HTML能够在浏览器中正确显示，并且可以作为静态原型，从而在开发团队中实现更强大的协作。Thymeleaf能够处理HTML，XML，JavaScript，CSS甚至纯文本。\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 整合thymeleaf\n\n## 修改pom.xml文件,添加依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.1.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.caicai</groupId>\n\t<artifactId>10-spring-boot-view-thymeleaf</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>10-spring-boot-view-thymeleaf</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-thymeleaf</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n## 编写视图:\n\n在templates/ 下建立 userList2.html:\n\n```html\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\">\n<head>\n    <title>index</title>\n</head>\n<body>\n<table border=\"1\" align=\"center\" width=\"50%\">\n    <tr>\n        <th>ID</th>\n        <th>Name</th>\n        <th>Age</th>\n    </tr>\n\n    <tr th:each=\"user:${list}\">\n        <td th:text=\"${user.userid}\"></td>\n        <td th:text=\"${user.username}\"></td>\n        <td th:text=\"${user.userage}\"></td>\n    </tr>\n\n</table>\n</body>\n</html>\n```\n\n## 创建Controller\n\n```java\npackage com.caicai.springbootviewfreemarker.controller;\n\nimport com.caicai.springbootviewfreemarker.pojo.Users;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author liu\n * @title: UserController\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2820:06\n */\n@Controller\npublic class UserController {\n    @RequestMapping(\"/showuser2\")\n    public String index(Model model){\n        List<Users> list = new ArrayList<>();\n        list.add(new Users(1,\"caicai\",21));\n        list.add(new Users(2,\"honghong\",32));\n        list.add(new Users(3,\"mingming\",43));\n        model.addAttribute(\"list\",list);\n        return \"userList2\";\n    }\n}\n\n```\n\n## 创建Users类:\n\n```java\npackage com.caicai.springbootviewfreemarker.pojo;\n\n/**\n * @author liu\n * @title: Users\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2820:06\n */\npublic class Users {\n    private Integer userid;\n    private String username;\n    private Integer userage;\n\n\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Integer getUserage() {\n        return userage;\n    }\n\n    public void setUserage(Integer userage) {\n        this.userage = userage;\n    }\n\n    public Users() {\n    }\n\n    public Integer getUserid() {\n        return userid;\n    }\n\n    public void setUserid(Integer userid) {\n        this.userid = userid;\n    }\n\n    public Users(Integer userid, String username, Integer userage) {\n        this.userid = userid;\n        this.username = username;\n        this.userage = userage;\n    }\n}\n\n\n```\n\n## 创建启动类\n\n```java\npackage com.caicai.springbootviewfreemarker;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n\n```\n\n\n\n# thymeleaf基本语法:\n\n## 变量输出与字符串操作\n\n### th:text\n\n在页面中输出值\n\n### th:value\n\n可以将一个值放入到 input 标签的 value 中\n\n### 判断字符串是否为空\nThymeleaf 内置对象\n注意语法：\n1，调用内置对象一定要用#\n2，大部分的内置对象都以 s 结尾 strings、numbers、dates\n\n```\n${#strings.isEmpty(key)}\n判断字符串是否为空，如果为空返回 true，否则返回 false\n${#strings.contains(msg,'T')}\n判断字符串是否包含指定的子串，如果包含返回 true，否则返回 false\n${#strings.startsWith(msg,'a')}\n判断当前字符串是否以子串开头，如果是返回 true，否则返回 false\n${#strings.endsWith(msg,'a')}\n判断当前字符串是否以子串结尾，如果是返回 true，否则返回 false\n${#strings.length(msg)}\n返回字符串的长度\n${#strings.indexOf(msg,'h')}\n查找子串的位置，并返回该子串的下标，如果没找到则返回-1\n${#strings.substring(msg,13)}\n${#strings.substring(msg,13,15)}\n截取子串，用户与 jdk String 类下 SubString 方法相同\n${#strings.toUpperCase(msg)}\n${#strings.toLowerCase(msg)}\n字符串转大小写。\n```\n\n\n\n## 日期格式化处理\n\n```\n${#dates.format(key)}\n格式化日期，默认的以浏览器默认语言为格式化标准\n${#dates.format(key,'yyy/MM/dd')}\n按照自定义的格式做日期转换\n${#dates.year(key)}\n${#dates.month(key)}\n${#dates.day(key)}\nyear：取年\nMonth：取月\nDay：取日    \n\n```\n\n## 条件判断\n\n### th:if\n\n```html\n<span th:if=\"${sex} == '男'\">\n    性别男\n</span>\n<span th:if=\"${sex} == '女'\">\n    性别女\n</span>\n```\n\n### th:switch\n\n```html\n<span th:switch=\"${id}\">\n    <span th:case=\"1\">ID 为1</span>\n    <span th:case=\"2\">ID 为2</span>\n    <span th:case=\"2\">ID 为3</span>\n</span>\n```\n\n## 迭代遍历\n\n```html\n<table border=\"1\" align=\"center\" width=\"50%\">\n    <tr>\n        <th>ID</th>\n        <th>Name</th>\n        <th>Age</th>\n    </tr>\n\n    <tr th:each=\"user:${list}\">\n        <td th:text=\"${user.userid}\"></td>\n        <td th:text=\"${user.username}\"></td>\n        <td th:text=\"${user.userage}\"></td>\n    </tr>\n\n</table>\n```\n\n```java\n    @RequestMapping(\"/index\")\n    public String index(Model model){\n        List<Users> list = new ArrayList<>();\n        list.add(new Users(1,\"caicai\",21));\n        list.add(new Users(2,\"honghong\",32));\n        list.add(new Users(3,\"mingming\",43));\n        model.addAttribute(\"list\",list);\n        return \"index\";\n\n    }\n```\n\n状态变量属性\n1,index:当前迭代器的索引 从 0 开始\n2,count:当前迭代对象的计数 从 1 开始\n3,size:被迭代对象的长度\n4,even/odd:布尔值，当前循环是否是偶数/奇数 从 0 开始\n5,first:布尔值，当前循环的是否是第一条，如果是返回 true 否则返回 false\n6,last:布尔值，当前循环的是否是最后一条，如果是则返回 true 否则返回 false\n\n### th:each 迭代Map\n\n```html\n<table border=\"1\">\n    <tr>\n        <th>ID</th>\n        <th>Name</th>\n        <th>Age</th>\n    </tr>\n    <tr th:each=\"maps : ${map}\">\n        <td th:text=\"${maps}\"></td>\n    </tr>\n</table>\n<th/>\n<table border=\"1\">\n    <tr>\n        <th>ID</th>\n        <th>Name</th>\n        <th>Age</th>\n    </tr>\n    <tr th:each=\"maps : ${map}\">\n        <td th:each=\"entry:${maps}\"\n            th:text=\"${entry.value.id}\" ></td>\n        <td th:each=\"entry:${maps}\"\n            th:text=\"${entry.value.name}\"></td>\n        <td th:each=\"entry:${maps}\"\n            th:text=\"${entry.value.age}\"></td>\n    </tr>\n</table>\n```\n\n```java\n\n    @RequestMapping(\"/index3\")\n    public String index3(Model model){\n        Map<String, User> map = new HashMap<>();\n        map.put(\"u1\", new User(1,\"张三\",20));\n        map.put(\"u2\", new User(2,\"李四\",22));\n        map.put(\"u3\", new User(3,\"王五\",24));\n        model.addAttribute(\"map\", map);\n        return \"index3\" ;\n    }\n```\n\n\n\n## 域对象操作\n\n```java\n    @RequestMapping(\"/index4\")\n    public String index4(HttpServletRequest httpServletRequest, Model model){\n        httpServletRequest.setAttribute(\"req\",\"HttpServletRequest\");\n        httpServletRequest.getSession().setAttribute(\"sess\",\"HttpSession\");\n        httpServletRequest.getSession().getServletContext().setAttribute(\"app\",\"Application\");\n        return \"index4\" ;\n    }\n```\n\n```html\n<body>\n<span th:text=\"${#httpServletRequest.getAttribute('req')}\"></span><br>\n<span th:text=\"${session.sess}\"></span><br>\n<span th:text=\"${application.app}\"></span><br>\n</body>\n```\n\n## URL表达式\n\nth:href\nth:src\n\n### URL表达式语法\n\n基本语法：@{}\n\n### URL类型\n\n#### 绝对路径\n\n```html\n<a th:href=\"@{http://www.baidu.com}\">绝对路径</a><br/>\n```\n\n#### 相对路径\n\n1)相对于当前项目的根\n相对于项目的上下文的相对路径\n\n```html\n<a th:href=\"@{/show}\">相对路径</a>\n```\n\n2) 相对于服务器路径的根\n\n```html\n<a th:href=\"@{~/project2/resourcename}\">相对于服务器的根</a>\n```\n\n### 在 url  中实现参数传递\n\n```html\n<a th:href=\"@{/show(id=1,name=zhagnsan)}\">相对路径-传参</a>\n```\n\n###   在 url  中通过 restful  风格进行参数传递\n\n```html\n<a th:href=\"@{/path/{id}/show(id=1,name=zhagnsan)}\"> 相 对 路 径 - 传 参\n-restful</a>\n```\n\n","tags":["Spring Boot","thymeleaf"]},{"title":"Spring Boot 整合Freemarker","url":"/2019/03/28/Spring-Boot-整合Freemarker/","content":"\nFreeMarker 是一个模板引擎，一个基于模板生成文本输出的通用工具，使用纯 Java 编写，FreeMarker 被设计用来生成 HTML Web 页面，特别是基于 MVC 模式的应用程序，虽然 FreeMarker 具有一些编程的能力，但通常由 Java 程序准备要显示的数据，由FreeMarker 生成页面，通过模板显示准备的数据。符合MVC模式，采用哈希表存储，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据\n\n\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 整合Freemarker \n\n## 创建maven项目,添加依赖\n\n```xml\n<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-freemarker</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n```\n\n## 编写视图\n\n在templates/ 下建立 userList.ftl:\n\n```html\n<html>\n\t\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<title>显示用户数据</title>\n\t</head>\n\t<body>\n\t\t<table border=\"1\" align=\"center\" width=\"50%\">\n\t\t\t<tr>\n\t\t\t\t<th>ID</th>\n\t\t\t\t<th>Name</th>\n\t\t\t\t<th>Age</th>\n\t\t\t</tr>\n\n            <#list list as user>\n                <tr>\n                    <td>${user.userid}</td>\n                    <td>${user.username}</td>\n                    <td>${user.userage}</td>\n                </tr>\n            </#list>\n\n\t\t</table>\n\t</body>\n</html>\n\n```\n\n## 创建Controller\n\n```java\npackage com.caicai.springbootviewfreemarker.controller;\n\nimport com.caicai.springbootviewfreemarker.pojo.Users;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author liu\n * @title: UserController\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2820:06\n */\n@Controller\npublic class UserController {\n    /**\n     * 处理请求 产生数据\n     */\n    @RequestMapping(\"/showuser\")\n    public String showUser(Model model){\n        List<Users> list = new ArrayList<>();\n        list.add(new Users(1,\"caicai\",21));\n        list.add(new Users(2,\"honghong\",32));\n        list.add(new Users(3,\"mingming\",43));\n        model.addAttribute(\"list\",list);\n        return \"userList\";\n\n    }\n}\n\n```\n\n## 创建Uesrs类\n\n```java\npackage com.caicai.springbootviewfreemarker.pojo;\n\n/**\n * @author liu\n * @title: Users\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2820:06\n */\npublic class Users {\n    private Integer userid;\n    private String username;\n    private Integer userage;\n\n\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Integer getUserage() {\n        return userage;\n    }\n\n    public void setUserage(Integer userage) {\n        this.userage = userage;\n    }\n\n    public Users() {\n    }\n\n    public Integer getUserid() {\n        return userid;\n    }\n\n    public void setUserid(Integer userid) {\n        this.userid = userid;\n    }\n\n    public Users(Integer userid, String username, Integer userage) {\n        this.userid = userid;\n        this.username = username;\n        this.userage = userage;\n    }\n}\n\n```\n\n## 创建启动类\n\n```java\npackage com.caicai.springbootviewfreemarker;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n\n```\n\n","tags":["Spring Boot"]},{"title":"Spring Boot 整合jsp","url":"/2019/03/28/Spring-Boot-整合jsp/","content":"\n Spring Boot 整合jsp\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 创建maven项目,添加pom依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.1.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.caicai</groupId>\n\t<artifactId>08-spring-boot-view-jsp</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>08-spring-boot-view-jsp</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\n        <!-- tomcat支持 -->\n        <dependency>\n            <groupId>org.apache.tomcat.embed</groupId>\n            <artifactId>tomcat-embed-jasper</artifactId>\n        </dependency>\n        <!-- jstl标签库 -->\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>jstl</artifactId>\n        </dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n\n\n## 创建SpringBoot全局配置\n\napplication.yml:\n\n```xml\nspring:\n  mvc:\n    view:\n      prefix: /WEB-INF/jsp/\n      suffix: .jsp\n```\n\n## 创建Users类\n\n```java\npackage com.caicai.springbootviewjsp.pojo;\n\n/**\n * @author liu\n * @title: Users\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2813:16\n */\npublic class Users {\n    private Integer userid;\n    private String username;\n    private Integer userage;\n\n\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Integer getUserage() {\n        return userage;\n    }\n\n    public void setUserage(Integer userage) {\n        this.userage = userage;\n    }\n\n    public Users() {\n    }\n\n    public Integer getUserid() {\n        return userid;\n    }\n\n    public void setUserid(Integer userid) {\n        this.userid = userid;\n    }\n\n    public Users(Integer userid, String username, Integer userage) {\n        this.userid = userid;\n        this.username = username;\n        this.userage = userage;\n    }\n}\n\n```\n\n\n\n## 创建Controller\n\n```java\npackage com.caicai.springbootviewjsp.controller;\n\nimport com.caicai.springbootviewjsp.pojo.Users;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author liu\n * @title: UserController\n * @projectName 08-spring-boot-view-jsp\n * @description: TODO\n * @date 2019/3/2813:15\n */\n@Controller\npublic class UserController {\n    /**\n     * 处理请求 产生数据\n     */\n    @RequestMapping(\"/showuser\")\n    public String showUser(Model model){\n        List<Users> list = new ArrayList<>();\n        list.add(new Users(1,\"caicai\",21));\n        list.add(new Users(2,\"honghong\",32));\n        list.add(new Users(3,\"mingming\",43));\n        model.addAttribute(\"list\",list);\n        return \"userList\";\n\n    }\n}\n\n```\n\n\n\n## 创建jsp\n\nuserList.jsp:\n\n```xml\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n         pageEncoding=\"UTF-8\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Insert title here</title>\n</head>\n<body>\n    <table border=\"1\" align=\"center\" width=\"50%\">\n        <tr>\n            <th>ID:</th>\n            <th>姓名:</th>\n            <th>年龄</th>\n\n        </tr>\n        <c:forEach items=\"${list}\" var=\"user\">\n        <tr>\n            <td>${user.userid}</td>\n            <td>${user.username}</td>\n            <td>${user.userage}</td>\n        </tr>\n\n\n        </c:forEach>\n    </table>\n</body>\n</html>\n```\n\n\n\n## 创建启动类:\n\n```java\npackage com.caicai.springbootviewjsp;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n\n```\n\n\n\n## 效果图:\n\n![](/Spring-Boot-整合jsp/1.png)","tags":["Spring Boot"]},{"title":"Spring-Boot-文件上传","url":"/2019/03/27/Spring-Boot-文件上传/","content":"\nSpring-Boot-文件上传\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 编写Controller\n\n```java\npackage com.caicai.springbootstaticresources1.controller;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * @author liu\n * @title: FileController\n * @projectName 05-spring-boot-static-resources1\n * @description: TODO\n * @date 2019/3/2719:04\n */\n@RestController\npublic class FileController {\n\n    @RequestMapping(value = \"/fileUploadController\")\n    public String fileUpload(@RequestParam(\"filename\") MultipartFile file){\n        System.out.println(file.getName());\n        try {\n            file.transferTo(new File(\"F:/\"+file.getName()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"success\";\n    }\n}\n\n```\n\n## 编写上传界面\n\n为了方便在static文件夹下建立upload.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>文件上传</title>\n</head>\n<body>\n    <form action=\"fileUploadController\" method=\"post\" enctype=\"multipart/form-data\">\n        上传文件:<input type=\"file\" name=\"filename\">\n        <input type=\"submit\">\n    </form>\n</body>\n</html>\n```\n\n## 设置上传文件大小的默认值\n\n在resources下建立application.yml文件\n\n```xml\nspring:\n  servlet:\n    multipart:\n      max-file-size: 10MB   #设置单个上传文件的大小\n      max-request-size: 100MB  #设置一次请求上传文件的总容量\n      enabled: true\n```\n\n","tags":["Spring Boot"]},{"title":"Spring-Boot 整合Servlet和Filter","url":"/2019/03/27/Spring-Boot-整合Servlet/","content":"\nSpring-Boot 整合Servlet和Filter\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 整合Servlet\n\n## 传统方式配置\n\n```xml\n\n<servlet>\n<servlet-name>FirstServlet</servlet-name>\n<servlet-class>com.caicai.springbootservlet.filter.FirstFilter</servlet-class>\n</servlet>\n\n<servlet-mapping>\n<servlet-name>FirstServlet</servlet-name>\n<url-pattern>/first</url-pattern>\n</servlet-mapping>\n\n```\n\n## 通过注解扫描注册Servlet\n\n使用@WebServlet注解并在启动类上使用@ServletComponentScan注解\n\n```java\n@WebServlet(name = \"FirstServlet\",urlPatterns = \"/first\")\npublic class FirstServlet extends HttpServlet{\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"FirstServlet.....\");\n    }\n}\n```\n\n```java\n@SpringBootApplication\n@ServletComponentScan //在SpringBoot启动时会扫描@WebServlet注解 并将该类实例化\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n```\n\n## 通过方法完成Servlet组件的注册\n\n通过使用@Bean注解的形式注册组件\n\n```java\npublic class SecondServlet extends HttpServlet{\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"SecondServlet.....\");\n    }\n}\n```\n\n```java\n@SpringBootApplication\npublic class App2 {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Bean\n    public ServletRegistrationBean getServletRegistrationBean() {\n        ServletRegistrationBean bean = new ServletRegistrationBean(new SecondServlet());\n        bean.addUrlMappings(\"/second\");//添加url路径\n        return bean;\n    }\n}\n```\n\n\n\n\n\n# 整合Filter\n\n## 传统方式配置\n\n```xml\n<filter>\n<filter-name>FirstFilter</filter-name>\n<filter-class>com.caicai.springbootservlet.filter.FirstFilter</filter-class>\n</filter>\n<filter-mapping>\n<filter-name>FirstFilter</filter-name>\n<url-pattern>/filter1</url-pattern>\n</filter-mapping>\n\n```\n\n\n\n## 通过注解扫描注册Servlet\n\n```java\npackage com.caicai.springbootservlet.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n/**\n * @author liu\n * @title: FirstFilter\n * @projectName 02-spring-boot-servlet\n * @description: TODO\n * @date 2019/3/2718:19\n */\n//@WebFilter(filterName = \"\",urlPatterns ={\"*.do\",\"*.jsp\"})\n@WebFilter(filterName = \"FirstFilter\",urlPatterns =\"/filter1\")\npublic class FirstFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println(\"init.......\");\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"进入filter.......\");\n        filterChain.doFilter(servletRequest,servletResponse);\n        System.out.println(\"离开filter.......\");\n\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(\"destroy.......\");\n\n    }\n}\n\n```\n\n启动类:\n\n````java\npackage com.caicai.springbootservlet;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.web.servlet.ServletComponentScan;\n\n@SpringBootApplication\n@ServletComponentScan //在SpringBoot启动时会扫描@WebServlet注解 并将该类实例化\npublic class App3 {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(App3.class, args);\n\t}\n\n}\n\n````\n\n## 通过方法完成Filter的注册\n\n```java\npackage com.caicai.springbootservlet.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n/**\n * @author liu\n * @title: SecondFilter\n * @projectName 02-spring-boot-servlet\n * @description: TODO\n * @date 2019/3/2718:19\n */\n\npublic class SecondFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println(\"init.......\");\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"进入filter2.......\");\n        filterChain.doFilter(servletRequest,servletResponse);\n        System.out.println(\"离开filter2.......\");\n\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(\"destroy.......\");\n\n    }\n}\n\n```\n\n```java\npackage com.caicai.springbootservlet;\n\nimport com.caicai.springbootservlet.filter.SecondFilter;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\n\n@SpringBootApplication\npublic class App4 {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(App4.class, args);\n\t}\n\n\t@Bean\n\tpublic FilterRegistrationBean filterRegistrationBean(){\n        FilterRegistrationBean bean = new FilterRegistrationBean(new SecondFilter()) ;\n        bean.addUrlPatterns(\"/filter2\");\n        return bean;\n    }\n\n}\n```\n\n","tags":["Spring Boot","Servlet"]},{"title":"String，StringBuilder，StringBuffer三者的区别","url":"/2019/03/26/string相关/","content":"\n最近突然被问起String，StringBuilder，StringBuffer三者的区别,发现自己确实对这方面的知识不是很了解.所以学习了一下做个笔记.\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## String\n\n+ String 类是一个常量，String类本身和其中存储字符的数组都是用final关键字修饰的,所以不能被继承\n\n```java\n    /** The value is used for character storage. */\n    private final char value[];\n```\n\n### String str=\"hello world\"和String str=new String(\"hello world\")的区别\n\n\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        String string1 = \"hello word\";\n        String string2 = new String(\"hello world\");\n        String string3 = \"hello word\";\n        String string4 = new String(\"hello world\");\n        System.out.println(string1 == string2);\n        System.out.println(string1 == string3);\n        System.out.println(string2 == string4);\n    }\n}\n\n```\n\n上面代码的输出结果为:\n\nfalse\n\ntrue\n\nfalse\n\n我们发现 同样都都是\"helllo world\" string1 和 string3 相等.是因为string1 和 string3 都是赋值为一个字面常量\"hello world\",在JVM运行时候,会在常量池里寻找是否已经存在相同的常量,如果存在便直接将引用指向已有常量,否则就创建一个常量,并且将引用指向他,对于string2 和string4来说,两者都是采取了new 来创建的,是两个不同的对象,所以不相等.\n\n## StringBuilder\n\n\n\n在第二点中,我们看到String是一个final类,打开StringBuilder,我们发现StringBuilder类是AbstractStringBuilder的子类,在AbstractStringBuilder类中,我们看到与String不同,StringBuilder存储字符的数组是可变的\n\n```java\n  /**\n     * The value is used for character storage.\n     */\n    char[] value;\n```\n\n## StringBuilder和String 区别\n\n\n\n对于实际应用来说 假设有如下代码\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        String string = \"\";\n        for (int i = 0; i < 1000; i++) {\n            string += \"A\";\n        }\n\n\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i < 1000; i++) {\n            stringBuilder.append(\"A\");\n        }\n    }\n}\n\n```\n\n上述代码进行了一个1000次的循环,每次在字符串string后面追加一个字符A,无论使用的是String,还是StringBuilder,最后的结果都为长度为1000的字符全为A的字符串.而不同的是,如果使用StringBuilder,append操作是在原有的对象基础上进行的,而使用String每次循环都会新建一个StringBuilder对象,进行append操作,通过toString方法返回String对象,如果这些对象没有被回收会浪费大量资源,\n\n## StringBuilder和StringBuffer区别\n\n对比StringBuilder和StringBuffer源码,我们发现在StringBuffer中很多方法都加上了synchronized关键字,所以StringBuffer是线程安全的,不过相应的,在提升了安全的同时对资源的消耗也会增大\n\n```java\n        /**\n         * StringBuffer append方法\n         */\n        @Override\n        public synchronized StringBuffer append (String str){\n            toStringCache = null;\n            super.append(str);\n            return this;\n        }\n        \n        /**\n         * StringBuilder append方法\n         */\n\n        @Override\n        public StringBuilder append (String str){\n            super.append(str);\n            return this;\n        }\n```\n\n## 结论\n\n三个类应当根据不同的情况来进行选择使用：\n\n当字符串相加操作或者改动较少的情况下，建议使用 String str=\"hello\"这种形式\n\n当字符串相加操作较多的情况下，建议使用StringBuilder\n\n如果采用了多线程，则使用StringBuffer。\n\n","tags":["java","String"]},{"title":"swagger2","url":"/2019/03/19/swagger2/","content":"\nSwagger 是一款RESTFUL接口的、基于YAML、JSON语言的文档在线自动生成、代码自动生成的工具。\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 关于Swagger\n\n\n\nSwagger能成为最受欢迎的REST APIs文档生成工具之一，有以下几个原因：\n\n- Swagger 可以生成一个具有互动性的API控制台，开发者可以用来快速学习和尝试API。\n- Swagger 可以生成客户端SDK代码用于各种不同的平台上的实现。\n- Swagger 文件可以在许多不同的平台上从代码注释中自动生成。\n- Swagger 有一个强大的社区，里面有许多强悍的贡献者。\n\nSwagger 文档提供了一个方法，使我们可以用指定的 JSON 或者 YAML 摘要来描述你的 API，包括了比如 names、order 等 API 信息。\n\n你可以通过一个文本编辑器来编辑 Swagger 文件，或者你也可以从你的代码注释中自动生成。各种工具都可以使用 Swagger 文件来生成互动的 API 文档。\n\n> 注意：用 Swagger 文件生成互动的 API 文档是最精简的，它展示了资源、参数、请求、响应。但是它不会提供你的API如何工作的其他任何一个细节。\n\n## Spring Boot集成使用Swagger\n\n### 创建Spring Boot Web工程并且引入Swagger依赖\n\n所需Swagger依赖可以在[Maven仓库](https://mvnrepository.com/) 中找查询\n\n```xml\n        <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 -->\n        <dependency>\n            <groupId>io.springfox</groupId>\n            <artifactId>springfox-swagger2</artifactId>\n            <version>2.9.2</version>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui -->\n        <dependency>\n            <groupId>io.springfox</groupId>\n            <artifactId>springfox-swagger-ui</artifactId>\n            <version>2.9.2</version>\n        </dependency>\n\n```\n\n### 创建User实体类\n\n```java\npackage com.example.demo.domain;\n\n/**\n * @author liu\n * @title: User\n * @projectName demo\n * @description: TODO\n * @date 2019/3/1821:52\n */\npublic class User {\n    private Long id;\n    private String username;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                '}';\n    }\n}\n\n```\n\n### 在启动类目录创建Swagger2配置类\n\n```java\npackage com.example.demo;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n@Configuration\n@EnableSwagger2\npublic class Swagger2  {\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(\"com.example.demo.controller\"))//扫描controller下的包\n                .paths(PathSelectors.any())\n                .build();\n    }\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                .title(\"Spring Boot中使用Swagger2构建RESTful APIs\")\n                .description(\"swagger2 构建APIS\")\n                .version(\"1.0\")\n                .build();\n    }\n}\n```\n\n### 创建UserController类\n\n```java\npackage com.example.demo.controller;\n\nimport com.example.demo.domain.User;\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiImplicitParam;\nimport io.swagger.annotations.ApiImplicitParams;\nimport io.swagger.annotations.ApiOperation;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author liu\n * @title: HelloController\n * @projectName demo\n * @description: TODO\n * @date 2019/3/1821:48\n */\n@RestController\n@Api(tags = \"用户模块\")\n@RequestMapping(value = \"/user\")\npublic class UserController {\n    /**\n     * 此处为了方便直接用一个Map来模拟数据库进行操作\n     */\n    static Map<Long, User> userMap;\n\n    static {\n        userMap = new HashMap<>();\n        User user = new User();\n        user.setId((long) 10000);\n        user.setUsername(\"admin\");\n        userMap.put((long) 10000,user);\n    }\n\n    @ApiOperation(value = \"获取用户列表\")\n    @RequestMapping(value = \"list\", method = RequestMethod.GET)\n    public List<User> getUserList() {\n\n        return new ArrayList<User>(userMap.values());\n    }\n\n\n    @ApiOperation(value = \"创建用户\")\n    @ApiImplicitParams({@ApiImplicitParam(paramType = \"query\", name = \"id\", dataType = \"Long\", required = true, value = \"用户id\", defaultValue = \"10001\"),\n            @ApiImplicitParam(paramType = \"query\", name = \"username\", dataType = \"String\", required = true, value = \"用户名字\", defaultValue = \"菜菜\")\n    })\n    @RequestMapping(value = \"\", method = RequestMethod.POST)\n    public String postUser(User user) {\n\n        userMap.put(user.getId(),user);\n        return \"添加成功\";\n    }\n\n\n\n    @ApiOperation(value = \"获取用户\")\n    @ApiImplicitParam(paramType = \"query\", required = true, name = \"id\", dataType = \"Long\", value = \"用户id\")\n    @RequestMapping(value = \"\", method = RequestMethod.GET)\n    public User getUser(@RequestParam(\"id\") Long id) {\n        System.out.println(id);\n        return userMap.get(id);\n    }\n\n\n\n    @ApiOperation(value = \"更新用户\")\n    @ApiImplicitParams({@ApiImplicitParam(paramType = \"query\", name = \"id\", dataType = \"Long\", required = true, value = \"用户id\", defaultValue = \"10001\"),\n            @ApiImplicitParam(paramType = \"query\", name = \"username\", dataType = \"String\", required = true, value = \"用户名字\", defaultValue = \"菜菜\")\n    })\n    @RequestMapping(value = \"\", method = RequestMethod.PUT)\n    public String putUser(User user) {\n        userMap.put(user.getId(),user);\n        return \"更新成功\";\n    }\n\n\n    @ApiOperation(value = \"删除用户\")\n    @ApiImplicitParam(paramType = \"query\", required = true, name = \"id\", dataType = \"Long\", value = \"用户id\")\n    @RequestMapping(value = \"\", method = RequestMethod.DELETE)\n    public String deleteUser(@RequestParam(\"id\") Long id) {\n        userMap.remove(id);\n        return \"删除成功\";\n    }\n}\n\n```\n\n### 测试:\n\n主界面:\n\n![主界面](/swagger2简介/1.png)\n\n查询用户列表:\n\n![](/swagger2简介/2.png)\n\n创建用户:\n\n![](/swagger2简介/3.png)\n\n获取用户:\n\n![](/swagger2简介/4.png)\n\n删除用户:\n\n![](/swagger2简介/5.png)\n\n## 使用过程中遇到的问题\n\n(1)java.lang.NumberFormatException: For input string: \"\"\n\n在使用@ApiModelProperty注解在字段上时，如果字段的类型为Long或是int类型，那么程序启动后，访问swagger-ui.html的页面，程序会报错\n\njava.lang.NumberFormatException: For input string: \"\"\n在swagger的官方文档中介绍是一个bug；可以忽略这个错误，如果看着不爽，可以调整日志的级别\n\napplication.yml:\n\n```xml\nlogging:\n  level:\n    io.swagger.models.parameters.AbstractSerializableParameter: error\n```\n\n\n\n(2)@Api()注解中使用tags = \"\"参数才能改变api名字 例如@Api(tags = \"用户模块\")\n\n\n\n(3)requestparam 和pathvariable区别 :\n\n@PathVariable:从路径路去获取变量,也就是把路径名当作变量 例如:\n\n```xml\nhttp://localhost:8080/user?id=5\n```\n\n@RequestParam:从请求里面获取参数,例如:\n\n```xml\nhttp://localhost:8080/user?5\n```\n\n","tags":["Spring Boot","swagger"]},{"title":"mysql的时区错误问题： The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one","url":"/2019/03/18/mysql的时区错误问题：-The-server-time-zone-value-OÐ¹u±e×¼E±¼a-is-unrecognized-or-represents-more-than-one/","content":"\n链接数据库时候出现cexception is org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException:\n\n <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n## spring boot 链接数据库的时候报错\n\n```java\ncexception is org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: \n### Error querying database.  Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Connections could not be acquired from the underlying database!\n### The error may exist in com/wj/mapper/UserLoginMapper.xml\n### The error may involve com.wj.mapper.UserLoginMapper.selectByName\n### The error occurred while executing a query\n### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Connections could not be acquired from the underlying database!\n    org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:982)\n    org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872)\n    javax.servlet.http.HttpServlet.service(HttpServlet.java:650)\n    org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)\n    javax.servlet.http.HttpServlet.service(HttpServlet.java:731)\n```\n```java\njava.sql.SQLException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:127)\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:95)\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:87)\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:61)\n    com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:71)\n    com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:76)\n    com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:862)\n    com.mysql.cj.jdbc.ConnectionImpl.<init>(ConnectionImpl.java:444)\n    com.mysql.cj.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:230)\n    com.mysql.cj.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:226)\n    com.mchange.v2.c3p0.DriverManagerDataSource.getConnection(DriverManagerDataSource.java:175)\n    com.mchange.v2.c3p0.WrapperConnectionPoolDataSource.getPooledConnection(WrapperConnectionPoolDataSource.java:220)\n    com.mchange.v2.c3p0.WrapperConnectionPoolDataSource.getPooledConnection(WrapperConnectionPoolDataSource.java:206)\n    com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool$1PooledConnectionResourcePoolManager.acquireResource(C3P0PooledConnectionPool.java:203)\n    com.mchange.v2.resourcepool.BasicResourcePool.doAcquire(BasicResourcePool.java:1138)\n    com.mchange.v2.resourcepool.BasicResourcePool.doAcquireAndDecrementPendingAcquiresWithinLockOnSuccess(BasicResourcePool.java:1125)\n    com.mchange.v2.resourcepool.BasicResourcePool.access$700(BasicResourcePool.java:44)\n    com.mchange.v2.resourcepool.BasicResourcePool$ScatteredAcquireTask.run(BasicResourcePool.java:1870)\n    com.mchange.v2.async.ThreadPoolAsynchronousRunner$PoolThread.run(ThreadPoolAsynchronousRunner.java:696)\n```\n## 解决方案:\n\n据查询是因为电脑的时区和mysql的时区不一样导致的\n用 打开mysql \n\n```sql\nshow variables like '%time_zone%'; //查询mysql的时区\nset global time_zone='+8:00'; //设置时区\n```","tags":["MYSQL","Spring Boot"]},{"title":"navicat 连接 mysql   Client does not support authentication protocol requested by server","url":"/2019/03/18/navicat-连接-mysql-Client-does-not-support-authentication-protocol-requested-by-server/","content":"\nClient does not support authentication protocol requested by server; consider upgrading MySQL client\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 报错信息:\n\n```java\nClient does not support authentication protocol requested by server; consider upgrading MySQL client\n```\n\n## 解决方案:\n\n打开mysql的MySQL Command Line Client 输入:\n```\nUSE mysql;\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';\nFLUSH PRIVILEGES; \n```\n\nlocalhost:本机地址\n123456:要设置的密码","tags":["MYSQL"]},{"title":"hexo 常用命令","url":"/2019/03/18/hexo-常用命令/","content":"\nhexo 的一些常用命令\n\n<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## hexo\n\n```\nnpm install hexo -g #安装  \nnpm update hexo -g #升级  \nhexo init #初始化\n```\n\n## 简写\n\n`hexo n \"我的博客\"` == `hexo new \"我的博客\"` #新建文章\n`hexo p` == `hexo publish`\n`hexo g` == `hexo generate`#生成\n`hexo s` == `hexo server` #启动服务预览\n`hexo d` == `hexo deploy`#部署\n\n## 服务器\n\n`hexo server` #Hexo 会监视文件变动并自动更新，您无须重启服务器。\n`hexo server -s` #静态模式\n`hexo server -p 5000` #更改端口\n`hexo server -i 192.168.1.1` #自定义 IP\n\n`hexo clean` #清除缓存 网页正常情况下可以忽略此条命令\n`hexo g` #生成静态网页\n`hexo d` #开始部署\n\n### 监视文件变动\n\n`hexo generate` #使用 Hexo 生成静态文件快速而且简单\n`hexo generate --watch` #监视文件变动\n\n### 完成后部署\n\n> 两个命令的作用是相同的\n> `hexo generate --deploy`\n> `hexo deploy --generate`\n\n```\nhexo deploy -g`\n`hexo server -g\n```\n\n## 草稿\n\n```\nhexo publish [layout] <title>\n```\n\n## 模版\n\n`hexo new \"postName\"` #新建文章\n`hexo new page \"pageName\"` #新建页面\n`hexo generate` #生成静态页面至public目录\n`hexo server` #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n`hexo deploy` #将.deploy目录部署到GitHub\n\n```\nhexo new [layout] <title>`\n`hexo new photo \"My Gallery\"`\n`hexo new \"Hello World\" --lang tw\n```\n\n| 变量   | 描述         |\n| ------ | ------------ |\n| layout | 布局         |\n| title  | 标题         |\n| date   | 文件建立日期 |\n\n```\ntitle: 使用Hexo搭建个人博客\nlayout: post\ndate: 2019-03-18 14:59:30\ncomments: true\ncategories: Blog\ntags: [Hexo]\nkeywords: Hexo, Blog\ndescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。\n```\n\n## 模版（Scaffold）\n\n```\nhexo new photo \"My Gallery\"\n```\n\n| 变量   | 描述         |\n| ------ | ------------ |\n| layout | 布局         |\n| title  | 标题         |\n| date   | 文件建立日期 |\n\n## 设置文章摘要\n\n```\n以上是文章摘要 <!--more--> 以下是余下全文 \n```\n\n## 写作\n\n```\nhexo new page <title>`\n`hexo new post <title>\n```\n\n| 变量     | 描述                       |\n| -------- | -------------------------- |\n| :title   | 标题                       |\n| :year    | 建立的年份（4 位数）       |\n| :month   | 建立的月份（2 位数）       |\n| :i_month | 建立的月份（去掉开头的零） |\n| :day     | 建立的日期（2 位数）       |\n| :i_day   | 建立的日期（去掉开头的零） |\n\n### 推送到服务器上\n\n```\nhexo n` #写文章\n`hexo g` #生成\n`hexo d` #部署 #可与`hexo g`合并为 `hexo d -g\n```\n\n## 报错\n\n### 1.找不到git部署\n\n```\nERROR Deployer not found: git\n```\n\n**解决方法**\n\n```\nnpm install hexo-deployer-git --save\n```\n\n### 3.部署类型设置git\n\nhexo 3.0 部署类型不再是`github`，`_config.yml` 中修改\n\n```\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@***.github.com:***/***.github.io.git\n  branch: master\n```\n\n### 4. xcodebuild\n\nxcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance\n\n```\nnpm install bcrypt\n```\n\n### 5. RSS不显示\n\n#### 安装RSS插件\n\n```\nnpm install hexo-generator-feed --save\n```\n\n#### 开启RSS功能\n\n编辑hexo/_config.yml，添加如下代码：\n\n```\nrss: /atom.xml #rss地址  默认即可\n```","tags":["hexo"]}]